<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kitect 3D JSON Studio</title>
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            /* NgƒÉn cu·ªôn ·ªü body */
        }

        header {
            background-color: #333;
            color: white;
            padding: 10px 20px;
            text-align: center;
            position: relative;
            /* ƒê·∫£m b·∫£o absolute positioning c·ªßa children l√† relative to header */
            display: flex;
            /* S·ª≠ d·ª•ng Flexbox */
            justify-content: space-between;
            /* CƒÉn ƒë·ªÅu c√°c nh√≥m controls */
            align-items: center;
            /* CƒÉn gi·ªØa theo chi·ªÅu d·ªçc */
        }

        header button,
        header .btn {
            /* Target Bootstrap buttons in header too */
            /* Style chung cho c√°c button trong header */
            padding: 0.25rem 0.5rem;
            /* ƒêi·ªÅu ch·ªânh padding ƒë·ªÉ gi·∫£m chi·ªÅu cao */
            /* background-color: #007bff; */
            /* Bootstrap handles this */
            font-size: 0.9em;
            /* color: white; */
            /* Bootstrap handles this */
            /* border: none; */
            /* Bootstrap handles this */
            border-radius: 3px;
            cursor: pointer;
            margin-left: 5px;
            /* Kho·∫£ng c√°ch gi·ªØa c√°c button trong c√πng m·ªôt nh√≥m */
        }

        #importJsonBtn {
            white-space: nowrap;
        }

        #uploadJsonBtn {
            white-space: nowrap;
        }

        /* header button:hover {
            background-color: #0056b3;
        } */
        /* Bootstrap handles this */

        .header-controls-group {
            display: flex;
            /* Cho ph√©p c√°c button trong nh√≥m n·∫±m tr√™n m·ªôt h√†ng */
            align-items: center;
        }

        /* C√≥ th·ªÉ th√™m style c·ª• th·ªÉ cho input-controls v√† output-controls n·∫øu c·∫ßn */
        #create2DXmlBtn {
            background-color: red;
            /* Keep this specific style if needed */
        }

        .main-container {
            display: flex;
            flex-grow: 1;
            overflow: hidden;
            /* Cho ph√©p c√°c panel con cu·ªôn */
            padding: 10px;
            gap: 10px;
        }

        .panel {
            background-color: white;
            border-radius: 5px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.1);
            padding: 15px;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            /* Cho ph√©p cu·ªôn n·ªôi dung panel */
        }

        #shapes-panel {
            flex: 0 0 250px;
            /* ƒê·ªô r·ªông c·ªë ƒë·ªãnh cho panel shapes */
        }

        #editor-panel {
            flex-grow: 1;
            /* Panel editor chi·∫øm ph·∫ßn c√≤n l·∫°i */
        }

        #viewer-3d-panel {
            flex-grow: 2;
            /* Cho panel 3D chi·∫øm nhi·ªÅu kh√¥ng gian h∆°n */
            min-width: 300px;
            /* ƒê·∫£m b·∫£o c√≥ kh√¥ng gian t·ªëi thi·ªÉu cho view 3D */
            position: relative;
            /* ƒê·ªÉ canvas c√≥ th·ªÉ ƒë∆∞·ª£c ƒë·ªãnh v·ªã tuy·ªát ƒë·ªëi b√™n trong */
        }

        #viewer-3d-panel canvas {
            display: block;
            /* Lo·∫°i b·ªè kho·∫£ng tr·∫Øng th·ª´a b√™n d∆∞·ªõi canvas */
            width: 100% !important;
            /* Ghi ƒë√® style m·∫∑c ƒë·ªãnh c·ªßa three.js n·∫øu c√≥ */
            height: 100% !important;
        }

        textarea {
            width: calc(100% - 10px);
            /* ƒêi·ªÅu ch·ªânh ƒë·ªÉ padding kh√¥ng l√†m v·ª° layout */
            flex-grow: 1;
            margin-top: 10px;
            border: 1px solid #ccc;
            border-radius: 3px;
            padding: 5px;
            font-family: monospace;
            resize: none;
            /* Kh√¥ng cho ph√©p resize textarea */
        }

        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 3px;
            cursor: pointer;
            margin-top: 5px;
            margin-bottom: 10px;
        }

        button:hover {
            background-color: #0056b3;
        }

        .shape-item {
            padding: 8px;
            border: 1px solid #eee;
            border-radius: 3px;
            margin-bottom: 5px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .shape-item:hover,
        .shape-item.selected {
            background-color: #e9ecef;
        }

        .shape-item button {
            background-color: #dc3545;
            padding: 3px 6px;
            font-size: 0.8em;
            margin: 0;
        }

        .shape-item button:hover {
            background-color: #c82333;
        }

        .section {
            margin-bottom: 15px;
            border: 1px solid #ddd;
            padding: 10px;
            border-radius: 3px;
        }

        .section h3 {
            margin-top: 0;
            font-size: 1.1em;
            color: #333;
        }

        label {
            display: block;
            margin-bottom: 3px;
            font-size: 0.9em;
            color: #555;
        }

        input[type="text"],
        input[type="number"] {
            width: calc(100% - 12px);
            /* width - padding */
            padding: 5px;
            margin-bottom: 8px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }

        .vertex-entry,
        .face-entry,
        .line-entry {
            display: flex;
            gap: 5px;
            align-items: center;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        .vertex-entry input[type="number"] {
            width: 50px;
        }

        .face-entry input[type="text"] {
            flex-grow: 1;
        }

        .vertex-list,
        .face-list,
        .line-list {
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid #eee;
            padding: 5px;
            margin-bottom: 10px;
        }

        .hidden {
            display: none;
        }

        /* Toast Styling */
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1050;
            /* Ensure toast is above other elements, including modals (Bootstrap modal z-index is 1040/1050) */
        }
        /* Styles for Shape Canvas Modal */
        .fullscreen-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 1060; /* Ensure it's above Bootstrap modals (1050) */
            display: none; /* Hidden by default */
            align-items: center;
            justify-content: center;
        }
        .modal-content-wrapper {
            background-color: #fff;
            width: 98%;
            height: 98%;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,.5);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .modal-header-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem;
            border-bottom: 1px solid #dee2e6;
        }
        .modal-header-controls h5 {
            margin-bottom: 0;
        }
        .modal-main-content {
            display: flex;
            flex-grow: 1;
            height: calc(100% - 70px); /* Adjust based on header height + padding */
            overflow: hidden; /* Prevent scrollbars on this container */
        }
        .modal-canvas-section {
            flex: 3;
            padding: 1rem;
            border-right: 1px solid #dee2e6;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden; /* Canvas itself might scroll if larger than container */
            background-color: #f8f9fa; /* Light background for canvas area */
        }
        #shapeDetailCanvas {
            max-width: 100%;
            max-height: 100%;
            border: 1px solid #ced4da;
            background-color: white;
        }
        .modal-info-section {
            flex: 1;
            padding: 1rem;
            overflow-y: auto;
            background-color: #fff;
        }
        .modal-info-section h5 {
            margin-top: 0;
            margin-bottom: 0.75rem;
        }
        .modal-info-section p {
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }
    </style>
</head>

<body>
    <header>
        <h1>Kitect 3D JSON Studio</h1>
        <div class="header-controls-group input-controls">
            <input type="text" id="objectNameInput" class="form-control form-control-sm mr-2"
                placeholder="Nh·∫≠p Object Name (v√≠ d·ª•: PFHP-PILLAR-B)" value="OBJECT-NAME">
            <button id="importJsonBtn" class="btn btn-primary btn-sm">ƒê·ªçc Clipboard</button>
            <input type="file" id="uploadJsonFile" accept=".json" style="display: none;">
            <button id="uploadJsonBtn" class="btn btn-secondary btn-sm ml-2">Upload File</button>
        </div>
        <div class="header-controls-group main-actions">
            <button id="openOptionsModalBtn" class="btn btn-info btn-sm mr-2" data-toggle="modal"
                data-target="#optionsModal">T√πy ch·ªçn & Sao ch√©p</button>
            <button id="create2DXmlBtn" class="btn btn-danger btn-sm"
                onclick="window.open('./generate-2d-xml.html', '_blank')">Create 2D XML</button>
        </div>
    </header>
    <div class="main-container">
        <div id="shapes-panel" class="panel">
            <h2>Shapes</h2>
            <button id="addShapeBtn">Th√™m Shape M·ªõi</button>
            <div id="shapesListContainer">
                <!-- Danh s√°ch shapes s·∫Ω ƒë∆∞·ª£c th√™m v√†o ƒë√¢y b·∫±ng JavaScript -->
            </div>
            <div id="noShapeSelectedMsg">
                <p>Vui l√≤ng ch·ªçn m·ªôt shape t·ª´ danh s√°ch ho·∫∑c th√™m shape m·ªõi ƒë·ªÉ b·∫Øt ƒë·∫ßu ch·ªânh s·ª≠a.</p>
            </div>
        </div>

        <div id="editor-panel" class="panel">
            <h2 style="display: flex; align-items: center; justify-content: space-between;"><span>Editor</span><button id="openShapeCanvasModalBtn" class="btn btn-sm btn-light ml-2" style="display: none; padding: 2px 6px; line-height: 1;" title="M·ªü tr√¨nh ch·ªânh s·ª≠a canvas"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-pencil-square" viewBox="0 0 16 16"><path d="M15.502 1.94a.5.5 0 0 1 0 .706L14.459 3.69l-2-2L13.502.646a.5.5 0 0 1 .707 0l1.293 1.293zm-1.75 2.456-2-2L4.939 9.21a.5.5 0 0 0-.121.196l-.805 2.414a.25.25 0 0 0 .316.316l2.414-.805a.5.5 0 0 0 .196-.12l6.813-6.813z"/><path fill-rule="evenodd" d="M1 13.5A1.5 1.5 0 0 0 2.5 15h11a1.5 1.5 0 0 0 1.5-1.5v-6a.5.5 0 0 0-1 0v6a.5.5 0 0 1-.5.5h-11a.5.5 0 0 1-.5-.5v-11a.5.5 0 0 1 .5-.5H9a.5.5 0 0 0 0-1H2.5A1.5 1.5 0 0 0 1 2.5z"/></svg></button></h2>
            <div id="shapeEditorContainer" class="hidden">
                <div class="section">
                    <h3>Th√¥ng tin Shape</h3>
                    <p><strong>T√™n Shape (Line Mode):</strong> <span id="generatedShapeNameLine"></span></p>
                    <p><strong>T√™n Shape (Std Mode):</strong> <span id="generatedShapeNameStd"></span></p>

                    <label for="stdMaterialInput">Std Material:</label>
                    <input type="text" id="stdMaterialInput" placeholder="V√≠ d·ª•: R110-0">

                    <h4>Deform Types</h4>
                    <div style="margin-bottom: 10px;">
                        <label style="display: inline-block; margin-right: 10px;">
                            <input type="checkbox" id="deformStretch2Checkbox"> Stretch2
                        </label>
                        <label style="display: inline-block;">
                            <input type="checkbox" id="deformClippingCheckbox"> Clipping
                        </label>
                    </div>
                    <div style="margin-bottom: 10px; font-size: 0.9em; color: #333;">
                        <strong>Current Deform Types:</strong> <span id="currentDeformTypesText"></span>
                    </div>

                    <h4>Custom Pivot (T·ªça ƒë·ªô Local c·ªßa Shape)</h4>
                    <div style="display: flex; gap: 5px; margin-bottom: 10px;">
                        <div style="flex: 1;">
                            <label for="pivotX">Pivot X:</label>
                            <input type="number" id="pivotX" value="0" step="1">
                        </div>
                        <div style="flex: 1;">
                            <label for="pivotY">Pivot Y:</label>
                            <input type="number" id="pivotY" value="0" step="1">
                        </div>
                        <div style="flex: 1;">
                            <label for="pivotZ">Pivot Z:</label>
                            <input type="number" id="pivotZ" value="0" step="1">
                        </div>
                    </div>
                </div>

                <div class="section">
                    <h3>Vertices (v)</h3>
                    <button id="addVertexBtn">Th√™m Vertex</button>
                    <div class="vertex-list" id="verticesList">
                        <!-- Vertices s·∫Ω ƒë∆∞·ª£c th√™m v√†o ƒë√¢y -->
                    </div>
                </div>

                <div class="section">
                    <h3>Faces</h3>
                    <label for="faceVertices">Vertices (ch·ªâ s·ªë, c√°ch nhau b·ªüi d·∫•u ph·∫©y):</label>
                    <input type="text" id="faceVertices" placeholder="V√≠ d·ª•: 0,1,13,12">
                    <button id="addFaceBtn">Th√™m Face</button>
                    <div class="face-list" id="facesListContainer">
                        <!-- Faces s·∫Ω ƒë∆∞·ª£c th√™m v√†o ƒë√¢y -->
                    </div>
                </div>

                <div class="section">
                    <h3>Lines</h3>
                    <label for="lineVerticesInput">Vertices (ID ƒë·ªânh 1, ID ƒë·ªânh 2, c√°ch nhau b·ªüi d·∫•u ph·∫©y):</label>
                    <input type="text" id="lineVerticesInput" placeholder="V√≠ d·ª•: 0,1">
                    <button id="addLineBtn">Th√™m Line</button>
                    <div class="line-list" id="linesListContainer">
                        <!-- Lines s·∫Ω ƒë∆∞·ª£c th√™m v√†o ƒë√¢y -->
                    </div>
                </div>

                <div class="section" id="transformationsSection">
                    <h3>Ph√©p bi·∫øn ƒë·ªïi (Transformations)</h3>

                    <div class="subsection">
                        <h4>T·ªãnh ti·∫øn (Translate)</h4>
                        <label for="translateX">Delta X:</label>
                        <input type="number" id="translateX" value="0" step="1">
                        <label for="translateY">Delta Y:</label>
                        <input type="number" id="translateY" value="0" step="1">
                        <label for="translateZ">Delta Z:</label>
                        <input type="number" id="translateZ" value="0" step="1">
                        <button id="applyTranslateBtn">√Åp d·ª•ng T·ªãnh ti·∫øn</button>
                    </div>

                    <div class="subsection">
                        <h4>Xoay quanh t√¢m Shape (Rotate around Shape Center)</h4>
                        <p style="font-size:0.8em; color:#555;">ƒê∆°n v·ªã: ƒê·ªô. Th·ª© t·ª± xoay: X -> Y -> Z.</p>
                        <label for="rotateX">G√≥c X:</label>
                        <input type="number" id="rotateX" value="0" step="1">
                        <label for="rotateY">G√≥c Y:</label>
                        <input type="number" id="rotateY" value="0" step="1">
                        <label for="rotateZ">G√≥c Z:</label>
                        <input type="number" id="rotateZ" value="0" step="1">
                        <button id="applyRotateBtn">√Åp d·ª•ng Xoay</button>
                    </div>

                    <div class="subsection">
                        <h4>L·∫≠t qua t√¢m Shape (Flip around Shape Center)</h4>
                        <button id="flipXBtn">L·∫≠t qua tr·ª•c X (YZ plane)</button>
                        <button id="flipYBtn">L·∫≠t qua tr·ª•c Y (XZ plane)</button>
                        <button id="flipZBtn">L·∫≠t qua tr·ª•c Z (XY plane)</button>
                    </div>
                </div>

            </div>
        </div>

        <div id="viewer-3d-panel" class="panel">
            <h2>3D View</h2>
            <div id="threejs-canvas-container" style="width: 100%; height: calc(100% - 40px);">
                <!-- Canvas cho Three.js s·∫Ω ƒë∆∞·ª£c th√™m v√†o ƒë√¢y -->
            </div>
        </div>
    </div>

    <!-- Toast Container -->
    <div aria-live="polite" aria-atomic="true" class="toast-container">
        <!-- Toasts will be appended here -->
    </div>

    <!-- Options Modal -->
    <div class="modal fade" id="optionsModal" tabindex="-1" aria-labelledby="optionsModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="optionsModalLabel">T√πy ch·ªçn & Sao ch√©p</h5>
                    <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                        <span aria-hidden="true">&times;</span>
                    </button>
                </div>
                <div class="modal-body">
                    <div class="container-fluid">
                        <div class="row">
                            <div class="col-md-6">
                                <h5>Sao ch√©p D·ªØ li·ªáu</h5>
                                <button id="copyLineGeometryBtn" class="btn btn-outline-primary btn-block mb-2">Copy
                                    Line Geometry</button>
                                <button id="copyStdGeometryBtn" class="btn btn-outline-primary btn-block mb-2">Copy Std
                                    Geometry</button>
                                <button id="copyLineMeshBtn" class="btn btn-outline-success btn-block mb-2">Copy Line
                                    Mesh</button>
                                <button id="copyStdMeshBtn" class="btn btn-outline-success btn-block mb-2">Copy Std
                                    Mesh</button>
                            </div>
                            <div class="col-md-6">
                                <h5>C√†i ƒë·∫∑t M·∫∑c ƒë·ªãnh cho Shape</h5>
                                <div class="form-group">
                                    <label for="defaultStdMaterialInput">Default Std Material:</label>
                                    <input type="text" id="defaultStdMaterialInput" class="form-control form-control-sm"
                                        placeholder="V√≠ d·ª•: R110-0">
                                </div>
                                <div class="form-group">
                                    <label>Default Deform Types:</label>
                                    <div class="form-check">
                                        <input class="form-check-input" type="checkbox"
                                            id="defaultDeformStretch2Checkbox"> <!-- B·ªè checked m·∫∑c ƒë·ªãnh -->
                                        <label class="form-check-label"
                                            for="defaultDeformStretch2Checkbox">Stretch2</label>
                                    </div>
                                    <div class="form-check">
                                        <input class="form-check-input" type="checkbox"
                                            id="defaultDeformClippingCheckbox">
                                        <label class="form-check-label"
                                            for="defaultDeformClippingCheckbox">Clipping</label>
                                    </div>
                                </div>
                                <button id="applyDefaultsBtn" class="btn btn-warning btn-block mt-3">√Åp d·ª•ng cho t·∫•t c·∫£
                                    Shapes hi·ªán t·∫°i</button>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-dismiss="modal">ƒê√≥ng</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.9.2/dist/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/lines/LineSegmentsGeometry.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/lines/LineMaterial.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/lines/LineSegments2.js"></script>
    <script>
        // Bi·∫øn to√†n c·ª•c cho modal canvas view
        let currentModalViewMode = 'oxy'; // M·∫∑c ƒë·ªãnh l√† Oxy
        const PIXELS_PER_UNIT_DEFAULT = 20; // For default zoom when no points or single point
        let PIXELS_PER_UNIT = PIXELS_PER_UNIT_DEFAULT; // Will be dynamically calculated
        let modalOriginX = 0; // Dynamically calculated origin X for modal canvas
        let modalOriginY = 0; // Dynamically calculated origin Y for modal canvas
        const MODAL_CANVAS_PADDING = 40; // Pixels of padding around the content when auto-fitting
        const GRID_COLOR = '#cccccc';

        // Bi·∫øn to√†n c·ª•c cho ch·∫ø ƒë·ªô t∆∞∆°ng t√°c trong modal canvas
        let currentModalInteractionMode = 'none'; // 'none', 'addPoint', 'moveObject', etc.
        let temporaryNewPoints = []; // M·∫£ng l∆∞u c√°c ƒëi·ªÉm m·ªõi ƒë∆∞·ª£c click tr√™n canvas modal
        let selectedTemporaryPointIndex = -1; // Index c·ªßa ƒëi·ªÉm t·∫°m th·ªùi ƒëang ƒë∆∞·ª£c ch·ªânh s·ª≠a t·ªça ƒë·ªô

        // Bi·∫øn cho tr·∫°ng th√°i pan chu·ªôt ph·∫£i
        let isPanningWithRightMouse = false;
        let lastPanX = 0;
        let lastPanY = 0;

        const AXIS_COLOR = '#333333';
        const TEXT_COLOR = '#000000';
        // State c·ªßa ·ª©ng d·ª•ng
        let shapesData = [];
        let selectedShapeId = null;
        let currentJsonString = ''; // L∆∞u tr·ªØ chu·ªói JSON hi·ªán t·∫°i (ch·ªß y·∫øu cho Line Geometry v√† 3D view)
        let currentObjectName = 'OBJECT-NAME'; // L∆∞u tr·ªØ Object Name, kh·ªüi t·∫°o v·ªõi gi√° tr·ªã m·∫∑c ƒë·ªãnh

        // DOM Elements
        const addShapeBtn = document.getElementById('addShapeBtn');
        const shapesListContainer = document.getElementById('shapesListContainer');
        const importJsonBtn = document.getElementById('importJsonBtn');
        const copyLineGeometryBtn = document.getElementById('copyLineGeometryBtn');
        const copyStdGeometryBtn = document.getElementById('copyStdGeometryBtn');
        const copyLineMeshBtn = document.getElementById('copyLineMeshBtn');
        const copyStdMeshBtn = document.getElementById('copyStdMeshBtn');
        const objectNameInput = document.getElementById('objectNameInput');
        const uploadJsonBtn = document.getElementById('uploadJsonBtn');
        const uploadJsonFile = document.getElementById('uploadJsonFile');

        const shapeEditorContainer = document.getElementById('shapeEditorContainer');
        const noShapeSelectedMsg = document.getElementById('noShapeSelectedMsg');
        const generatedShapeNameLine = document.getElementById('generatedShapeNameLine');
        const generatedShapeNameStd = document.getElementById('generatedShapeNameStd');
        const stdMaterialInput = document.getElementById('stdMaterialInput');

        const addVertexBtn = document.getElementById('addVertexBtn');
        const verticesListContainer = document.getElementById('verticesList');

        const addFaceBtn = document.getElementById('addFaceBtn');
        const faceVerticesInput = document.getElementById('faceVertices');
        const facesListContainer = document.getElementById('facesListContainer');

        const addLineBtn = document.getElementById('addLineBtn');
        const lineVerticesInput = document.getElementById('lineVerticesInput');
        const linesListContainer = document.getElementById('linesListContainer');

        // Transformation UI Elements
        const translateXInput = document.getElementById('translateX');
        const translateYInput = document.getElementById('translateY');
        const translateZInput = document.getElementById('translateZ');
        const applyTranslateBtn = document.getElementById('applyTranslateBtn');
        const rotateXInput = document.getElementById('rotateX');
        const rotateYInput = document.getElementById('rotateY');
        const rotateZInput = document.getElementById('rotateZ');
        const applyRotateBtn = document.getElementById('applyRotateBtn');
        const flipXBtn = document.getElementById('flipXBtn');
        const flipYBtn = document.getElementById('flipYBtn');
        const flipZBtn = document.getElementById('flipZBtn');

        const currentDeformTypesText = document.getElementById('currentDeformTypesText');

        const threeJsCanvasContainer = document.getElementById('threejs-canvas-container');

        // Three.js specific variables
        let scene, camera, renderer, controls, shapesGroup;
        let vertexLabelsGroup; // Group cho c√°c nh√£n ID ƒë·ªânh
        let threeShapeObjects = {}; // Map t·ª´ shape._internalId sang { group, lineMaterial, faceMaterial, labelMaterial }

        // Materials for highlighting
        const NORMAL_LINE_COLOR = 0x0000ff;
        const HIGHLIGHTED_LINE_COLOR = 0x007bff; // Changed to Blue
        const NORMAL_FACE_COLOR = 0xcccccc;
        const HIGHLIGHTED_FACE_COLOR = 0xffd700; // Gold
        const NORMAL_LABEL_BG_COLOR = { r: 50, g: 50, b: 50, a: 0.7 };
        const HIGHLIGHTED_LABEL_BG_COLOR = { r: 255, g: 165, b: 0, a: 0.9 }; // Orange background for labels

        // Variables for modal canvas crosshair and coordinates display
        let modalCanvasMouseX = null;
        let modalCanvasMouseY = null;
        let showCrosshairAndCoords = true; // Toggle for the new feature

        // Th√™m l·∫°i c√°c khai b√°o bi·∫øn b·ªã thi·∫øu
        const deformStretch2Checkbox = document.getElementById('deformStretch2Checkbox');
        const deformClippingCheckbox = document.getElementById('deformClippingCheckbox'); // ID n√†y ƒë√£ ƒë∆∞·ª£c ƒë·ªïi t·ª´ deformClipCheckbox
        const pivotXInput = document.getElementById('pivotX');
        const pivotYInput = document.getElementById('pivotY');
        const pivotZInput = document.getElementById('pivotZ');

        const defaultStdMaterialInput = document.getElementById('defaultStdMaterialInput');
        const defaultDeformStretch2Checkbox = document.getElementById('defaultDeformStretch2Checkbox');
        const defaultDeformClippingCheckbox = document.getElementById('defaultDeformClippingCheckbox');
        const applyDefaultsBtn = document.getElementById('applyDefaultsBtn');

        // Raycaster for picking objects
        let raycaster;
        let mouse;

        // --- Helper function to create text sprites (moved to a more global scope) ---
        function createTextSprite(message, parameters) {
            parameters = parameters || {};
            const fontface = parameters.fontface || 'Arial';
            const internalFontsize = parameters.internalFontsize || 32; // Fontsize v·∫Ω l√™n canvas
            const borderThickness = parameters.borderThickness || 2;
            const borderColor = parameters.borderColor || { r: 0, g: 0, b: 0, a: 1.0 };
            const backgroundColor = parameters.backgroundColor || { r: 255, g: 255, b: 255, a: 0.8 };
            const textColor = parameters.textColor || { r: 0, g: 0, b: 0, a: 1.0 };

            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');

            context.font = 'Bold ' + internalFontsize + 'px ' + fontface;
            const metrics = context.measureText(message);
            const textWidth = metrics.width;

            canvas.width = textWidth + borderThickness * 2 + 20; // Th√™m padding cho canvas
            canvas.height = internalFontsize * 1.4 + borderThickness * 2;

            context.font = 'Bold ' + internalFontsize + 'px ' + fontface;
            context.fillStyle = `rgba(${backgroundColor.r},${backgroundColor.g},${backgroundColor.b},${backgroundColor.a})`;
            context.strokeStyle = `rgba(${borderColor.r},${borderColor.g},${borderColor.b},${borderColor.a})`;
            context.lineWidth = borderThickness;

            context.fillStyle = `rgba(${textColor.r},${textColor.g},${textColor.b},${textColor.a})`;
            context.fillText(message, borderThickness + 5, internalFontsize + borderThickness);

            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter; // Th√™m magFilter cho nh·∫•t qu√°n
            texture.wrapS = THREE.ClampToEdgeWrapping;
            texture.wrapT = THREE.ClampToEdgeWrapping;

            const spriteMaterial = new THREE.SpriteMaterial({
                map: texture,
                sizeAttenuation: false, // THAY ƒê·ªîI ·ªû ƒê√ÇY: k√≠ch th∆∞·ªõc kh√¥ng ƒë·ªïi khi zoom
                transparent: true, // Cho ph√©p background trong su·ªët n·∫øu alpha < 1
                alphaTest: 0.1 // ƒê·ªÉ c√°c pixel g·∫ßn nh∆∞ trong su·ªët ho√†n to√†n kh√¥ng ƒë∆∞·ª£c v·∫Ω
            });
            const sprite = new THREE.Sprite(spriteMaterial);

            // ƒêi·ªÅu ch·ªânh scale ƒë·ªÉ sprite c√≥ chi·ªÅu cao mong mu·ªën 
            // Khi sizeAttenuation = false, scale n√†y s·∫Ω tr·ª±c ti·∫øp ·∫£nh h∆∞·ªüng ƒë·∫øn k√≠ch th∆∞·ªõc hi·ªÉn th·ªã tr√™n m√†n h√¨nh.
            // B·∫°n c√≥ th·ªÉ c·∫ßn ƒëi·ªÅu ch·ªânh gi√° tr·ªã n√†y ƒë·ªÉ ƒë·∫°t ƒë∆∞·ª£c k√≠ch th∆∞·ªõc mong mu·ªën.
            const desiredScreenHeightFactor = parameters.worldHeight || 50; // C√≥ th·ªÉ c·∫ßn ƒë·ªïi t√™n v√† gi√° tr·ªã
            // T·∫°m th·ªüi gi·ªØ nguy√™n logic scale c≈©, nh∆∞ng c√≥ th·ªÉ c·∫ßn ƒëi·ªÅu ch·ªânh l·∫°i 'desiredScreenHeightFactor'
            // ho·∫∑c c√°ch t√≠nh to√°n scale cho ph√π h·ª£p v·ªõi sizeAttenuation = false.
            // V√≠ d·ª•, b·∫°n c√≥ th·ªÉ mu·ªën ƒë·∫∑t m·ªôt scale c·ªë ƒë·ªãnh:
            // sprite.scale.set(50, 25, 1); // V√≠ d·ª•: r·ªông 50 units, cao 25 units tr√™n m√†n h√¨nh (c·∫ßn th·ª≠ nghi·ªám)
            sprite.scale.set((desiredScreenHeightFactor * canvas.width / canvas.height), desiredScreenHeightFactor, 1.0);

            return sprite;
        }

        // --- UUID Generation ---
        function generateUUID() {
            // Basic UUID v4 generator
            return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>
                (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
            );
        }

        // --- 3D Viewer Initialization ---
        function init3DViewer() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xeeeeee);

            // Camera
            const aspect = threeJsCanvasContainer.clientWidth / threeJsCanvasContainer.clientHeight;
            camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 10000);
            camera.position.set(100, 100, 500); // ƒêi·ªÅu ch·ªânh v·ªã tr√≠ camera cho ph√π h·ª£p v·ªõi d·ªØ li·ªáu c·ªßa b·∫°n
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(threeJsCanvasContainer.clientWidth, threeJsCanvasContainer.clientHeight);
            threeJsCanvasContainer.appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(200, 500, 300);
            scene.add(directionalLight);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 10;
            controls.maxDistance = 5000;
            controls.addEventListener('change', render3DScene); // render khi c√≥ t∆∞∆°ng t√°c

            // Shapes Group - to hold all dynamic shapes for easy clearing
            shapesGroup = new THREE.Group();
            scene.add(shapesGroup);

            vertexLabelsGroup = new THREE.Group(); // Kh·ªüi t·∫°o group cho nh√£n
            scene.add(vertexLabelsGroup);

            // Axes Helper
            const mainAxesHelper = new THREE.AxesHelper(10000); // TƒÉng chi·ªÅu d√†i tr·ª•c ch√≠nh
            scene.add(mainAxesHelper);

            // Grid/Ticks for Axes
            const ticksGroup = new THREE.Group();
            const tickLength = 20; // ƒê·ªô d√†i c·ªßa m·ªói v·∫°ch tick
            const tickStep = 100;  // Kho·∫£ng c√°ch gi·ªØa c√°c v·∫°ch tick
            const axisLength = 10000; // Ph·∫£i kh·ªõp v·ªõi AxesHelper ·ªü tr√™n
            const tickMaterialX = new THREE.LineBasicMaterial({ color: 0xff0000 }); // Red for X ticks
            const tickMaterialY = new THREE.LineBasicMaterial({ color: 0x00ff00 }); // Green for Y ticks
            const tickMaterialZ = new THREE.LineBasicMaterial({ color: 0x0000ff }); // Blue for Z ticks

            function createTicksForAxis(targetAxis, length, step, tickSize, material) {
                const points = [];
                for (let i = -length; i <= length; i += step) {
                    if (i === 0) continue; // B·ªè qua g·ªëc t·ªça ƒë·ªô

                    if (targetAxis === 'x') {
                        points.push(new THREE.Vector3(i, -tickSize / 2, 0));
                        points.push(new THREE.Vector3(i, tickSize / 2, 0));
                        points.push(new THREE.Vector3(i, 0, -tickSize / 2));
                        points.push(new THREE.Vector3(i, 0, tickSize / 2));
                    } else if (targetAxis === 'y') {
                        points.push(new THREE.Vector3(-tickSize / 2, i, 0));
                        points.push(new THREE.Vector3(tickSize / 2, i, 0));
                        points.push(new THREE.Vector3(0, i, -tickSize / 2));
                        points.push(new THREE.Vector3(0, i, tickSize / 2));
                    } else if (targetAxis === 'z') {
                        points.push(new THREE.Vector3(-tickSize / 2, 0, i));
                        points.push(new THREE.Vector3(tickSize / 2, 0, i));
                        points.push(new THREE.Vector3(0, -tickSize / 2, i));
                        points.push(new THREE.Vector3(0, tickSize / 2, i));
                    }
                }
                if (points.length > 0) {
                    const tickGeometry = new THREE.BufferGeometry().setFromPoints(points);
                    const ticks = new THREE.LineSegments(tickGeometry, material);
                    ticksGroup.add(ticks);
                }
            }

            createTicksForAxis('x', axisLength, tickStep, tickLength, tickMaterialX);
            createTicksForAxis('y', axisLength, tickStep, tickLength, tickMaterialY);
            createTicksForAxis('z', axisLength, tickStep, tickLength, tickMaterialZ);
            scene.add(ticksGroup);

            // Initialize Raycaster
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            renderer.domElement.addEventListener('pointerdown', onDocumentMouseDown, false);

            // Animation loop for controls damping
            function animate() {
                requestAnimationFrame(animate);
                controls.update(); // only required if controls.enableDamping or controls.autoRotate are set to true
                render3DScene();
            }
            animate();

            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);
            onWindowResize(); // Initial call to set size
        }

        function onWindowResize() {
            if (!renderer || !camera || !threeJsCanvasContainer) return;
            const newWidth = threeJsCanvasContainer.clientWidth;
            const newHeight = threeJsCanvasContainer.clientHeight;

            camera.aspect = newWidth / newHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(newWidth, newHeight);
            update3DView();
        }

        function render3DScene() {
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }

        // --- Update 3D View ---
        function update3DView() {
            if (!scene || !shapesGroup) return;

            // Clear previous shapes and labels first
            while (shapesGroup.children.length > 0) {
                shapesGroup.remove(shapesGroup.children[0]);
            }
            shapesGroup.clear(); // ƒê·∫£m b·∫£o group r·ªóng
            threeShapeObjects = {}; // Reset map object

            while (vertexLabelsGroup && vertexLabelsGroup.children.length > 0) {
                vertexLabelsGroup.remove(vertexLabelsGroup.children[0]);
            }
            if (vertexLabelsGroup) vertexLabelsGroup.clear();


            shapesData.forEach(shape => {
                const isSelected = shape._internalId === selectedShapeId;

                const shapeSpecificGroup = new THREE.Group(); // Group ri√™ng cho m·ªói shape
                shapeSpecificGroup.userData.shapeId = shape._internalId; // Store shapeId for picking
                shapesGroup.add(shapeSpecificGroup); // Th√™m group c·ªßa shape v√†o group ch√≠nh

                const currentLineMaterial = new THREE.LineBasicMaterial({
                    color: isSelected ? HIGHLIGHTED_LINE_COLOR : NORMAL_LINE_COLOR,
                    depthTest: false, // ƒê·ªÉ line kh√¥ng b·ªã ·∫©n b·ªüi face n·∫øu tr√πng
                });
                const currentFaceMaterial = new THREE.MeshStandardMaterial({
                    color: isSelected ? HIGHLIGHTED_FACE_COLOR : NORMAL_FACE_COLOR,
                    side: THREE.FrontSide,
                    metalness: 0.1,
                    roughness: 0.75,
                    depthTest: true
                });
                const currentLabelBackgroundColor = isSelected ? HIGHLIGHTED_LABEL_BG_COLOR : NORMAL_LABEL_BG_COLOR;
                const currentLabelTextColor = isSelected ? { r: 0, g: 0, b: 0, a: 1 } : { r: 255, g: 255, b: 255, a: 1 };


                // L∆∞u tr·ªØ c√°c ƒë·ªëi t∆∞·ª£ng three.js c·ªßa shape n√†y ƒë·ªÉ c√≥ th·ªÉ highlight sau
                threeShapeObjects[shape._internalId] = {
                    group: shapeSpecificGroup, // Group ch·ª©a t·∫•t c·∫£ elements c·ªßa shape n√†y
                    lines: null, // S·∫Ω ƒë∆∞·ª£c g√°n khi t·∫°o LineSegments
                    mesh: null,  // S·∫Ω ƒë∆∞·ª£c g√°n khi t·∫°o Mesh
                    labels: [] // M·∫£ng c√°c sprite nh√£n
                };

                if (!shape.v || Object.keys(shape.v).length === 0) return;

                const vertexMap = {};
                const points = [];
                Object.keys(shape.v).sort((a, b) => parseInt(a) - parseInt(b)).forEach((key, index) => {
                    const coords = shape.v[key];
                    const pivot = shape.pivot || [0, 0, 0]; // L·∫•y pivot, m·∫∑c ƒë·ªãnh [0,0,0]
                    const vertexPosition = new THREE.Vector3(
                        coords[0] + pivot[0],
                        coords[1] + pivot[1],
                        coords[2] + pivot[2]
                    );
                    points.push(vertexPosition);
                    vertexMap[key] = index;

                    const currentWorldHeight = 0.1; // ƒê·∫∑t l·∫°i k√≠ch th∆∞·ªõc nh√£n mong mu·ªën tr√™n m√†n h√¨nh
                    const labelSprite = createTextSprite(key.toString(), {
                        internalFontsize: 32,    // Gi·ªØ nguy√™n font size cho texture s·∫Øc n√©t
                        worldHeight: currentWorldHeight,
                        backgroundColor: currentLabelBackgroundColor,
                        textColor: currentLabelTextColor,
                        fontface: 'monospace'
                    });
                    labelSprite.position.copy(vertexPosition);
                    labelSprite.position.y += (currentWorldHeight * 0.5) + 2;
                    if (isSelected) { // Ch·ªâ th√™m label v√†o group c·ªßa shape n·∫øu shape ƒë∆∞·ª£c ch·ªçn
                        shapeSpecificGroup.add(labelSprite);
                    }
                    threeShapeObjects[shape._internalId].labels.push(labelSprite); // V·∫´n l∆∞u tr·ªØ tham chi·∫øu ƒë·∫øn label
                });

                if (points.length === 0) return;

                if (shape.lines && shape.lines.length > 0) {
                    const linePointsForBuffer = []; // For existing LineBasicMaterial if not selected
                    const flatLineVertices = [];   // For LineMaterial if selected

                    shape.lines.forEach(line => {
                        if (vertexMap[line.v1.toString()] !== undefined && vertexMap[line.v2.toString()] !== undefined) {
                            const p1 = points[vertexMap[line.v1.toString()]];
                            const p2 = points[vertexMap[line.v2.toString()]];

                            flatLineVertices.push(p1.x, p1.y, p1.z);
                            flatLineVertices.push(p2.x, p2.y, p2.z);
                        }
                    });

                    if (flatLineVertices.length > 0) {
                        if (isSelected) { // Ch·ªâ v·∫Ω lines n·∫øu shape ƒë∆∞·ª£c ch·ªçn
                            const lineGeo = new THREE.LineSegmentsGeometry();
                            lineGeo.setPositions(flatLineVertices);

                            const lineMat = new THREE.LineMaterial({
                                color: HIGHLIGHTED_LINE_COLOR,
                                linewidth: 3, // ƒê·ªô d√†y c·ªßa line (v√≠ d·ª•: 3 pixels)
                                resolution: new THREE.Vector2(threeJsCanvasContainer.clientWidth, threeJsCanvasContainer.clientHeight),
                                depthTest: true, // ƒê·ªïi th√†nh true ƒë·ªÉ ƒë∆∞·ªùng b·ªã khu·∫•t kh√¥ng hi·ªÉn th·ªã
                                dashed: false
                            });

                            const lineSegmentsFat = new THREE.LineSegments2(lineGeo, lineMat);
                            shapeSpecificGroup.add(lineSegmentsFat);
                            threeShapeObjects[shape._internalId].lines = lineSegmentsFat;
                        }
                    }
                }

                if (shape.faces && Object.keys(shape.faces).length > 0) {
                    const faceIndices = [];
                    Object.values(shape.faces).forEach(face => {
                        const vIndices = face.vertices;
                        const mappedVIndices = vIndices.map(vi => vertexMap[vi.toString()]).filter(vi => vi !== undefined);

                        if (mappedVIndices.length >= 3) {
                            for (let i = 1; i < mappedVIndices.length - 1; i++) {
                                faceIndices.push(mappedVIndices[0], mappedVIndices[i], mappedVIndices[i + 1]);
                            }
                        }
                    });

                    if (faceIndices.length > 0) {
                        const faceGeometry = new THREE.BufferGeometry().setFromPoints(points);
                        faceGeometry.setIndex(faceIndices);
                        faceGeometry.computeVertexNormals();
                        const mesh = new THREE.Mesh(faceGeometry, currentFaceMaterial);
                        shapeSpecificGroup.add(mesh); // Th√™m mesh v√†o group c·ªßa shape
                        threeShapeObjects[shape._internalId].mesh = mesh;
                    }
                }
            });
            render3DScene();
        }

        // --- Render Functions ---
        function renderShapesList() {
            shapesListContainer.innerHTML = '';
            if (shapesData.length === 0) {
                shapesListContainer.innerHTML = '<p>Ch∆∞a c√≥ shape n√†o.</p>';
            } else {
                shapesData.forEach((shape, index) => {
                    const shapeItem = document.createElement('div');
                    shapeItem.classList.add('shape-item');
                    if (shape._internalId === selectedShapeId) {
                        shapeItem.classList.add('selected');
                    }
                    // Hi·ªÉn th·ªã t√™n theo mode "Line" trong danh s√°ch cho nh·∫•t qu√°n, ho·∫∑c c√≥ th·ªÉ ch·ªçn m·ªôt mode c·ªë ƒë·ªãnh
                    const displayIdentifiers = generateShapeIdentifiers(index, "Line");
                    shapeItem.textContent = `Shape: ${displayIdentifiers.name}`;
                    shapeItem.dataset.shapeId = shape._internalId; // V·∫´n d√πng _internalId ƒë·ªÉ ch·ªçn

                    const deleteBtn = document.createElement('button');
                    deleteBtn.innerHTML = 'üóëÔ∏è';
                    deleteBtn.title = 'X√≥a Shape';
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        deleteShape(shape._internalId);
                    };

                    const copyShapeBtn = document.createElement('button');
                    copyShapeBtn.innerHTML = 'üìã';
                    copyShapeBtn.title = 'Sao ch√©p Shape';
                    copyShapeBtn.style.backgroundColor = '#28a745';
                    copyShapeBtn.style.marginLeft = '5px';
                    copyShapeBtn.onclick = (e) => {
                        e.stopPropagation();
                        copyShape(shape._internalId);
                    };

                    shapeItem.appendChild(copyShapeBtn);
                    shapeItem.appendChild(deleteBtn);

                    shapeItem.onclick = () => {
                        selectShape(shape._internalId);
                    };
                    shapesListContainer.appendChild(shapeItem);
                });
            }
            // Kh√¥ng c·∫ßn g·ªçi update3DView ·ªü ƒë√¢y n·ªØa v√¨ selectShape s·∫Ω l√†m ƒëi·ªÅu ƒë√≥ th√¥ng qua renderJsonOutput
        }

        function renderJsonOutput() {
            // H√†m n√†y gi·ªù ch·ªâ t·∫°o JSON cho Line Geometry v√† c·∫≠p nh·∫≠t 3D view
            currentJsonString = generateJsonString(true); // true ƒë·ªÉ bao g·ªìm lines
            update3DView(); // Update 3D view whenever JSON output changes
        }

        function generateJsonString(includeLines) {
            const shapesForJson = shapesData.map((s, index) => {
                const { _internalId, pivot, stdMaterial, deformTypes, ...shapeRest } = s; // L·∫•y th√™m stdMaterial, deformTypes
                const currentPivot = pivot && Array.isArray(pivot) && pivot.length === 3 ? pivot : [0, 0, 0];

                const mode = includeLines ? "Line" : "Std";
                const identifiers = generateShapeIdentifiers(index, mode);

                const worldVertices = {};
                if (shapeRest.v) {
                    Object.keys(shapeRest.v).forEach(vKey => {
                        const localCoord = shapeRest.v[vKey];
                        worldVertices[vKey] = [
                            parseFloat((localCoord[0] + currentPivot[0]).toFixed(1)),
                            parseFloat((localCoord[1] + currentPivot[1]).toFixed(1)),
                            parseFloat((localCoord[2] + currentPivot[2]).toFixed(1))
                        ];
                    });
                }

                const outputShape = {
                    ...shapeRest,
                    name: identifiers.name, // S·ª≠ d·ª•ng t√™n ƒë∆∞·ª£c t·∫°o ƒë·ªông
                    uuid: identifiers.uuid, // S·ª≠ d·ª•ng UUID ƒë∆∞·ª£c t·∫°o ƒë·ªông
                    v: worldVertices,
                    lines: includeLines ? (shapeRest.lines || []) : []
                };
                // Kh√¥ng th√™m stdMaterial v√† deformTypes v√†o ƒë√¢y v√¨ ƒë√¢y l√† JSON cho Geometry
                return outputShape;
            });

            const output = {
                shapes: shapesForJson
            };
            return JSON.stringify(output); // B·ªè null, 2 ƒë·ªÉ minimize
        }

        function renderSelectedShapeEditor() {
            if (!selectedShapeId) {
                shapeEditorContainer.classList.add('hidden');
                noShapeSelectedMsg.classList.remove('hidden');
                if (currentDeformTypesText) currentDeformTypesText.textContent = 'None';
                return;
            }

            shapeEditorContainer.classList.remove('hidden');
            noShapeSelectedMsg.classList.add('hidden');

            const shape = shapesData.find(s => s._internalId === selectedShapeId);
            if (!shape) return; // Should not happen

            const shapeIndex = shapesData.findIndex(s => s._internalId === selectedShapeId);
            if (shapeIndex === -1) return; // Should not happen

            const lineIdentifiers = generateShapeIdentifiers(shapeIndex, "Line");
            const stdIdentifiers = generateShapeIdentifiers(shapeIndex, "Std");

            generatedShapeNameLine.textContent = lineIdentifiers.name;
            generatedShapeNameStd.textContent = stdIdentifiers.name;
            // UUID hi·ªÉn th·ªã c√≥ th·ªÉ l·∫•y theo Line mode ho·∫∑c l√†m r√µ h∆°n
            // generatedShapeUuid.textContent = `${lineIdentifiers.uuid} (Line Mode) / ${stdIdentifiers.uuid} (Std Mode)`; // ƒê√É X√ìA

            stdMaterialInput.value = shape.stdMaterial || '';

            // X·ª≠ l√Ω Deform Types Checkboxes
            shape.deformTypes = shape.deformTypes || [];
            deformStretch2Checkbox.checked = shape.deformTypes.includes('Stretch2');
            deformClippingCheckbox.checked = shape.deformTypes.includes('Clipping');
            updateCurrentDeformTypesText(shape.deformTypes); // C·∫≠p nh·∫≠t text hi·ªÉn th·ªã

            // Hi·ªÉn th·ªã v√† x·ª≠ l√Ω pivot
            shape.pivot = shape.pivot || [0, 0, 0]; // ƒê·∫£m b·∫£o pivot t·ªìn t·∫°i
            pivotXInput.value = shape.pivot[0];
            pivotYInput.value = shape.pivot[1];
            pivotZInput.value = shape.pivot[2];

            renderVerticesList(shape);
            renderFacesList(shape);
            renderLinesList(shape);
            renderJsonOutput();
        }

        function renderVerticesList(shape) {
            verticesListContainer.innerHTML = '';
            if (!shape || !shape.v) return;

            Object.entries(shape.v).forEach(([key, coords], index) => {
                const vEntry = document.createElement('div');
                vEntry.classList.add('vertex-entry');

                const idLabel = document.createElement('span');
                idLabel.textContent = `ID(${key}):`;

                // G·ªôp th√†nh 1 input
                const coordsInput = document.createElement('input');
                coordsInput.type = 'text';
                coordsInput.value = coords.join(','); // Hi·ªÉn th·ªã d·∫°ng X,Y,Z
                coordsInput.dataset.vertexKey = key;
                coordsInput.style.flexGrow = 1; // Cho input chi·∫øm nhi·ªÅu kh√¥ng gian h∆°n
                coordsInput.onchange = handleVertexCoordsChange; // H√†m x·ª≠ l√Ω m·ªõi

                const copyBtn = document.createElement('button');
                copyBtn.innerHTML = 'üìã';
                copyBtn.title = 'Sao ch√©p Vertex';
                copyBtn.style.backgroundColor = '#17a2b8';
                copyBtn.onclick = () => copyVertex(key);

                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'üóëÔ∏è';
                deleteBtn.title = 'X√≥a Vertex';
                deleteBtn.style.backgroundColor = '#ffc107';
                deleteBtn.onclick = () => deleteVertex(key);

                vEntry.append(idLabel, coordsInput, copyBtn, deleteBtn);
                verticesListContainer.appendChild(vEntry);
            });
        }

        function renderFacesList(shape) {
            facesListContainer.innerHTML = '';
            if (!shape || !shape.faces) return;

            Object.entries(shape.faces).forEach(([key, faceData]) => {
                const fEntry = document.createElement('div');
                fEntry.classList.add('face-entry');
                fEntry.textContent = `Face ID(${key}): ${faceData.vertices.join(', ')}`;

                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'üóëÔ∏è';
                deleteBtn.title = 'X√≥a Face';
                deleteBtn.style.backgroundColor = '#ffc107';
                deleteBtn.onclick = () => deleteFace(key);

                fEntry.appendChild(deleteBtn);
                facesListContainer.appendChild(fEntry);
            });
        }

        function renderLinesList(shape) {
            linesListContainer.innerHTML = '';
            if (!shape || !shape.lines) return;

            shape.lines.forEach((line, index) => {
                const lEntry = document.createElement('div');
                lEntry.classList.add('line-entry');
                lEntry.textContent = `Line: v${line.v1} - v${line.v2}`;

                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'üóëÔ∏è';
                deleteBtn.title = 'X√≥a Line';
                deleteBtn.style.backgroundColor = '#ffc107';
                deleteBtn.onclick = () => deleteLine(index);

                lEntry.appendChild(deleteBtn);
                linesListContainer.appendChild(lEntry);
            });
        }


        // --- Event Handlers & Logic ---
        addShapeBtn.onclick = () => {
            const newShapeInternalId = Date.now() + Math.random(); // ID n·ªôi b·ªô duy nh·∫•t, kh√¥ng d√πng cho name/uuid n·ªØa
            const defaultStdMaterial = defaultStdMaterialInput.value.trim();
            const defaultDeformTypes = []; // Kh·ªüi t·∫°o m·∫£ng r·ªóng
            if (defaultDeformStretch2Checkbox.checked) defaultDeformTypes.push('Stretch2');
            if (defaultDeformClippingCheckbox.checked) defaultDeformTypes.push('Clipping');

            const newShape = {
                _internalId: newShapeInternalId,
                // name v√† uuid s·∫Ω ƒë∆∞·ª£c t·∫°o ƒë·ªông, kh√¥ng c·∫ßn l∆∞u tr·ªØ c·ªë ƒë·ªãnh trong shape object n·ªØa
                faces: {},
                lines: [],
                v: {},
                pivot: [0, 0, 0],
                deformTypes: defaultDeformTypes, // S·ª≠ d·ª•ng gi√° tr·ªã default
                stdMaterial: defaultStdMaterial  // S·ª≠ d·ª•ng gi√° tr·ªã default
            };
            shapesData.push(newShape);
            // Kh√¥ng c·∫ßn g√°n selectedShapeId ngay, v√¨ selectShape s·∫Ω l√†m ƒëi·ªÅu ƒë√≥ th√¥ng qua renderShapesList
            renderShapesList(); // C·∫≠p nh·∫≠t danh s√°ch tr∆∞·ªõc
            selectShape(newShapeInternalId); // T·ª± ƒë·ªông ch·ªçn shape m·ªõi
        };

        function selectShape(shapeIdToSelect) {
            selectedShapeId = shapeIdToSelect;
            renderShapesList();
            renderSelectedShapeEditor();
            renderJsonOutput(); // ƒêi·ªÅu n√†y s·∫Ω g·ªçi update3DView v√† √°p d·ª•ng highlight

            const editBtn = document.getElementById('openShapeCanvasModalBtn');
            if (editBtn) {
                editBtn.style.display = selectedShapeId ? 'inline-block' : 'none';
            }
            // N·∫øu kh√¥ng c√≥ shape n√†o ƒë∆∞·ª£c ch·ªçn, ƒë·∫£m b·∫£o modal c≈©ng ƒë√≥ng (n·∫øu ƒëang m·ªü)
            if (!selectedShapeId) {
                const shapeCanvasModal = document.getElementById('shapeCanvasModal');
                if (shapeCanvasModal && shapeCanvasModal.style.display === 'flex') {
                    shapeCanvasModal.style.display = 'none';
                }
            }
        }

        function deleteShape(shapeIdToDelete) {
            shapesData = shapesData.filter(s => s._internalId !== shapeIdToDelete);
            if (selectedShapeId === shapeIdToDelete) {
                selectedShapeId = null;
                if (currentDeformTypesText) currentDeformTypesText.textContent = 'None';
                // X√≥a lu√¥n text t√™n/uuid ƒëang hi·ªÉn th·ªã trong editor
                generatedShapeNameLine.textContent = '';
                generatedShapeNameStd.textContent = '';
                // generatedShapeUuid.textContent = ''; // ƒê√É X√ìA
            }
            renderShapesList();
            renderSelectedShapeEditor(); // C·∫≠p nh·∫≠t editor (c√≥ th·ªÉ ·∫©n ƒëi)
            renderJsonOutput();
        }

        function generateShapeIdentifiers(shapeIndex, mode) {
            const baseName = currentObjectName || "DEFAULT_OBJECT";
            const suffix = mode === "Line" ? "L" : "G";
            const name = `${baseName}-${suffix}_${shapeIndex + 1}`;
            return { name: name, uuid: name }; // UUID gi·ªëng h·ªát name
        }

        objectNameInput.onchange = (e) => {
            currentObjectName = e.target.value.trim();
            renderShapesList();
            renderSelectedShapeEditor(); // C·∫≠p nh·∫≠t t√™n hi·ªÉn th·ªã n·∫øu c√≥ shape ƒëang ch·ªçn
            renderJsonOutput(); // C·∫≠p nh·∫≠t JSON v√† 3D view
        };

        addVertexBtn.onclick = () => {
            if (!selectedShapeId) return;
            const shape = shapesData.find(s => s._internalId === selectedShapeId);
            if (!shape) return;

            const existingKeys = Object.keys(shape.v).map(k => parseInt(k)).filter(k => !isNaN(k));
            const newKey = existingKeys.length > 0 ? Math.max(...existingKeys) + 1 : 0;

            shape.v[newKey.toString()] = [0, 0, 0]; // Default coords
            renderVerticesList(shape);
            renderJsonOutput();
        };

        function handleVertexCoordsChange(event) {
            if (!selectedShapeId) return;
            const shape = shapesData.find(s => s._internalId === selectedShapeId);
            if (!shape) return;

            const vertexKey = event.target.dataset.vertexKey;
            const newCoordsStr = event.target.value.trim();
            const coordsArray = newCoordsStr.split(',').map(c => parseFloat(c.trim()));

            if (coordsArray.length === 3 && coordsArray.every(c => !isNaN(c))) {
                shape.v[vertexKey] = coordsArray;
                renderJsonOutput();
            } else {
                alert("ƒê·ªãnh d·∫°ng t·ªça ƒë·ªô kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p d∆∞·ªõi d·∫°ng X,Y,Z (v√≠ d·ª•: 10.5,20,30.2)");
                event.target.value = shape.v[vertexKey].join(',');
            }
        }

        function copyVertex(vertexKeyToCopy) {
            if (!selectedShapeId) {
                showToast('Vui l√≤ng ch·ªçn m·ªôt shape tr∆∞·ªõc.', 'warning');
                return;
            }
            const shape = shapesData.find(s => s._internalId === selectedShapeId);

            if (!shape) {
                showToast('Kh√¥ng t√¨m th·∫•y shape ƒë∆∞·ª£c ch·ªçn.', 'error');
                return;
            }

            // Ki·ªÉm tra shape.v v√† vertex ngu·ªìn
            if (typeof shape.v !== 'object' || shape.v === null || !shape.v[vertexKeyToCopy]) {
                showToast(`Kh√¥ng t√¨m th·∫•y vertex '${vertexKeyToCopy}' ho·∫∑c d·ªØ li·ªáu vertices kh√¥ng h·ª£p l·ªá.`, 'error');
                console.warn('[CopyVertex] Invalid shape.v or source vertex. Shape:', shape, 'VertexKey:', vertexKeyToCopy);
                return;
            }

            const coordsToCopy = [...shape.v[vertexKeyToCopy]];

            // T·∫°o key m·ªõi theo ƒë·ªãnh d·∫°ng 'vN', t∆∞∆°ng t·ª± nh∆∞ trong saveAndCloseModal
            let nextVertexNum = 1;
            const existingVertexKeys = Object.keys(shape.v);
            if (existingVertexKeys.length > 0) {
                const numericKeys = existingVertexKeys
                    .map(key => parseInt(String(key).replace('v', ''), 10))
                    .filter(num => !isNaN(num));
                if (numericKeys.length > 0) {
                    nextVertexNum = Math.max(...numericKeys) + 1;
                }
            }
            const newKey = String(nextVertexNum);

            shape.v[newKey] = coordsToCopy;
            renderVerticesList(shape); // V·∫Ω l·∫°i danh s√°ch vertices cho shape n√†y
            renderJsonOutput(); // C·∫≠p nh·∫≠t JSON v√† 3D view
            showToast(`Vertex ${vertexKeyToCopy} ƒë√£ ƒë∆∞·ª£c sao ch√©p th√†nh ${newKey}.`);
        }

        function deleteVertex(vertexKeyToDelete) {
            if (!selectedShapeId) return;
            const shape = shapesData.find(s => s._internalId === selectedShapeId);
            if (!shape || !shape.v[vertexKeyToDelete]) return;

            // B·ªè confirm, th·ª±c hi·ªán x√≥a tr·ª±c ti·∫øp
            // if (confirm(`B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a Vertex ID(${vertexKeyToDelete})? ƒêi·ªÅu n√†y c√≥ th·ªÉ ·∫£nh h∆∞·ªüng ƒë·∫øn Faces v√† Lines.`)) {
            delete shape.v[vertexKeyToDelete];
            renderVerticesList(shape);
            renderJsonOutput();
            showToast(`ƒê√£ x√≥a Vertex ID(${vertexKeyToDelete}). L∆∞u √Ω: Faces v√† Lines tham chi·∫øu ƒë·∫øn vertex n√†y c√≥ th·ªÉ kh√¥ng c√≤n h·ª£p l·ªá.`, 'warning');
            // }
        }

        addFaceBtn.onclick = () => {
            if (!selectedShapeId) return;
            const shape = shapesData.find(s => s._internalId === selectedShapeId);
            if (!shape) return;

            const verticesStr = faceVerticesInput.value.trim();
            const existingFaceKeys = Object.keys(shape.faces).map(k => parseInt(k)).filter(k => !isNaN(k));
            let newFaceKey = 0;
            if (existingFaceKeys.length > 0) {
                newFaceKey = Math.max(...existingFaceKeys) + 1;
            }
            const faceKey = newFaceKey.toString();

            if (!verticesStr) {
                showToast("Danh s√°ch vertices cho face kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng.", 'error');
                return;
            }
            const verticesIndices = verticesStr.split(',').map(v => parseInt(v.trim())).filter(v => !isNaN(v));
            if (verticesIndices.length < 3) {
                showToast("M·ªôt face c·∫ßn √≠t nh·∫•t 3 vertices.", 'error');
                return;
            }
            for (let vIndex of verticesIndices) {
                if (!shape.v[vIndex.toString()]) {
                    showToast(`Vertex ID '${vIndex}' kh√¥ng t·ªìn t·∫°i trong danh s√°ch vertices hi·ªán t·∫°i c·ªßa shape.`, 'error');
                    return;
                }
            }
            shape.faces[faceKey] = { vertices: verticesIndices };
            renderFacesList(shape);
            if (verticesIndices.length >= 2) {
                for (let i = 0; i < verticesIndices.length; i++) {
                    const vA = verticesIndices[i];
                    const vB = verticesIndices[(i + 1) % verticesIndices.length];
                    if (vA === vB || !shape.v[vA.toString()] || !shape.v[vB.toString()]) continue;
                    const lineExists = shape.lines.some(existingLine =>
                        (existingLine.v1 === vA && existingLine.v2 === vB) ||
                        (existingLine.v1 === vB && existingLine.v2 === vA)
                    );
                    if (!lineExists) {
                        shape.lines.push({ v1: vA, v2: vB });
                    }
                }
                renderLinesList(shape);
            }
            renderJsonOutput();
            faceVerticesInput.value = '';
        };

        function deleteFace(faceKeyToDelete) {
            if (!selectedShapeId) return;
            const shape = shapesData.find(s => s._internalId === selectedShapeId);
            if (!shape || !shape.faces[faceKeyToDelete]) return;
            delete shape.faces[faceKeyToDelete];
            renderFacesList(shape);
            renderJsonOutput();
        }

        addLineBtn.onclick = () => {
            if (!selectedShapeId) return;
            const shape = shapesData.find(s => s._internalId === selectedShapeId);
            if (!shape) return;
            const verticesStr = lineVerticesInput.value.trim();
            if (!verticesStr) {
                showToast("Vui l√≤ng nh·∫≠p ID c·ªßa hai ƒë·ªânh, c√°ch nhau b·ªüi d·∫•u ph·∫©y.", 'error');
                return;
            }
            const parts = verticesStr.split(',');
            if (parts.length !== 2) {
                showToast("ƒê·ªãnh d·∫°ng kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p hai ID ƒë·ªânh, c√°ch nhau b·ªüi d·∫•u ph·∫©y (v√≠ d·ª•: 0,1).", 'error');
                return;
            }
            const v1 = parseInt(parts[0].trim());
            const v2 = parseInt(parts[1].trim());
            if (isNaN(v1) || isNaN(v2)) {
                showToast("ID Vertex ph·∫£i l√† s·ªë.", 'error');
                return;
            }
            if (!shape.v[v1.toString()]) {
                showToast(`Vertex ID '${v1}' kh√¥ng t·ªìn t·∫°i trong shape n√†y.`, 'error');
                return;
            }
            if (!shape.v[v2.toString()]) {
                showToast(`Vertex ID '${v2}' kh√¥ng t·ªìn t·∫°i trong shape n√†y.`, 'error');
                return;
            }
            if (v1 === v2) {
                showToast("M·ªôt line kh√¥ng th·ªÉ b·∫Øt ƒë·∫ßu v√† k·∫øt th√∫c ·ªü c√πng m·ªôt vertex.", 'error');
                return;
            }
            const lineExists = shape.lines.some(existingLine =>
                (existingLine.v1 === v1 && existingLine.v2 === v2) || (existingLine.v1 === v2 && existingLine.v2 === v1)
            );
            if (lineExists) {
                showToast("Line n√†y ƒë√£ t·ªìn t·∫°i.", 'error');
                return;
            }
            shape.lines.push({ v1: v1, v2: v2 });
            renderLinesList(shape);
            renderJsonOutput();
            lineVerticesInput.value = '';
        };

        function deleteLine(lineIndexToDelete) {
            if (!selectedShapeId) return;
            const shape = shapesData.find(s => s._internalId === selectedShapeId);
            if (!shape || !shape.lines[lineIndexToDelete]) return;
            shape.lines.splice(lineIndexToDelete, 1);
            renderLinesList(shape);
            renderJsonOutput();
        }

        // --- Transformation Functions ---
        function calculateShapeCentroid(shape) {
            if (!shape || !shape.v || Object.keys(shape.v).length === 0) {
                return new THREE.Vector3(0, 0, 0); // Default to origin if no vertices
            }
            const centroid = new THREE.Vector3(0, 0, 0);
            const vertexKeys = Object.keys(shape.v);
            vertexKeys.forEach(key => {
                centroid.add(new THREE.Vector3(...shape.v[key]));
            });
            centroid.divideScalar(vertexKeys.length);
            return centroid;
        }

        applyTranslateBtn.onclick = () => {
            if (!selectedShapeId) return;
            const shape = shapesData.find(s => s._internalId === selectedShapeId);
            if (!shape || !shape.v) return;

            // ƒê·∫£m b·∫£o shape.pivot t·ªìn t·∫°i v√† l√† m·ªôt m·∫£ng
            shape.pivot = shape.pivot && Array.isArray(shape.pivot) && shape.pivot.length === 3 ? shape.pivot : [0, 0, 0];

            const deltaX = parseFloat(translateXInput.value) || 0;
            const deltaY = parseFloat(translateYInput.value) || 0;
            const deltaZ = parseFloat(translateZInput.value) || 0;

            shape.pivot[0] = parseFloat((shape.pivot[0] + deltaX).toFixed(1));
            shape.pivot[1] = parseFloat((shape.pivot[1] + deltaY).toFixed(1));
            shape.pivot[2] = parseFloat((shape.pivot[2] + deltaZ).toFixed(1));

            // Kh√¥ng c·∫ßn c·∫≠p nh·∫≠t shape.v n·ªØa v√¨ ch√∫ng l√† local
            // renderVerticesList(shape); // Kh√¥ng c·∫ßn thi·∫øt n·∫øu ch·ªâ pivot thay ƒë·ªïi
            renderSelectedShapeEditor(); // C·∫≠p nh·∫≠t gi√° tr·ªã pivot tr√™n UI
            renderJsonOutput(); // C·∫≠p nh·∫≠t JSON v√† 3D view
        };

        applyRotateBtn.onclick = () => {
            if (!selectedShapeId) return;
            const shape = shapesData.find(s => s._internalId === selectedShapeId);
            if (!shape || !shape.v) return;

            const angleX = THREE.MathUtils.degToRad(parseFloat(rotateXInput.value) || 0);
            const angleY = THREE.MathUtils.degToRad(parseFloat(rotateYInput.value) || 0);
            const angleZ = THREE.MathUtils.degToRad(parseFloat(rotateZInput.value) || 0);

            // const centroid = calculateShapeCentroid(shape); // Kh√¥ng c·∫ßn centroid n·ªØa v√¨ xoay local vertices
            const euler = new THREE.Euler(angleX, angleY, angleZ, 'XYZ'); // Th·ª© t·ª± xoay XYZ

            Object.keys(shape.v).forEach(key => {
                const vertex = new THREE.Vector3(...shape.v[key]); // ƒê√¢y l√† local vertex
                // vertex.sub(centroid); // Kh√¥ng c·∫ßn tr·ª´ centroid
                vertex.applyEuler(euler); // Xoay quanh g·ªëc (0,0,0) c·ªßa local space
                // vertex.add(centroid); // Kh√¥ng c·∫ßn c·ªông l·∫°i centroid
                shape.v[key] = [
                    parseFloat(vertex.x.toFixed(1)),
                    parseFloat(vertex.y.toFixed(1)),
                    parseFloat(vertex.z.toFixed(1))
                ];
            });
            renderVerticesList(shape);
            renderJsonOutput();
        };

        function applyFlip(axis) {
            if (!selectedShapeId) return;
            const shape = shapesData.find(s => s._internalId === selectedShapeId);
            if (!shape || !shape.v) return;

            // const centroid = calculateShapeCentroid(shape); // Kh√¥ng c·∫ßn centroid n·ªØa

            Object.keys(shape.v).forEach(key => {
                const vertex = new THREE.Vector3(...shape.v[key]); // Local vertex
                // vertex.sub(centroid); // Kh√¥ng c·∫ßn
                if (axis === 'x') vertex.x *= -1;
                if (axis === 'y') vertex.y *= -1;
                if (axis === 'z') vertex.z *= -1;
                // vertex.add(centroid); // Kh√¥ng c·∫ßn
                shape.v[key] = [
                    parseFloat(vertex.x.toFixed(1)),
                    parseFloat(vertex.y.toFixed(1)),
                    parseFloat(vertex.z.toFixed(1))
                ];
            });
            renderVerticesList(shape);
            renderJsonOutput();
        }

        flipXBtn.onclick = () => applyFlip('x');
        flipYBtn.onclick = () => applyFlip('y');
        flipZBtn.onclick = () => applyFlip('z');

        pivotXInput.onchange = handlePivotChange;
        pivotYInput.onchange = handlePivotChange;
        pivotZInput.onchange = handlePivotChange;

        function handlePivotChange() {
            if (!selectedShapeId) return;
            const shape = shapesData.find(s => s._internalId === selectedShapeId);
            if (!shape) return;

            const newPivotX = parseFloat(pivotXInput.value) || 0;
            const newPivotY = parseFloat(pivotYInput.value) || 0;
            const newPivotZ = parseFloat(pivotZInput.value) || 0;

            shape.pivot = [newPivotX, newPivotY, newPivotZ];
            renderJsonOutput(); // C·∫≠p nh·∫≠t 3D view v√† JSON
        }

        deformStretch2Checkbox.onchange = handleDeformTypeChange;
        deformClippingCheckbox.onchange = handleDeformTypeChange;

        function handleDeformTypeChange(event) {
            if (!selectedShapeId) return;
            const shape = shapesData.find(s => s._internalId === selectedShapeId);
            if (!shape) return;

            const type = event.target.id === 'deformStretch2Checkbox' ? 'Stretch2' : 'Clipping';
            shape.deformTypes = shape.deformTypes || [];

            if (event.target.checked) {
                // Th√™m n·∫øu ch∆∞a c√≥, gi·ªØ th·ª© t·ª± n·∫øu ƒë√£ c√≥ t·ª´ tr∆∞·ªõc (do uncheck r·ªìi check l·∫°i)
                if (!shape.deformTypes.includes(type)) {
                    shape.deformTypes.push(type);
                }
            } else {
                // X√≥a kh·ªèi m·∫£ng
                shape.deformTypes = shape.deformTypes.filter(dt => dt !== type);
            }
            updateCurrentDeformTypesText(shape.deformTypes); // C·∫≠p nh·∫≠t text hi·ªÉn th·ªã
            // Kh√¥ng c·∫ßn g·ªçi renderJsonOutput() ·ªü ƒë√¢y v√¨ JSON cho LineMesh ƒë∆∞·ª£c t·∫°o ri√™ng khi b·∫•m n√∫t
        }

        function updateCurrentDeformTypesText(deformTypesArray) {
            if (currentDeformTypesText) {
                currentDeformTypesText.textContent = deformTypesArray.join(', ') || 'None';
            }
        }

        function generateLineMeshJsonString() {
            const children = shapesData.map((shape, index) => {
                const identifiers = generateShapeIdentifiers(index, "Line");
                // ƒê·∫£m b·∫£o shape.name kh√¥ng r·ªóng, n·∫øu r·ªóng d√πng m·ªôt gi√° tr·ªã t·∫°m
                // const geometryName = (shape.name && shape.name.trim() !== '') ? shape.name.trim() : `Shape_${shape._internalId}`; // C≈©
                return {
                    "@type": ".Mesh2",
                    geometry: identifiers.name, // S·ª≠ d·ª•ng t√™n ƒë∆∞·ª£c t·∫°o ƒë·ªông
                    deformTypes: shape.deformTypes && Array.isArray(shape.deformTypes) ? shape.deformTypes : ['Stretch2'],
                    material: "MF", // Gi·ªØ nguy√™n nh∆∞ logic c≈© c·ªßa LineMesh
                    edgeMaterial: "ML0" // Gi·ªØ nguy√™n
                };
            });
            return JSON.stringify({ children: children }); // B·ªè null, 2 ƒë·ªÉ minimize
        }

        copyLineMeshBtn.onclick = () => {
            const lineMeshJson = generateLineMeshJsonString();
            navigator.clipboard.writeText(lineMeshJson).then(() => {
                showToast('ƒê√£ sao ch√©p Line Mesh JSON v√†o clipboard!', 'success');
            }).catch(err => {
                console.error('L·ªói khi sao ch√©p Line Mesh JSON: ', err);
                showToast('Kh√¥ng th·ªÉ t·ª± ƒë·ªông sao ch√©p Line Mesh JSON. Vui l√≤ng th·ª≠ l·∫°i.', 'error');
            });
        };

        function generateStdMeshJsonString() {
            const children = shapesData.map((shape, index) => {
                const identifiers = generateShapeIdentifiers(index, "Std");
                // const geometryName = (shape.name && shape.name.trim() !== '') ? shape.name.trim() : `Shape_${shape._internalId}`; // C≈©
                return {
                    "@type": ".Mesh2",
                    geometry: identifiers.name, // S·ª≠ d·ª•ng t√™n ƒë∆∞·ª£c t·∫°o ƒë·ªông
                    deformTypes: shape.deformTypes && Array.isArray(shape.deformTypes) ? shape.deformTypes : ['Stretch2'],
                    material: shape.stdMaterial || "",
                    matTag: "mat1"
                };
            });
            return JSON.stringify({ children: children }); // B·ªè null, 2 ƒë·ªÉ minimize
        }

        copyStdMeshBtn.onclick = () => {
            const stdMeshJson = generateStdMeshJsonString();
            navigator.clipboard.writeText(stdMeshJson).then(() => {
                showToast('ƒê√£ sao ch√©p Std Mesh JSON v√†o clipboard!', 'success');
            }).catch(err => {
                console.error('L·ªói khi sao ch√©p Std Mesh JSON: ', err);
                showToast('Kh√¥ng th·ªÉ t·ª± ƒë·ªông sao ch√©p Std Mesh JSON. Vui l√≤ng th·ª≠ l·∫°i.', 'error');
            });
        };

        stdMaterialInput.onchange = (e) => {
            if (selectedShapeId) {
                const shape = shapesData.find(s => s._internalId === selectedShapeId);
                if (shape) {
                    shape.stdMaterial = e.target.value;
                    // Kh√¥ng c·∫ßn renderJsonOutput() v√¨ stdMaterial kh√¥ng ·∫£nh h∆∞·ªüng tr·ª±c ti·∫øp ƒë·∫øn 3D view ho·∫∑c JSON c·ªßa c√°c n√∫t copy kh√°c
                }
            }
        };

        importJsonBtn.onclick = async () => {
            try {
                const textFromClipboard = await navigator.clipboard.readText();
                if (!textFromClipboard) {
                    showToast("Clipboard r·ªóng ho·∫∑c kh√¥ng ch·ª©a d·ªØ li·ªáu text.", 'info');
                    return;
                }

                const parsedData = JSON.parse(textFromClipboard);

                if (!parsedData || !Array.isArray(parsedData.shapes)) {
                    showToast("L·ªói: D·ªØ li·ªáu t·ª´ clipboard kh√¥ng ph·∫£i JSON h·ª£p l·ªá ho·∫∑c kh√¥ng c√≥ thu·ªôc t√≠nh 'shapes' d·∫°ng m·∫£ng.", 'error');
                    return;
                }

                const isValidShapeStructure = parsedData.shapes.every(shape =>
                    typeof shape.v === 'object' && shape.v !== null &&
                    typeof shape.faces === 'object' && shape.faces !== null &&
                    Array.isArray(shape.lines)
                );

                if (!isValidShapeStructure) {
                    showToast("L·ªói: M·ªôt ho·∫∑c nhi·ªÅu shape trong JSON t·ª´ clipboard kh√¥ng c√≥ c·∫•u tr√∫c v, faces, ho·∫∑c lines h·ª£p l·ªá.", 'error');
                    return;
                }

                if (!currentObjectName || currentObjectName.trim() === "") {
                    showToast("Vui l√≤ng nh·∫≠p Object Name tr∆∞·ªõc khi import JSON.", 'warning');
                    objectNameInput.focus();
                    return;
                }

                shapesData = parsedData.shapes.map((s, index) => {
                    const internalId = Date.now() + index + Math.random();
                    return {
                        _internalId: internalId,
                        v: s.v || {},
                        faces: s.faces || {},
                        lines: s.lines || [],
                        pivot: s.pivot && Array.isArray(s.pivot) && s.pivot.length === 3 ? s.pivot : [0, 0, 0],
                        // N·∫øu s.deformTypes kh√¥ng t·ªìn t·∫°i, s·∫Ω l·∫•y t·ª´ c√°c checkbox m·∫∑c ƒë·ªãnh (gi·ªù ƒë√¢y s·∫Ω l√† r·ªóng n·∫øu kh√¥ng check)
                        deformTypes: s.deformTypes && Array.isArray(s.deformTypes) ? s.deformTypes : (defaultDeformStretch2Checkbox.checked ? ['Stretch2'] : []).concat(defaultDeformClippingCheckbox.checked ? ['Clipping'] : []),
                        stdMaterial: s.stdMaterial || defaultStdMaterialInput.value.trim()
                    };
                });

                selectedShapeId = null;
                renderShapesList();
                renderSelectedShapeEditor();
                renderJsonOutput();

                if (shapesData.length > 0 && !selectedShapeId) {
                    // Option: select the first shape automatically after import
                    // selectShape(shapesData[0]._internalId);
                } else if (selectedShapeId) {
                    const currentSelectedShape = shapesData.find(s => s._internalId === selectedShapeId);
                    if (currentSelectedShape) {
                        updateCurrentDeformTypesText(currentSelectedShape.deformTypes);
                    }
                } else {
                    if (currentDeformTypesText) currentDeformTypesText.textContent = 'None';
                }

            } catch (error) {
                console.error("L·ªói khi import JSON t·ª´ clipboard:", error);
                if (error.name === 'NotAllowedError') {
                    showToast("L·ªói: Kh√¥ng ƒë∆∞·ª£c ph√©p truy c·∫≠p clipboard. Vui l√≤ng c·∫•p quy·ªÅn cho trang web.", 'error');
                } else if (error instanceof SyntaxError) {
                    showToast("L·ªói: D·ªØ li·ªáu trong clipboard kh√¥ng ph·∫£i l√† ƒë·ªãnh d·∫°ng JSON h·ª£p l·ªá.", 'error');
                } else {
                    showToast("ƒê√£ x·∫£y ra l·ªói khi ƒë·ªçc ho·∫∑c parse JSON t·ª´ clipboard. Vui l√≤ng ki·ªÉm tra console.", 'error');
                }
            }
        };

        uploadJsonBtn.onclick = () => {
            uploadJsonFile.click(); // Trigger click event c·ªßa input file ·∫©n
        };

        uploadJsonFile.onchange = async (event) => {
            const file = event.target.files[0];
            if (!file) {
                showToast("Kh√¥ng c√≥ file n√†o ƒë∆∞·ª£c ch·ªçn.", 'info');
                return;
            }

            if (file.type !== "application/json") {
                showToast("Vui l√≤ng ch·ªçn m·ªôt file .json h·ª£p l·ªá.", 'error');
                event.target.value = null; // Reset input file
                return;
            }

            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const textFromFile = e.target.result;
                    if (!textFromFile) {
                        showToast("File r·ªóng ho·∫∑c kh√¥ng th·ªÉ ƒë·ªçc.", 'error');
                        event.target.value = null; // Reset input file
                        return;
                    }

                    const parsedData = JSON.parse(textFromFile);

                    if (!parsedData || !Array.isArray(parsedData.shapes)) {
                        showToast("L·ªói: D·ªØ li·ªáu t·ª´ file kh√¥ng ph·∫£i JSON h·ª£p l·ªá ho·∫∑c kh√¥ng c√≥ thu·ªôc t√≠nh 'shapes' d·∫°ng m·∫£ng.", 'error');
                        event.target.value = null; // Reset input file
                        return;
                    }

                    const isValidShapeStructure = parsedData.shapes.every(shape =>
                        typeof shape.v === 'object' && shape.v !== null &&
                        typeof shape.faces === 'object' && shape.faces !== null &&
                        Array.isArray(shape.lines)
                    );

                    if (!isValidShapeStructure) {
                        showToast("L·ªói: M·ªôt ho·∫∑c nhi·ªÅu shape trong JSON t·ª´ file kh√¥ng c√≥ c·∫•u tr√∫c v, faces, ho·∫∑c lines h·ª£p l·ªá.", 'error');
                        event.target.value = null; // Reset input file
                        return;
                    }

                    if (!currentObjectName || currentObjectName.trim() === "") {
                        showToast("Vui l√≤ng nh·∫≠p Object Name tr∆∞·ªõc khi import JSON.", 'warning');
                        objectNameInput.focus();
                        event.target.value = null; // Reset input file
                        return;
                    }

                    shapesData = parsedData.shapes.map((s, index) => {
                        const internalId = Date.now() + index + Math.random();
                        return {
                            _internalId: internalId,
                            v: s.v || {},
                            faces: s.faces || {},
                            lines: s.lines || [],
                            pivot: s.pivot && Array.isArray(s.pivot) && s.pivot.length === 3 ? s.pivot : [0, 0, 0],
                            deformTypes: s.deformTypes && Array.isArray(s.deformTypes) ? s.deformTypes : (defaultDeformStretch2Checkbox.checked ? ['Stretch2'] : []).concat(defaultDeformClippingCheckbox.checked ? ['Clipping'] : []),
                            stdMaterial: s.stdMaterial || defaultStdMaterialInput.value.trim()
                        };
                    });

                    selectedShapeId = null;
                    renderShapesList();
                    renderSelectedShapeEditor();
                    renderJsonOutput();
                    showToast(`ƒê√£ import th√†nh c√¥ng d·ªØ li·ªáu t·ª´ file ${file.name}`, 'success');


                    if (shapesData.length > 0 && !selectedShapeId) {
                        // Option: select the first shape automatically after import
                        // selectShape(shapesData[0]._internalId);
                    } else if (selectedShapeId) {
                        const currentSelectedShape = shapesData.find(s => s._internalId === selectedShapeId);
                        if (currentSelectedShape) {
                            updateCurrentDeformTypesText(currentSelectedShape.deformTypes);
                        }
                    } else {
                        if (currentDeformTypesText) currentDeformTypesText.textContent = 'None';
                    }
                    event.target.value = null; // Reset input file sau khi x·ª≠ l√Ω th√†nh c√¥ng

                } catch (error) {
                    console.error("L·ªói khi import JSON t·ª´ file:", error);
                    if (error instanceof SyntaxError) {
                        showToast("L·ªói: D·ªØ li·ªáu trong file kh√¥ng ph·∫£i l√† ƒë·ªãnh d·∫°ng JSON h·ª£p l·ªá.", 'error');
                    } else {
                        showToast("ƒê√£ x·∫£y ra l·ªói khi ƒë·ªçc ho·∫∑c parse JSON t·ª´ file. Vui l√≤ng ki·ªÉm tra console.", 'error');
                    }
                    event.target.value = null; // Reset input file
                }
            };
            reader.onerror = () => {
                showToast("L·ªói khi ƒë·ªçc file.", 'error');
                event.target.value = null; // Reset input file
            };
            reader.readAsText(file);
        };

        function copyShape(shapeIdToCopy) {
            // T√¨m shape g·ªëc ƒë·ªÉ sao ch√©p
            const originalShape = shapesData.find(s => s._internalId === shapeIdToCopy);
            if (!originalShape) return;

            // T·∫°o m·ªôt b·∫£n sao s√¢u c·ªßa shape (tr·ª´ _internalId)
            // Quan tr·ªçng: C·∫ßn sao ch√©p s√¢u c√°c object v√† array b√™n trong (v, faces, lines, pivot, deformTypes)
            const newShapeInternalId = Date.now() + Math.random();
            const newV = JSON.parse(JSON.stringify(originalShape.v || {}));
            const newFaces = JSON.parse(JSON.stringify(originalShape.faces || {}));
            const newLines = JSON.parse(JSON.stringify(originalShape.lines || []));
            const newPivot = JSON.parse(JSON.stringify(originalShape.pivot || [0, 0, 0]));
            const newDeformTypes = JSON.parse(JSON.stringify(originalShape.deformTypes || []));

            const copiedShape = {
                _internalId: newShapeInternalId,
                v: newV,
                faces: newFaces,
                lines: newLines,
                pivot: newPivot, // Sao ch√©p pivot
                deformTypes: newDeformTypes, // Sao ch√©p deformTypes
                stdMaterial: originalShape.stdMaterial // Sao ch√©p stdMaterial
            };

            // Th√™m shape ƒë√£ sao ch√©p v√†o m·∫£ng shapesData
            shapesData.push(copiedShape);

            // C·∫≠p nh·∫≠t danh s√°ch shapes v√† t·ª± ƒë·ªông ch·ªçn shape m·ªõi ƒë∆∞·ª£c sao ch√©p
            renderShapesList();
            selectShape(newShapeInternalId); // Ch·ªçn shape m·ªõi ƒë∆∞·ª£c copy
        }

        applyDefaultsBtn.onclick = () => {
            const defaultStdMaterial = defaultStdMaterialInput.value.trim();
            const defaultDeformTypes = [];
            if (defaultDeformStretch2Checkbox.checked) defaultDeformTypes.push('Stretch2');
            if (defaultDeformClippingCheckbox.checked) defaultDeformTypes.push('Clipping');

            if (shapesData.length === 0) {
                showToast("Kh√¥ng c√≥ shape n√†o ƒë·ªÉ √°p d·ª•ng.", 'info');
                return;
            }

            const confirmApply = confirm(`B·∫°n c√≥ ch·∫Øc mu·ªën √°p d·ª•ng default Std Material '${defaultStdMaterial}' v√† Deform Types '${defaultDeformTypes.join(', ')}' cho t·∫•t c·∫£ ${shapesData.length} shapes kh√¥ng? H√†nh ƒë·ªông n√†y kh√¥ng th·ªÉ ho√†n t√°c.`);
            if (!confirmApply) return;

            shapesData.forEach(shape => {
                shape.stdMaterial = defaultStdMaterial;
                shape.deformTypes = [...defaultDeformTypes]; // T·∫°o b·∫£n sao ƒë·ªÉ tr√°nh tham chi·∫øu
            });

            if (selectedShapeId) {
                renderSelectedShapeEditor(); // C·∫≠p nh·∫≠t editor n·∫øu c√≥ shape ƒëang ƒë∆∞·ª£c ch·ªçn
            }
            renderJsonOutput(); // C·∫≠p nh·∫≠t 3D view
            showToast(`ƒê√£ √°p d·ª•ng gi√° tr·ªã m·∫∑c ƒë·ªãnh cho ${shapesData.length} shapes.`, 'success');
        };

        copyLineGeometryBtn.onclick = () => {
            const lineGeometryJsonString = generateJsonString(true); // true ƒë·ªÉ bao g·ªìm lines
            if (!lineGeometryJsonString) {
                showToast('Kh√¥ng c√≥ d·ªØ li·ªáu Line Geometry JSON ƒë·ªÉ sao ch√©p.', 'info');
                return;
            }
            navigator.clipboard.writeText(lineGeometryJsonString).then(() => {
                showToast('ƒê√£ sao ch√©p Line Geometry JSON v√†o clipboard!', 'success');
            }).catch(err => {
                console.error('L·ªói khi sao ch√©p Line Geometry JSON: ', err);
                showToast('Kh√¥ng th·ªÉ t·ª± ƒë·ªông sao ch√©p JSON. Vui l√≤ng th·ª≠ l·∫°i.', 'error');
            });
        };

        copyStdGeometryBtn.onclick = () => {
            const stdGeometryJsonString = generateJsonString(false); // false ƒë·ªÉ kh√¥ng bao g·ªìm lines
            if (!stdGeometryJsonString) {
                showToast('Kh√¥ng th·ªÉ t·∫°o Standard Geometry JSON.', 'info');
                return;
            }
            navigator.clipboard.writeText(stdGeometryJsonString).then(() => {
                showToast('ƒê√£ sao ch√©p Standard Geometry JSON (kh√¥ng c√≥ lines) v√†o clipboard!', 'success');
            }).catch(err => {
                console.error('L·ªói khi sao ch√©p Standard Geometry JSON: ', err);
                showToast('Kh√¥ng th·ªÉ t·ª± ƒë·ªông sao ch√©p JSON. Vui l√≤ng th·ª≠ l·∫°i.', 'error');
            });
        };

        // --- Toast Notification Function ---
        function showToast(message, type = 'info') {
            const toastContainer = document.querySelector('.toast-container');
            if (!toastContainer) return; // Should not happen if HTML is correct

            const toastId = 'toast-' + Date.now();
            let toastHeaderClass = '';
            let toastIcon = '';

            switch (type) {
                case 'success':
                    toastHeaderClass = 'bg-success text-white';
                    toastIcon = '‚úîÔ∏è'; // Simple check icon
                    break;
                case 'error':
                    toastHeaderClass = 'bg-danger text-white';
                    toastIcon = '‚ùå'; // Simple cross icon
                    break;
                case 'warning':
                    toastHeaderClass = 'bg-warning text-dark';
                    toastIcon = '‚ö†Ô∏è'; // Simple warning icon
                    break;
                default: // info
                    toastHeaderClass = 'bg-info text-white';
                    toastIcon = '‚ÑπÔ∏è'; // Simple info icon
                    break;
            }

            const toastHTML = `
                <div id="${toastId}" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-delay="5000">
                    <div class="toast-header ${toastHeaderClass}">
                        <strong class="mr-auto">${toastIcon} Th√¥ng b√°o</strong>
                        <button type="button" class="ml-2 mb-1 close" data-dismiss="toast" aria-label="Close">
                            <span aria-hidden="true">&times;</span>
                        </button>
                    </div>
                    <div class="toast-body">
                        ${message}
                    </div>
                </div>
            `;

            toastContainer.insertAdjacentHTML('beforeend', toastHTML);
            const toastElement = document.getElementById(toastId);
            $(toastElement).toast('show'); // Initialize and show the toast using jQuery

            // Optional: Remove the toast from DOM after it's hidden
            $(toastElement).on('hidden.bs.toast', function () {
                this.remove();
            });
        }

        // --- Initialization ---
        function init() {
            // C√≥ th·ªÉ load d·ªØ li·ªáu m·∫´u ho·∫∑c t·ª´ localStorage ·ªü ƒë√¢y
            objectNameInput.value = currentObjectName; // ƒê·∫£m b·∫£o input hi·ªÉn th·ªã gi√° tr·ªã kh·ªüi t·∫°o

            renderShapesList();
            renderSelectedShapeEditor(); // Ban ƒë·∫ßu s·∫Ω ·∫©n editor
            renderJsonOutput(); // This will also call update3DView
            init3DViewer();
        }

        init();

        // --- Modal Canvas View Parameter Calculation ---
        function calculateAndUpdateModalCanvasViewParams() {
            const shapeDetailCanvas = document.getElementById('shapeDetailCanvas');
            if (!shapeDetailCanvas || !currentEditingShapeInModal) {
                console.warn("calculateAndUpdateModalCanvasViewParams: Canvas or current editing shape not available. Using defaults.");
                if (shapeDetailCanvas) { // If canvas exists, center origin with default PPU
                    PIXELS_PER_UNIT = PIXELS_PER_UNIT_DEFAULT;
                    modalOriginX = shapeDetailCanvas.width / 2;
                    modalOriginY = shapeDetailCanvas.height / 2;
                } else { // Fallback if canvas itself is missing (should not happen if modal is open)
                    PIXELS_PER_UNIT = PIXELS_PER_UNIT_DEFAULT;
                    modalOriginX = 250; // Arbitrary default
                    modalOriginY = 250; // Arbitrary default
                }
                return;
            }

            const canvasWidthForCalc = shapeDetailCanvas.width;
            const canvasHeightForCalc = shapeDetailCanvas.height;
            // Use temporaryNewPoints for fitting, as these include existing points plus newly added ones
            const pointsToConsider = temporaryNewPoints; 

            if (pointsToConsider.length > 0) {
                let minCoord1, maxCoord1, minCoord2, maxCoord2;

                if (currentModalViewMode === 'oxy') {
                    minCoord1 = Math.min(...pointsToConsider.map(p => p.x));
                    maxCoord1 = Math.max(...pointsToConsider.map(p => p.x));
                    minCoord2 = Math.min(...pointsToConsider.map(p => p.y));
                    maxCoord2 = Math.max(...pointsToConsider.map(p => p.y));
                } else if (currentModalViewMode === 'oxz') {
                    minCoord1 = Math.min(...pointsToConsider.map(p => p.x));
                    maxCoord1 = Math.max(...pointsToConsider.map(p => p.x));
                    minCoord2 = Math.min(...pointsToConsider.map(p => p.z)); 
                    maxCoord2 = Math.max(...pointsToConsider.map(p => p.z));
                } else { // oyz
                    minCoord1 = Math.min(...pointsToConsider.map(p => p.y)); 
                    maxCoord1 = Math.max(...pointsToConsider.map(p => p.y));
                    minCoord2 = Math.min(...pointsToConsider.map(p => p.z)); 
                    maxCoord2 = Math.max(...pointsToConsider.map(p => p.z));
                }

                const dataRange1 = (maxCoord1 - minCoord1);
                const dataRange2 = (maxCoord2 - minCoord2);
                let scale1 = Infinity, scale2 = Infinity;

                if (dataRange1 > 0.00001) { // Epsilon for floating point comparison
                    scale1 = (canvasWidthForCalc - MODAL_CANVAS_PADDING * 2) / dataRange1;
                }
                if (dataRange2 > 0.00001) {
                    scale2 = (canvasHeightForCalc - MODAL_CANVAS_PADDING * 2) / dataRange2;
                }
                
                if (pointsToConsider.length === 1 || (dataRange1 <= 0.00001 && dataRange2 <= 0.00001) ) {
                    PIXELS_PER_UNIT = PIXELS_PER_UNIT_DEFAULT;
                } else if (dataRange1 <= 0.00001) { // Points form a "vertical" line in current projection
                    PIXELS_PER_UNIT = (scale2 !== Infinity && scale2 > 0) ? scale2 : PIXELS_PER_UNIT_DEFAULT;
                } else if (dataRange2 <= 0.00001) { // Points form a "horizontal" line in current projection
                    PIXELS_PER_UNIT = (scale1 !== Infinity && scale1 > 0) ? scale1 : PIXELS_PER_UNIT_DEFAULT;
                } else {
                     PIXELS_PER_UNIT = Math.min(scale1, scale2);
                }
                
                // Clamp PPU. Allow very small PPU for large coordinate ranges.
        // Max PPU prevents excessive zoom for very small shapes.
        // Min PPU prevents PPU from becoming zero or negative if calculations are extreme.
        const MIN_PPU_CLAMP = 0.001; // Allow 1 world unit to be very small in pixels
        const MAX_PPU_CLAMP = 500;   // Max 500 pixels for one world unit

        if (!(PIXELS_PER_UNIT > 0 && isFinite(PIXELS_PER_UNIT))) {
            console.warn(`[CalcViewParams] PPU was calculated as non-positive/infinite (${PIXELS_PER_UNIT}). Resetting to default.`);
            PIXELS_PER_UNIT = PIXELS_PER_UNIT_DEFAULT;
        }
        PIXELS_PER_UNIT = Math.max(MIN_PPU_CLAMP, Math.min(PIXELS_PER_UNIT, MAX_PPU_CLAMP));

                const worldCenter1 = (minCoord1 + maxCoord1) / 2;
                const worldCenter2 = (minCoord2 + maxCoord2) / 2;

                modalOriginX = (canvasWidthForCalc / 2) - (worldCenter1 * PIXELS_PER_UNIT);
                modalOriginY = (canvasHeightForCalc / 2) + (worldCenter2 * PIXELS_PER_UNIT); // Canvas Y is inverted from world Y/Z

                console.log(`[CalcViewParams] View: ${currentModalViewMode}, DataRange1: (${minCoord1.toFixed(2)}-${maxCoord1.toFixed(2)}), DataRange2: (${minCoord2.toFixed(2)}-${maxCoord2.toFixed(2)})`);
                console.log(`[CalcViewParams] Calculated PPU: ${PIXELS_PER_UNIT.toFixed(2)}, Origin: (${modalOriginX.toFixed(2)}, ${modalOriginY.toFixed(2)})`);

            } else {
                // No points, use default zoom and center origin
                PIXELS_PER_UNIT = PIXELS_PER_UNIT_DEFAULT;
                modalOriginX = canvasWidthForCalc / 2;
                modalOriginY = canvasHeightForCalc / 2;
                console.log('[CalcViewParams] No points. Using default PPU and centered origin.');
            }
        }

        // --- Raycaster Click Handler ---
        function onDocumentMouseDown(event) {
            event.preventDefault();
            console.log(event);

            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(shapesGroup.children, true);

            if (intersects.length > 0) {
                let clickedObject = intersects[0].object;
                let parentGroupWithShapeId = null;
                console.log(clickedObject);

                while (clickedObject && clickedObject !== scene) {
                    if (clickedObject.userData && clickedObject.userData.shapeId) {
                        parentGroupWithShapeId = clickedObject;
                        break;
                    }
                    clickedObject = clickedObject.parent;
                }

                if (parentGroupWithShapeId) {
                    const shapeId = parentGroupWithShapeId.userData.shapeId;
                    if (shapeId && shapeId !== selectedShapeId) {
                        selectShape(shapeId);
                    }
                }
            }
        }

        // --- Shape Canvas Modal Logic ---
        let currentEditingShapeInModal = null; // Shape ƒëang ƒë∆∞·ª£c ch·ªânh s·ª≠a trong modal
        const COORD_EPSILON = 0.001; // Ng∆∞·ª°ng ƒë·ªÉ so s√°nh t·ªça ƒë·ªô ƒëi·ªÉm

        // Helper function to get unique points from an array based on an epsilon
        function getUniquePoints(pointsArray, epsilon) {
            const unique = [];
            pointsArray.forEach(p1 => {
                let isDuplicate = false;
                for (const p2 of unique) {
                    if (Math.abs(p1.x - p2.x) < epsilon &&
                        Math.abs(p1.y - p2.y) < epsilon &&
                        Math.abs(p1.z - p2.z) < epsilon) {
                        isDuplicate = true;
                        break;
                    }
                }
                if (!isDuplicate) {
                    unique.push(p1);
                }
            });
            return unique;
        }

        function closeShapeEditorModal() {
            const shapeCanvasModal = document.getElementById('shapeCanvasModal');
            if (shapeCanvasModal) {
                shapeCanvasModal.style.display = 'none';
            }
            currentEditingShapeInModal = null; // X√≥a tham chi·∫øu khi ƒë√≥ng modal
            // console.log('Modal closed, currentEditingShapeInModal:', currentEditingShapeInModal);

            // Reset tr·∫°ng th√°i t∆∞∆°ng t√°c
            currentModalInteractionMode = 'none'; // Reset mode
            setActiveModalModeButton('interactionModeNoneBtn'); // Reset to 'none' mode
            if (modalClickedPointCoordsContainer) modalClickedPointCoordsContainer.style.display = 'none';
            selectedTemporaryPointIndex = -1; // B·ªè highlight t·∫•t c·∫£ c√°c n√∫t ch·∫ø ƒë·ªô
            const canvas = document.getElementById('shapeDetailCanvas');
            if (canvas) {
                canvas.style.cursor = 'default';
            }
        }

        function updateShapeInList(updatedShape) {
            if (!updatedShape || !updatedShape._internalId) {
                console.error('[UpdateShape] Invalid shape or missing _internalId for update.');
                return;
            }
            // 'shapesData' l√† m·∫£ng to√†n c·ª•c ch·ª©a c√°c shape objects
            const index = shapesData.findIndex(s => s._internalId === updatedShape._internalId);
            if (index !== -1) {
                shapesData[index] = updatedShape;
                console.log('[UpdateShape] Shape updated in list:', updatedShape);
            } else {
                console.warn('[UpdateShape] Shape not found in list for ID:', updatedShape._internalId);
            }
        }

        // H√†m c·∫≠p nh·∫≠t t·ªça ƒë·ªô ƒëi·ªÉm t·∫°m th·ªüi t·ª´ input
        function updateTemporaryPointFromInputs() {
            console.log('[UpdateTempPoint] Function called. Selected Index:', selectedTemporaryPointIndex);
            if (selectedTemporaryPointIndex === -1 || !temporaryNewPoints[selectedTemporaryPointIndex]) {
                console.warn('[UpdateTempPoint] No temporary point selected or invalid index. Current temporaryNewPoints:', JSON.stringify(temporaryNewPoints));
                return;
            }

            const currentPoint = temporaryNewPoints[selectedTemporaryPointIndex];
            console.log(`[UpdateTempPoint] Point ${selectedTemporaryPointIndex} BEFORE update: (${currentPoint.x}, ${currentPoint.y}, ${currentPoint.z})`);

            const newX = parseFloat(modalPointXInput.value);
            const newY = parseFloat(modalPointYInput.value);
            const newZ = parseFloat(modalPointZInput.value);

            let changed = false;
            if (!isNaN(newX) && currentPoint.x !== newX) { currentPoint.x = newX; changed = true; }
            if (!isNaN(newY) && currentPoint.y !== newY) { currentPoint.y = newY; changed = true; }
            if (!isNaN(newZ) && currentPoint.z !== newZ) { currentPoint.z = newZ; changed = true; }

            if (changed) {
                console.log(`[UpdateTempPoint] Point ${selectedTemporaryPointIndex} AFTER update: (${currentPoint.x}, ${currentPoint.y}, ${currentPoint.z})`);
                console.log('[UpdateTempPoint] Calling drawModalCanvas() to refresh.');
                drawModalCanvas(); // V·∫Ω l·∫°i to√†n b·ªô modal canvas ƒë·ªÉ ph·∫£n √°nh thay ƒë·ªïi
            } else {
                console.log(`[UpdateTempPoint] No change in values for point ${selectedTemporaryPointIndex}.`);
            }
        }

        function saveAndCloseModal() {
    console.log('[SaveModal] Attempting to save changes...');
    try {
        if (!currentEditingShapeInModal) {
            console.log('[SaveModal] No shape currently being edited.');
            showToast('Kh√¥ng c√≥ shape n√†o ƒëang ƒë∆∞·ª£c ch·ªânh s·ª≠a.', 'info');
            return; 
        }
        if (!temporaryNewPoints || temporaryNewPoints.length === 0) {
            console.log('[SaveModal] No new temporary points to save.');
            showToast('Kh√¥ng c√≥ ƒëi·ªÉm t·∫°m th·ªùi n√†o ƒë·ªÉ l∆∞u.', 'info');
            return;
        }

        // 1. L·ªçc c√°c ƒëi·ªÉm duy nh·∫•t t·ª´ temporaryNewPoints
        const uniqueTempPoints = getUniquePoints(temporaryNewPoints, COORD_EPSILON);
        if (uniqueTempPoints.length === 0) {
            console.log('[SaveModal] All temporary points were duplicates of each other or list was empty after filtering.');
            showToast('Kh√¥ng c√≥ ƒëi·ªÉm m·ªõi h·ª£p l·ªá n√†o ƒë·ªÉ th√™m (c√≥ th·ªÉ t·∫•t c·∫£ ƒë·ªÅu tr√πng l·∫∑p).', 'info');
            return;
        }

        // ƒê·∫£m b·∫£o currentEditingShapeInModal.v l√† m·ªôt ƒë·ªëi t∆∞·ª£ng
        if (typeof currentEditingShapeInModal.v !== 'object' || currentEditingShapeInModal.v === null) {
            currentEditingShapeInModal.v = {};
        }

        // 2. X√°c ƒë·ªãnh ID s·ªë ti·∫øp theo cho vertex (v√≠ d·ª•: 0, 1, 2, ...)
        let nextVertexNum = 0; // B·∫Øt ƒë·∫ßu t·ª´ 0 n·∫øu kh√¥ng c√≥ key s·ªë n√†o t·ªìn t·∫°i
        const existingVertexKeys = Object.keys(currentEditingShapeInModal.v);
        
        if (existingVertexKeys.length > 0) {
            const numericStringKeys = existingVertexKeys.filter(key => /^\d+$/.test(key)); // L·ªçc c√°c key l√† chu·ªói s·ªë
            
            if (numericStringKeys.length > 0) {
                const numericKeysAsNumbers = numericStringKeys.map(key => parseInt(key, 10));
                nextVertexNum = Math.max(...numericKeysAsNumbers) + 1;
            }
            // N·∫øu kh√¥ng c√≥ key d·∫°ng s·ªë n√†o (v√≠ d·ª•: ch·ªâ c√≥ "v0", "v1"), nextVertexNum s·∫Ω v·∫´n l√† 0.
        }
        console.log(`[SaveModal] Starting new numeric vertex ID from ${nextVertexNum}`);

        let addedPointsCount = 0;
        uniqueTempPoints.forEach(pointObj => {
            // 3. Ki·ªÉm tra tr√πng l·∫∑p v·ªõi c√°c vertex hi·ªán c√≥ trong shape
            let isDuplicateWithExisting = false;
            for (const vertexKey in currentEditingShapeInModal.v) {
                const existingVertexArray = currentEditingShapeInModal.v[vertexKey]; // D·∫°ng [x, y, z]
                if (Math.abs(existingVertexArray[0] - pointObj.x) < COORD_EPSILON &&
                    Math.abs(existingVertexArray[1] - pointObj.y) < COORD_EPSILON &&
                    Math.abs(existingVertexArray[2] - pointObj.z) < COORD_EPSILON) {
                    isDuplicateWithExisting = true;
                    console.log(`[SaveModal] Point (${pointObj.x.toFixed(2)}, ${pointObj.y.toFixed(2)}, ${pointObj.z.toFixed(2)}) is a duplicate of existing vertex ${vertexKey}. Skipping.`);
                    break;
                }
            }

            if (!isDuplicateWithExisting) {
                const newVertexId = String(nextVertexNum); // ƒê·ªãnh d·∫°ng ID l√† "0", "1", ...
                currentEditingShapeInModal.v[newVertexId] = [pointObj.x, pointObj.y, pointObj.z];
                console.log(`[SaveModal] Added vertex ${newVertexId}: [${pointObj.x.toFixed(2)}, ${pointObj.y.toFixed(2)}, ${pointObj.z.toFixed(2)}]`);
                nextVertexNum++; // TƒÉng s·ªë hi·ªáu cho ID ti·∫øp theo
                addedPointsCount++;
            }
        });

        if (addedPointsCount > 0) {
            console.log('[SaveModal] Vertices object after adding new points:', JSON.stringify(currentEditingShapeInModal.v));
            updateShapeInList(currentEditingShapeInModal); // C·∫≠p nh·∫≠t trong danh s√°ch shapesData
            renderShapesList(); // V·∫Ω l·∫°i danh s√°ch shape UI
            selectShape(currentEditingShapeInModal._internalId); // Ch·ªçn l·∫°i shape v·ª´a s·ª≠a
            renderSelectedShapeEditor(); // C·∫≠p nh·∫≠t editor panel
            update3DView(); // C·∫≠p nh·∫≠t view 3D

            showToast(`ƒê√£ th√™m ${addedPointsCount} ƒëi·ªÉm m·ªõi v√†o shape '${currentEditingShapeInModal.n || currentEditingShapeInModal.name}'.`);
        } else {
            showToast('Kh√¥ng c√≥ ƒëi·ªÉm m·ªõi n√†o ƒë∆∞·ª£c th√™m (t·∫•t c·∫£ ƒë·ªÅu tr√πng v·ªõi c√°c ƒëi·ªÉm ƒë√£ c√≥ ho·∫∑c ƒë√£ t·ªìn t·∫°i trong danh s√°ch t·∫°m th·ªùi).', 'info');
        }

    } catch (error) {
        console.error('[SaveModal] Error during save operation:', error);
        showToast('L·ªói: Kh√¥ng th·ªÉ l∆∞u c√°c thay ƒë·ªïi. Vui l√≤ng ki·ªÉm tra Console.', 'error');
    } finally {
        closeShapeEditorModal(); // ƒê·∫£m b·∫£o modal lu√¥n ƒë√≥ng v√† reset tr·∫°ng th√°i
    }
}

        // C·∫≠p nh·∫≠t n√∫t ƒë√≥ng tr√™n HTML c·ªßa modal ƒë·ªÉ g·ªçi h√†m n√†y
        // V√≠ d·ª•: onclick="closeShapeEditorModal()"

        document.addEventListener('DOMContentLoaded', () => {
            const openShapeCanvasModalBtn = document.getElementById('openShapeCanvasModalBtn');

        if (openShapeCanvasModalBtn) {
            openShapeCanvasModalBtn.addEventListener('click', () => {
                setActiveModalModeButton('interactionModeNoneBtn'); // Set default mode on open
                const shapeCanvasModal = document.getElementById('shapeCanvasModal');
                const shapeDetailCanvas = document.getElementById('shapeDetailCanvas');
                const modalCanvasContainer = document.getElementById('modalCanvasContainer');
                const shapeCanvasModalTitle = document.getElementById('shapeCanvasModalTitle');
                const modalInfoContent = document.getElementById('modalInfoContent');

                if (!shapeCanvasModal) {
                    console.error('Shape Canvas Modal element not found on click!');
                    showToast('L·ªói: Kh√¥ng t√¨m th·∫•y modal canvas (click).', 'error');
                    return;
                }

                if (!selectedShapeId) {
                    showToast('Vui l√≤ng ch·ªçn m·ªôt shape ƒë·ªÉ ch·ªânh s·ª≠a.', 'warning');
                    return;
                }
                const shape = shapesData.find(s => s._internalId === selectedShapeId);
                if (!shape) {
                    showToast('Kh√¥ng t√¨m th·∫•y shape ƒë∆∞·ª£c ch·ªçn.', 'error');
                    currentEditingShapeInModal = null;
                    return;
                }
                currentEditingShapeInModal = shape; // L∆∞u shape ƒëang ƒë∆∞·ª£c focus

                const shapeIndex = shapesData.findIndex(s => s._internalId === shape._internalId);
                let shapeDisplayName = 'Unnamed Shape';
                if (shapeIndex !== -1) {
                    const identifiers = generateShapeIdentifiers(shapeIndex, 'Line'); // L·∫•y t√™n d·∫°ng 'L'
                    shapeDisplayName = identifiers.name;
                }

                console.log('Modal Open: Target title element:', shapeCanvasModalTitle);
                console.log('Modal Open: Current shape object:', shape);
                console.log('Modal Open: Shape name to display (from generateShapeIdentifiers):', shapeDisplayName);

                if (shapeCanvasModalTitle) {
                    shapeCanvasModalTitle.textContent = `Canvas Editor: ${shapeDisplayName}`;
                }
                console.log('[DebugModalOpen] About to show modal.');
                shapeCanvasModal.style.display = 'flex';
                console.log('[DebugModalOpen] Modal display set to flex.');

                if (shapeDetailCanvas && modalCanvasContainer) {
                    let shapeDetailCtx = shapeDetailCanvas.getContext('2d');
                    const containerWidth = modalCanvasContainer.clientWidth;
                    const containerHeight = modalCanvasContainer.clientHeight;
                    shapeDetailCanvas.width = containerWidth > 20 ? containerWidth - 20 : 200; 
                    shapeDetailCanvas.height = containerHeight > 20 ? containerHeight - 20 : 150;

                    currentModalViewMode = 'oxy'; // ƒê·∫∑t l·∫°i view m·∫∑c ƒë·ªãnh khi m·ªü modal
                    setActiveViewButton('viewOxyBtn'); // Highlight n√∫t m·∫∑c ƒë·ªãnh

                    // Reset tr·∫°ng th√°i t∆∞∆°ng t√°c khi m·ªü modal
                    currentModalInteractionMode = 'none';
                    temporaryNewPoints = []; // Kh·ªüi t·∫°o m·∫£ng ƒëi·ªÉm t·∫°m th·ªüi
                    // setActiveModalModeButton(null); // This was causing the issue, mode is already set.
                    if (shapeDetailCanvas) shapeDetailCanvas.style.cursor = 'default';

                    // N·∫°p c√°c ƒëi·ªÉm hi·ªán c√≥ c·ªßa shape v√†o temporaryNewPoints ƒë·ªÉ hi·ªÉn th·ªã
                    if (currentEditingShapeInModal && currentEditingShapeInModal.v) {
                        console.log('[OpenModal] Loading existing vertices into temporaryNewPoints. Original vertices:', JSON.stringify(currentEditingShapeInModal.v));
                        for (const vertexId in currentEditingShapeInModal.v) {
                            if (Object.hasOwnProperty.call(currentEditingShapeInModal.v, vertexId)) {
                                const vCoords = currentEditingShapeInModal.v[vertexId]; // [x, y, z]
                                if (Array.isArray(vCoords) && vCoords.length === 3) {
                                    temporaryNewPoints.push({ x: vCoords[0], y: vCoords[1], z: vCoords[2], originalId: vertexId }); // L∆∞u originalId ƒë·ªÉ c√≥ th·ªÉ x·ª≠ l√Ω sau n√†y
                                } else {
                                    console.warn(`[OpenModal] Vertex ${vertexId} has invalid format:`, vCoords);
                                }
                            }
                        }
                        console.log('[OpenModal] temporaryNewPoints after loading existing vertices:', JSON.stringify(temporaryNewPoints));
                        // TODO: C·∫ßn c∆° ch·∫ø ƒë·ªÉ ph√¢n bi·ªát ƒëi·ªÉm c≈© v√† ƒëi·ªÉm m·ªõi khi L∆ØU ƒë·ªÉ tr√°nh nh√¢n b·∫£n.
                        // Hi·ªán t·∫°i, h√†m saveAndCloseModal s·∫Ω coi t·∫•t c·∫£ ƒëi·ªÉm trong temporaryNewPoints l√† ƒëi·ªÉm m·ªõi.
                    }

                    calculateAndUpdateModalCanvasViewParams(); // Calculate PPU and origin

                    drawModalCanvas();
                } else {
                    if (!shapeDetailCanvas) console.error('shapeDetailCanvas not found');
                    if (!modalCanvasContainer) console.error('modalCanvasContainer not found');
                }

                if(modalInfoContent) {
                    modalInfoContent.innerHTML = `<h5>${shapeDisplayName}</h5>
                                        <p><strong>ID:</strong> ${shape._internalId}</p>
                                        <p><strong>Lo·∫°i:</strong> ${shape.type}</p>
                                        <p><strong>S·ªë ƒë·ªânh:</strong> ${shape.vertices && typeof shape.vertices === 'object' ? Object.keys(shape.vertices).length : 0}</p>
                                        <p><strong>S·ªë m·∫∑t:</strong> ${shape.faces && Array.isArray(shape.faces) ? shape.faces.length : 0}</p>
                                        <p><strong>S·ªë ƒë∆∞·ªùng:</strong> ${shape.lines && Array.isArray(shape.lines) ? shape.lines.length : 0}</p>
                                        <!-- Th√™m th√¥ng tin kh√°c n·∫øu c·∫ßn -->`;
                } else {
                    const modalInfoSection = document.getElementById('modalInfoSection');
                    if(modalInfoSection) modalInfoSection.innerHTML = '<p>L·ªói khi t·∫£i chi ti·∫øt shape.</p>';
                    else console.error('modalInfoContent and modalInfoSection not found');
                }
                if (modalClickedPointCoordsContainer) modalClickedPointCoordsContainer.style.display = 'none'; // ·∫®n input t·ªça ƒë·ªô
                if (modalPointXInput) modalPointXInput.value = '';
                if (modalPointYInput) modalPointYInput.value = '';
                if (modalPointZInput) modalPointZInput.value = '';
            });
        }

function calculateNiceGridStep(pixelsPerUnit, minPixelSpacing = 40, maxPixelSpacing = 100) {
    if (pixelsPerUnit <= 0) {
        return { worldStep: 1, pixelStep: PIXELS_PER_UNIT_DEFAULT }; // Fallback
    }

    const niceSteps = [0.001, 0.002, 0.005, 0.01, 0.02, 0.05, 0.1, 0.2, 0.25, 0.5, 1, 2, 2.5, 5, 10, 20, 25, 50, 100, 200, 250, 500, 1000];
    
    let bestWorldStep = 1;
    let bestPixelStep = pixelsPerUnit; 

    const targetPixelStep = (minPixelSpacing + maxPixelSpacing) / 2;
    let smallestDiff = Infinity;

    for (const worldStep of niceSteps) {
        const currentPixelStep = worldStep * pixelsPerUnit;
        if (currentPixelStep >= minPixelSpacing && currentPixelStep <= maxPixelSpacing) {
            const diff = Math.abs(currentPixelStep - targetPixelStep);
            if (diff < smallestDiff) {
                smallestDiff = diff;
                bestWorldStep = worldStep;
                bestPixelStep = currentPixelStep;
            }
        }
    }
    
    if (smallestDiff === Infinity) { // If no step fits the range, find the closest one
        for (const worldStep of niceSteps) {
            const currentPixelStep = worldStep * pixelsPerUnit;
            const diff = Math.abs(currentPixelStep - targetPixelStep);
            if (diff < smallestDiff) {
                smallestDiff = diff;
                bestWorldStep = worldStep;
                bestPixelStep = currentPixelStep;
            }
        }
    }
    
    // Ensure pixelStep is not too small, making grid lines indistinguishable
    if (bestPixelStep < 5 && pixelsPerUnit > 0) { 
        for (const worldStep of niceSteps) {
            if (worldStep * pixelsPerUnit > 5) { // Find first nice step that results in pixelStep > 5
                bestWorldStep = worldStep;
                bestPixelStep = worldStep * pixelsPerUnit;
                break;
            }
        }
        // If still too small (e.g., pixelsPerUnit is extremely small), fallback to a default pixelStep
        if (bestPixelStep < 5) {
             bestPixelStep = minPixelSpacing; // Or some other sensible default
             bestWorldStep = bestPixelStep / pixelsPerUnit;
        }
    }

    return { worldStep: bestWorldStep, pixelStep: bestPixelStep };
}

        function drawGridAndAxes(ctx, viewMode, canvasWidth, canvasHeight, originX, originY, pixelsPerUnit) {
            const axisColor = '#FF0000'; 
            const gridColor = '#CCCCCC'; 
            const textColor = '#000000'; 
            const lineWidthThin = 0.5;
            const lineWidthThick = 1;

            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // T√≠nh to√°n b∆∞·ªõc l∆∞·ªõi "ƒë·∫πp"
            const { worldStep: gridWorldStep, pixelStep: gridPixelStep } = calculateNiceGridStep(pixelsPerUnit);
            
            if (gridPixelStep <= 0) { 
                console.warn("[drawGridAndAxes] Invalid gridPixelStep:", gridPixelStep, "pixelsPerUnit:", pixelsPerUnit, "Falling back or skipping grid.");
                // Fallback: V·∫Ω tr·ª•c ch√≠nh n·∫øu pixelsPerUnit h·ª£p l·ªá
                if (pixelsPerUnit > 0) {
                    ctx.beginPath();
                    ctx.strokeStyle = axisColor;
                    ctx.lineWidth = lineWidthThick;
                    ctx.moveTo(0, originY);
                    ctx.lineTo(canvasWidth, originY);
                    ctx.moveTo(originX, 0);
                    ctx.lineTo(originX, canvasHeight);
                    ctx.stroke();
                    ctx.fillStyle = textColor;
                    ctx.fillText('0', originX + 10, originY + 10);
                }
                return;
            }

            // --- V·∫Ω L∆∞·ªõi ---
            ctx.beginPath();
            ctx.strokeStyle = gridColor;
            ctx.lineWidth = lineWidthThin;

            // L∆∞·ªõi d·ªçc (song song v·ªõi tr·ª•c Y c·ªßa canvas)
            let currentWorldValX = Math.ceil(((0 - originX) / pixelsPerUnit) / gridWorldStep) * gridWorldStep;
            let safetyCountX = 0;
            while (safetyCountX++ < (canvasWidth / gridPixelStep) + 5) { // Safety break
                const canvasX = originX + currentWorldValX * pixelsPerUnit;
                if (canvasX > canvasWidth + gridPixelStep) break;
                if (canvasX >= -gridPixelStep) { // Ch·ªâ v·∫Ω n·∫øu n√≥ g·∫ßn ho·∫∑c trong viewport
                    ctx.moveTo(canvasX, 0);
                    ctx.lineTo(canvasX, canvasHeight);
                }
                currentWorldValX += gridWorldStep;
            }

            // L∆∞·ªõi ngang (song song v·ªõi tr·ª•c X c·ªßa canvas)
            // worldY t·∫°i ƒë√°y canvas (pixel Y = canvasHeight) l√† ((originY - canvasHeight) / pixelsPerUnit)
            let currentWorldValY = Math.ceil(((originY - canvasHeight) / pixelsPerUnit) / gridWorldStep) * gridWorldStep;
            let safetyCountY = 0;
            while (safetyCountY++ < (canvasHeight / gridPixelStep) + 5) { // Safety break
                const canvasY = originY - currentWorldValY * pixelsPerUnit; // Tr·ª´ v√¨ Y th·∫ø gi·ªõi ng∆∞·ª£c Y canvas
                if (canvasY < -gridPixelStep) break;
                if (canvasY <= canvasHeight + gridPixelStep) { // Ch·ªâ v·∫Ω n·∫øu n√≥ g·∫ßn ho·∫∑c trong viewport
                    ctx.moveTo(0, canvasY);
                    ctx.lineTo(canvasWidth, canvasY);
                }
                currentWorldValY += gridWorldStep;
            }
            ctx.stroke();

            // --- V·∫Ω Tr·ª•c T·ªça ƒê·ªô --- (V·∫´n gi·ªØ nguy√™n, v√¨ tr·ª•c ch√≠nh l√† ƒë∆∞·ªùng t·∫°i originX, originY)
            ctx.beginPath();
            ctx.strokeStyle = axisColor;
            ctx.lineWidth = lineWidthThick;
            ctx.moveTo(0, originY); // Tr·ª•c X (ƒë∆∞·ªùng y = world 0)
            ctx.lineTo(canvasWidth, originY);
            ctx.moveTo(originX, 0); // Tr·ª•c Y (ƒë∆∞·ªùng x = world 0)
            ctx.lineTo(originX, canvasHeight);
            ctx.stroke();

            // --- V·∫Ω Nh√£n S·ªë tr√™n Tr·ª•c ---
            ctx.fillStyle = textColor;
            const labelOffset = 10;

            function formatLabel(value, step) {
                if (step >= 1) return String(Math.round(value));
                const stepStr = String(step);
                const decimalPlaces = stepStr.includes('.') ? stepStr.split('.')[1].length : 0;
                return value.toFixed(Math.min(2, decimalPlaces)); // Gi·ªõi h·∫°n t·ªëi ƒëa 2 ch·ªØ s·ªë th·∫≠p ph√¢n, ho·∫∑c theo step
            }

            // Nh√£n tr√™n tr·ª•c X (d·ªçc theo ƒë∆∞·ªùng y = originY)
            if (originY >= -labelOffset && originY <= canvasHeight + labelOffset) { // Ch·ªâ v·∫Ω n·∫øu tr·ª•c X ch√≠nh hi·ªÉn th·ªã
                currentWorldValX = Math.ceil(((0 - originX) / pixelsPerUnit) / gridWorldStep) * gridWorldStep;
                safetyCountX = 0;
                while (safetyCountX++ < (canvasWidth / gridPixelStep) + 5) {
                    const canvasX = originX + currentWorldValX * pixelsPerUnit;
                    if (canvasX > canvasWidth + gridPixelStep) break;
                    if (canvasX >= -gridPixelStep - labelOffset) { // Buffer cho label
                        if (Math.abs(currentWorldValX) > gridWorldStep * 0.0001 || Math.abs(currentWorldValX) === 0) { // V·∫Ω '0' n·∫øu l√† g·ªëc, ho·∫∑c c√°c s·ªë kh√°c
                           // Avoid drawing label '0' if originX itself is not on this tick
                           if (Math.abs(currentWorldValX) === 0 && Math.abs(originX - canvasX) > gridPixelStep * 0.1) {
                               // This is world 0, but originX (canvas projection of world 0) is not here, so don't label this tick as 0.
                           } else {
                               ctx.fillText(formatLabel(currentWorldValX, gridWorldStep), canvasX, originY + labelOffset);
                           }
                        }
                    }
                    currentWorldValX += gridWorldStep;
                }
            }

            // Nh√£n tr√™n tr·ª•c Y (d·ªçc theo ƒë∆∞·ªùng x = originX)
            if (originX >= -labelOffset && originX <= canvasWidth + labelOffset) { // Ch·ªâ v·∫Ω n·∫øu tr·ª•c Y ch√≠nh hi·ªÉn th·ªã
                currentWorldValY = Math.ceil(((originY - canvasHeight) / pixelsPerUnit) / gridWorldStep) * gridWorldStep;
                safetyCountY = 0;
                while (safetyCountY++ < (canvasHeight / gridPixelStep) + 5) {
                    const canvasY = originY - currentWorldValY * pixelsPerUnit;
                    if (canvasY < -gridPixelStep) break;
                    if (canvasY <= canvasHeight + gridPixelStep + labelOffset) { // Buffer cho label
                         if (Math.abs(currentWorldValY) > gridWorldStep * 0.0001 || Math.abs(currentWorldValY) === 0) {
                            if (Math.abs(currentWorldValY) === 0 && Math.abs(originY - canvasY) > gridPixelStep * 0.1) {
                                // World 0, but originY is not here.
                            } else {
                                ctx.fillText(formatLabel(currentWorldValY, gridWorldStep), originX + labelOffset, canvasY);
                            }
                        }
                    }
                    currentWorldValY += gridWorldStep;
                }
            }
            
            // Nh√£n g·ªëc t·ªça ƒë·ªô '0' - v·∫Ω m·ªôt c√°ch r√µ r√†ng n·∫øu g·ªëc (originX, originY) n·∫±m trong canvas
            // v√† ch∆∞a ƒë∆∞·ª£c v·∫Ω b·ªüi logic ·ªü tr√™n (tr∆∞·ªùng h·ª£p currentWorldValX/Y l√† 0)
            if (originX >= -labelOffset && originX <= canvasWidth + labelOffset && 
                originY >= -labelOffset && originY <= canvasHeight + labelOffset) {
                // Check if '0' label for X axis would have been drawn near originX
                let xZeroDrawn = false;
                if (originY >= -labelOffset && originY <= canvasHeight + labelOffset) {
                    if (Math.abs( (0 - originX) / pixelsPerUnit ) < gridWorldStep * 0.5) xZeroDrawn = true;
                }
                // Check if '0' label for Y axis would have been drawn near originY
                let yZeroDrawn = false;
                if (originX >= -labelOffset && originX <= canvasWidth + labelOffset) {
                     if (Math.abs( (originY - 0) / pixelsPerUnit ) < gridWorldStep * 0.5) yZeroDrawn = true;
                }
                // If origin is a grid intersection and labels for 0 on X and Y axes were already drawn, this specific '0' might be redundant
                // However, the logic above tries to draw 0 if currentWorldVal is 0.
                // This explicit '0' ensures it's there if origin itself is on screen.
                // The conditions in the loops above for currentWorldValX/Y === 0 should ideally handle it.
                // Let's simplify: if origin is on screen, draw '0'. The loops above might skip it if origin is not a grid line itself.
                 ctx.fillText('0', originX + labelOffset, originY + labelOffset);
            }

            // --- V·∫Ω t√™n tr·ª•c ---
            ctx.font = 'bold 12px Arial';
            let axisLabelX = 'X';
            let axisLabelY = 'Y';

            if (viewMode === 'oxy') { axisLabelX = 'X'; axisLabelY = 'Y'; }
            else if (viewMode === 'oxz') { axisLabelX = 'X'; axisLabelY = 'Z'; }
            else if (viewMode === 'oyz') { axisLabelX = 'Y'; axisLabelY = 'Z'; }

            ctx.fillText(axisLabelX, canvasWidth - 15, originY - 15);
            ctx.fillText(axisLabelY, originX + 15, 15);
        }

        // Helper function to get scaled mouse coordinates on canvas
function getScaledMouseCoordinatesOnCanvas(event, canvasElement) {
    if (!canvasElement) return { x: 0, y: 0 };
    const canvasRect = canvasElement.getBoundingClientRect();

    // Mouse coordinates relative to the canvas element's top-left corner
    const mouseX_relative_to_canvas_element = event.clientX - canvasRect.left;
    const mouseY_relative_to_canvas_element = event.clientY - canvasRect.top;

    // Adjust mouse coordinates if the canvas's display size is different from its drawing surface size
    const scaleX = canvasElement.width / canvasRect.width;
    const scaleY = canvasElement.height / canvasRect.height;

    const finalCanvasX = mouseX_relative_to_canvas_element * scaleX;
    const finalCanvasY = mouseY_relative_to_canvas_element * scaleY;

    return { x: finalCanvasX, y: finalCanvasY };
}

function drawModalCanvas() { 
            const canvas = document.getElementById('shapeDetailCanvas');
            if (!canvas) {
                console.error('drawModalCanvas: Canvas element #shapeDetailCanvas not found!');
                return;
            }
            const ctx = canvas.getContext('2d');
            if (!ctx) {
                console.error('drawModalCanvas: Failed to get 2D context from canvas.');
                return;
            }

            // If not in 'addPoint' mode AND no shape is being edited, then we can't draw meaningfully.
            // However, if in 'addPoint' mode, we might want to draw grid/crosshair even without a shape.
            if (currentModalInteractionMode !== 'addPoint' && !currentEditingShapeInModal) {
                console.warn('drawModalCanvas: currentEditingShapeInModal is null and not in addPoint mode. Cannot draw.');
                ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas if we are returning early
                return;
            }
            // If in 'addPoint' mode but no shape, we proceed, but some features depending on shape details might use defaults.
            console.log(`Attempting to draw modal canvas. View: ${currentModalViewMode}, Shape ID: ${currentEditingShapeInModal._internalId}, Canvas WxH: ${canvas.width}x${canvas.height}, PPU: ${PIXELS_PER_UNIT.toFixed(2)}, Origin: (${modalOriginX.toFixed(2)}, ${modalOriginY.toFixed(2)})`);
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            drawGridAndAxes(ctx, currentModalViewMode, canvas.width, canvas.height, modalOriginX, modalOriginY, PIXELS_PER_UNIT);
            drawTemporaryPoints(ctx, modalOriginX, modalOriginY, PIXELS_PER_UNIT, currentModalViewMode); 
            // TODO: G·ªçi drawShapeProjection(...) v·ªõi c√°c tham s·ªë t∆∞∆°ng t·ª±

            // Draw crosshair and coordinates if mouse is over canvas
            // Draw crosshair and coordinates if in 'addPoint' mode and mouse is over canvas
            // Now allows drawing even if currentEditingShapeInModal is null, using default Z/Y/X for the third dimension.
            if (showCrosshairAndCoords && currentModalInteractionMode === 'addPoint' && modalCanvasMouseX !== null && modalCanvasMouseY !== null && canvas) {
                console.log('[CrosshairDebug] Drawing crosshair and coords block. Mouse:', modalCanvasMouseX, modalCanvasMouseY, 'Mode:', currentModalInteractionMode, 'ShapeID:', currentEditingShapeInModal._internalId );
                ctx.save(); // Save context state
                ctx.strokeStyle = 'rgba(100, 100, 100, 0.7)';
                ctx.lineWidth = 0.5;
                ctx.fillStyle = 'black';
                ctx.font = '10px Arial';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'bottom';

                // Draw horizontal line (clipped to canvas)
                ctx.beginPath();
                ctx.moveTo(0, modalCanvasMouseY);
                ctx.lineTo(canvas.width, modalCanvasMouseY);
                ctx.stroke();

                // Draw vertical line (clipped to canvas)
                ctx.beginPath();
                ctx.moveTo(modalCanvasMouseX, 0);
                ctx.lineTo(modalCanvasMouseX, canvas.height);
                ctx.stroke();

                // Calculate world coordinates from modalCanvasMouseX/Y (which are canvas-relative)
                let worldDspX, worldDspY, worldDspZ; // Coordinates for display
                if (currentModalViewMode === 'oxy') {
                    worldDspX = (modalCanvasMouseX - modalOriginX) / PIXELS_PER_UNIT;
                    worldDspY = (modalOriginY - modalCanvasMouseY) / PIXELS_PER_UNIT;
                    worldDspZ = (currentEditingShapeInModal && currentEditingShapeInModal.vertices && Object.keys(currentEditingShapeInModal.vertices).length > 0) ? (currentEditingShapeInModal.vertices[Object.keys(currentEditingShapeInModal.vertices)[0]]?.z || 0) : 0;
                } else if (currentModalViewMode === 'oxz') {
                    worldDspX = (modalCanvasMouseX - modalOriginX) / PIXELS_PER_UNIT;
                    worldDspZ = (modalOriginY - modalCanvasMouseY) / PIXELS_PER_UNIT;
                    worldDspY = (currentEditingShapeInModal && currentEditingShapeInModal.vertices && Object.keys(currentEditingShapeInModal.vertices).length > 0) ? (currentEditingShapeInModal.vertices[Object.keys(currentEditingShapeInModal.vertices)[0]]?.y || 0) : 0;
                } else if (currentModalViewMode === 'oyz') {
                    worldDspY = (modalCanvasMouseX - modalOriginX) / PIXELS_PER_UNIT;
                    worldDspZ = (modalOriginY - modalCanvasMouseY) / PIXELS_PER_UNIT;
                    worldDspX = (currentEditingShapeInModal && currentEditingShapeInModal.vertices && Object.keys(currentEditingShapeInModal.vertices).length > 0) ? (currentEditingShapeInModal.vertices[Object.keys(currentEditingShapeInModal.vertices)[0]]?.x || 0) : 0;
                } else {
                    worldDspX = 0; worldDspY = 0; worldDspZ = 0;
                }

                const coordText = `(${worldDspX.toFixed(2)}, ${worldDspY.toFixed(2)}, ${worldDspZ.toFixed(2)})`;
                
                let textX = modalCanvasMouseX + 8;
                let textY = modalCanvasMouseY - 8;
                const textMetrics = ctx.measureText(coordText);
                const textWidth = textMetrics.width;
                const textHeight = 10; 

                if (textX + textWidth + 5 > canvas.width) textX = modalCanvasMouseX - textWidth - 8;
                if (textY - textHeight < 5) textY = modalCanvasMouseY + textHeight + 12; 
                if (textY + 5 > canvas.height) {
                    textY = modalCanvasMouseY - 8;
                    if (textY - textHeight < 5) textY = textHeight + 5;
                }

                console.log(`[CrosshairDebug] World Coords: (${worldDspX?.toFixed(2)}, ${worldDspY?.toFixed(2)}, ${worldDspZ?.toFixed(2)})`);
                console.log(`[CrosshairDebug] coordText: ${coordText}`);
                console.log(`[CrosshairDebug] Calculated text position before drawing: X=${textX}, Y=${textY}`);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.85)'; 
                ctx.fillRect(textX - 3, textY - textHeight - 3, textWidth + 6, textHeight + 6);
                ctx.fillStyle = 'black';
                ctx.fillText(coordText, textX, textY);
                ctx.restore();
            }
            console.log(`Finished drawing canvas for view: ${currentModalViewMode}`);
        }

        function drawTemporaryPoints(ctx, originX, originY, pixelsPerUnit, viewMode) {
            if (!temporaryNewPoints || temporaryNewPoints.length === 0) return;

            const canvas = document.getElementById('shapeDetailCanvas');
            if (!canvas) return;
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;

            ctx.fillStyle = 'blue'; // M√†u cho ƒëi·ªÉm t·∫°m th·ªüi
            ctx.strokeStyle = 'darkblue';
            ctx.lineWidth = 1;

            temporaryNewPoints.forEach(point3D => {
                let pX, pY;
                // Chuy·ªÉn ƒë·ªïi t·ª´ t·ªça ƒë·ªô 3D c·ªßa ƒëi·ªÉm t·∫°m th·ªüi sang 2D tr√™n canvas
                // d·ª±a tr√™n viewMode (tham s·ªë c·ªßa h√†m)
                if (viewMode === 'oxy') {
                    pX = originX + point3D.x * pixelsPerUnit;
                    pY = originY - point3D.y * pixelsPerUnit; // Y ng∆∞·ª£c l·∫°i tr√™n canvas
                } else if (viewMode === 'oxz') {
                    pX = originX + point3D.x * pixelsPerUnit;
                    pY = originY - point3D.z * pixelsPerUnit; // Z thay cho Y
                } else if (viewMode === 'oyz') {
                    pX = originX + point3D.y * pixelsPerUnit; // Y thay cho X
                    pY = originY - point3D.z * pixelsPerUnit; // Z thay cho Y
                } else {
                    console.warn(`drawTemporaryPoints: Unknown viewMode '${viewMode}' for point ${JSON.stringify(point3D)}`);
                    return; // B·ªè qua ƒëi·ªÉm n√†y n·∫øu viewMode kh√¥ng x√°c ƒë·ªãnh
                }

                // V·∫Ω ƒëi·ªÉm
                ctx.beginPath();
                ctx.arc(pX, pY, 5, 0, 2 * Math.PI); // V·∫Ω v√≤ng tr√≤n nh·ªè
                ctx.fill();
                ctx.stroke();

                // Hi·ªÉn th·ªã t·ªça ƒë·ªô b√™n c·∫°nh ƒëi·ªÉm (t·ªça ƒë·ªô th·∫ø gi·ªõi 3D)
                ctx.fillStyle = 'black';
                ctx.font = '10px Arial';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'bottom';
                let coordText = '';
                if (viewMode === 'oxy') coordText = `(${point3D.x.toFixed(1)}, ${point3D.y.toFixed(1)})`;
                else if (viewMode === 'oxz') coordText = `(${point3D.x.toFixed(1)}, ${point3D.z.toFixed(1)})`;
                else if (viewMode === 'oyz') coordText = `(${point3D.y.toFixed(1)}, ${point3D.z.toFixed(1)})`;
                    ctx.fillText(coordText, pX + 7, pY - 7);
                }); // End of temporaryNewPoints.forEach
        } // End of function drawTemporaryPoints

        function setActiveViewButton(activeButtonId) {
            const buttonIds = ['viewOxyBtn', 'viewOxzBtn', 'viewOyzBtn'];
            buttonIds.forEach(id => {
                const btn = document.getElementById(id);
                if (btn) {
                    btn.classList.remove('btn-primary');
                    btn.classList.add('btn-outline-secondary');
                }
            });
            const activeBtnElement = document.getElementById(activeButtonId);
            if (activeBtnElement) {
                activeBtnElement.classList.remove('btn-outline-secondary');
                activeBtnElement.classList.add('btn-primary');
            }
        }

        function updateCanvasCursor() {
            const canvas = document.getElementById('shapeDetailCanvas');
            if (!canvas) return;

            if (isPanningWithRightMouse) {
                canvas.style.cursor = 'grabbing';
            } else {
                switch (currentModalInteractionMode) {
                    case 'addPoint':
                        canvas.style.cursor = 'crosshair';
                        break;
                    case 'moveObject':
                        canvas.style.cursor = 'move';
                        break;
                    default: // 'none' or other
                        canvas.style.cursor = 'default';
                        break;
                }
            }
            // console.log('[CursorUpdate] Canvas cursor set to:', canvas.style.cursor, 'Mode:', currentModalInteractionMode, 'Panning:', isPanningWithRightMouse);
        }

        function setActiveModalModeButton(activeButtonId) {
            console.log('[Debug] setActiveModalModeButton called with ID:', activeButtonId);
            const buttonIds = ['interactionModeNoneBtn', 'interactionModeAddPointBtn', 'interactionModeMoveObjectBtn'];

            buttonIds.forEach(id => {
                const btn = document.getElementById(id);
                if (btn) {
                    btn.classList.remove('btn-success'); 
                    btn.classList.add('btn-outline-secondary');
                }
            });

            const activeButtonElement = document.getElementById(activeButtonId);
            if (activeButtonElement) {
                activeButtonElement.classList.remove('btn-outline-secondary');
                activeButtonElement.classList.add('btn-success');
            }

            if (activeButtonId === 'interactionModeAddPointBtn') {
                currentModalInteractionMode = 'addPoint';
            } else if (activeButtonId === 'interactionModeMoveObjectBtn') {
                currentModalInteractionMode = 'moveObject';
            } else { // Default to 'none' for interactionModeNoneBtn or any other case
                currentModalInteractionMode = 'none';
            }
            // updateCanvasCursor() will be called regardless of panning, 
            // but its behavior changes based on isPanningWithRightMouse and currentModalInteractionMode.
            // If panning, it should ideally ensure the cursor is 'grabbing'.
            // If not panning, it sets cursor based on interaction mode.
            updateCanvasCursor();

            if (!isPanningWithRightMouse && showCrosshairAndCoords) {
                drawModalCanvas(); // Redraw for crosshair if not panning
            }
            console.log('[ModalMode] Interaction mode set to:', currentModalInteractionMode);
        }

        // Event listeners for modal interaction mode buttons
        document.getElementById('interactionModeNoneBtn')?.addEventListener('click', () => setActiveModalModeButton('interactionModeNoneBtn'));
        document.getElementById('interactionModeAddPointBtn')?.addEventListener('click', () => {
            setActiveModalModeButton('interactionModeAddPointBtn');
            console.log('[Debug] currentModalInteractionMode after click on AddPointBtn:', currentModalInteractionMode);
        });
        document.getElementById('interactionModeMoveObjectBtn')?.addEventListener('click', () => setActiveModalModeButton('interactionModeMoveObjectBtn'));
        
        // Event listeners cho c√°c n√∫t View Control tr√™n Modal
        const viewOxyBtn = document.getElementById('viewOxyBtn');
        const viewOxzBtn = document.getElementById('viewOxzBtn');
        const viewOyzBtn = document.getElementById('viewOyzBtn');
        console.log('[ViewControlButtons] viewOxyBtn element:', viewOxyBtn);
        console.log('[ViewControlButtons] viewOxzBtn element:', viewOxzBtn);
        console.log('[ViewControlButtons] viewOyzBtn element:', viewOyzBtn);

        // Khai b√°o bi·∫øn cho c√°c element li√™n quan ƒë·∫øn vi·ªác th√™m ƒëi·ªÉm v√† th√¥ng b√°o
        const modalMessage = document.getElementById('modalMessage');
        const modalClickedPointCoordsContainer = document.getElementById('modalClickedPointCoordsContainer');
        const modalPointXInput = document.getElementById('modalPointX');
        const modalPointYInput = document.getElementById('modalPointY');
        const modalPointZInput = document.getElementById('modalPointZ');
        const modalAddBtn = document.getElementById('modalAddBtn'); // N√∫t "Th√™m ƒêi·ªÉm T·∫°m Th·ªùi"
        const modalSaveBtn = document.getElementById('saveModalBtn');

        if (modalAddBtn) {
            modalAddBtn.addEventListener('click', () => {
                console.log('[ModalEvent] "Th√™m ƒêi·ªÉm T·∫°m Th·ªùi" button clicked.');
                if (!currentEditingShapeInModal) {
                    showToast('L·ªói: Kh√¥ng c√≥ shape n√†o ƒëang ƒë∆∞·ª£c ch·ªçn ƒë·ªÉ th√™m ƒëi·ªÉm.', 'error');
                    if (modalMessage) modalMessage.textContent = 'L·ªói: Ch∆∞a ch·ªçn shape.';
                    return;
                }
                const x = parseFloat(modalPointXInput.value);
                const y = parseFloat(modalPointYInput.value);
                const z = parseFloat(modalPointZInput.value);

                if (isNaN(x) || isNaN(y) || isNaN(z)) {
                    showToast('Vui l√≤ng nh·∫≠p t·ªça ƒë·ªô h·ª£p l·ªá cho ƒëi·ªÉm.', 'warning');
                    if (modalMessage) modalMessage.textContent = 'T·ªça ƒë·ªô kh√¥ng h·ª£p l·ªá.';
                    return;
                }
                const newPoint = { x, y, z };
                temporaryNewPoints.push(newPoint);
                console.log('[ModalEvent] Added temporary point:', newPoint, 'Total temp points:', temporaryNewPoints.length);
                
                if (modalMessage) modalMessage.textContent = ''; // X√≥a th√¥ng b√°o c≈©
                if (modalMessage) modalMessage.textContent = `ƒê√£ th√™m: (${x.toFixed(2)}, ${y.toFixed(2)}, ${z.toFixed(2)}). T·ªïng ƒëi·ªÉm t·∫°m: ${temporaryNewPoints.length}`;
                
                drawModalCanvas(); // V·∫Ω l·∫°i canvas ƒë·ªÉ hi·ªÉn th·ªã ƒëi·ªÉm m·ªõi
            });
        }

        // Event listener cho vi·ªác click tr√™n canvas ƒë·ªÉ th√™m ƒëi·ªÉm
        const shapeDetailCanvasForClick = document.getElementById('shapeDetailCanvas');
        if (shapeDetailCanvasForClick) {
            shapeDetailCanvasForClick.addEventListener('click', (event) => {
                if (currentModalInteractionMode !== 'addPoint' || !currentEditingShapeInModal) return;

                const canvasRect = shapeDetailCanvasForClick.getBoundingClientRect();
                
                // T·ªça ƒë·ªô chu·ªôt g·ªëc so v·ªõi viewport
                // console.log(`[DebugOffset] Mouse Click: clientX=${event.clientX}, clientY=${event.clientY}`);
                // console.log(`[DebugOffset] Canvas Rect: left=${canvasRect.left}, top=${canvasRect.top}, width=${canvasRect.width}, height=${canvasRect.height}`);

                // T·ªça ƒë·ªô chu·ªôt so v·ªõi g√≥c tr√™n b√™n tr√°i c·ªßa ph·∫ßn t·ª≠ canvas
                let mouseX_relative_to_canvas_element = event.clientX - canvasRect.left;
                let mouseY_relative_to_canvas_element = event.clientY - canvasRect.top;

                // console.log(`[DebugOffset] Mouse relative to canvas element: x=${mouseX_relative_to_canvas_element}, y=${mouseY_relative_to_canvas_element}`);
                // console.log(`[DebugOffset] Canvas drawing surface size: width=${shapeDetailCanvasForClick.width}, height=${shapeDetailCanvasForClick.height}`);

                // ƒêi·ªÅu ch·ªânh t·ªça ƒë·ªô chu·ªôt n·∫øu k√≠ch th∆∞·ªõc hi·ªÉn th·ªã c·ªßa canvas kh√°c v·ªõi k√≠ch th∆∞·ªõc b·ªÅ m·∫∑t v·∫Ω
                // (v√≠ d·ª•: khi canvas ƒë∆∞·ª£c scale b·∫±ng CSS)
                const scaleX = shapeDetailCanvasForClick.width / canvasRect.width;
                const scaleY = shapeDetailCanvasForClick.height / canvasRect.height;
                
                const finalCanvasX = mouseX_relative_to_canvas_element * scaleX;
                const finalCanvasY = mouseY_relative_to_canvas_element * scaleY;

                // console.log(`[DebugOffset] Scaling factors: scaleX=${scaleX}, scaleY=${scaleY}`);
                // console.log(`[DebugOffset] Final scaled mouse coords on canvas: x=${finalCanvasX}, y=${finalCanvasY}`);

                // modalOriginX and modalOriginY are calculated in calculateAndUpdateModalCanvasViewParams
                // and represent the canvas coordinates of the world origin (0,0) for the current view.
                let point3D = { x: 0, y: 0, z: 0 };

                if (currentModalViewMode === 'oxy') {
                    point3D.x = (finalCanvasX - modalOriginX) / PIXELS_PER_UNIT;
                    point3D.y = (modalOriginY - finalCanvasY) / PIXELS_PER_UNIT; // modalOriginY already accounts for inverted Y
                    point3D.z = 0;
                } else if (currentModalViewMode === 'oxz') {
                    point3D.x = (finalCanvasX - modalOriginX) / PIXELS_PER_UNIT;
                    point3D.z = (modalOriginY - finalCanvasY) / PIXELS_PER_UNIT; // modalOriginY for Z in OXZ view
                    point3D.y = 0;
                } else if (currentModalViewMode === 'oyz') {
                    point3D.y = (finalCanvasX - modalOriginX) / PIXELS_PER_UNIT; // modalOriginX for Y in OYZ view (first coord)
                    point3D.z = (modalOriginY - finalCanvasY) / PIXELS_PER_UNIT; // modalOriginY for Z in OYZ view (second coord)
                    point3D.x = 0;
                }
                
                point3D.x = parseFloat(point3D.x.toFixed(2));
                point3D.y = parseFloat(point3D.y.toFixed(2));
                point3D.z = parseFloat(point3D.z.toFixed(2));

                // console.log(`[DebugOffset] World coords before PIXELS_PER_UNIT: x_raw=${(finalCanvasX - originCanvasX)}, y_raw=${(originCanvasY - finalCanvasY)} (for Oxy)`);
                console.log(`[AddPoint] Attempting to add point. Mode: ${currentModalViewMode}, FinalCanvasClick:(${finalCanvasX.toFixed(2)},${finalCanvasY.toFixed(2)}), PIXELS: ${PIXELS_PER_UNIT.toFixed(4)}`);
                console.log('[AddPoint] Calculated 3D point:', point3D);

                // Diagnostic: Convert back to canvas coordinates to check consistency
                let recalculatedCanvasX, recalculatedCanvasY;
                if (currentModalViewMode === 'oxy') {
                    recalculatedCanvasX = modalOriginX + point3D.x * PIXELS_PER_UNIT;
                    recalculatedCanvasY = modalOriginY - point3D.y * PIXELS_PER_UNIT;
                } else if (currentModalViewMode === 'oxz') {
                    recalculatedCanvasX = modalOriginX + point3D.x * PIXELS_PER_UNIT;
                    recalculatedCanvasY = modalOriginY - point3D.z * PIXELS_PER_UNIT;
                } else if (currentModalViewMode === 'oyz') {
                    recalculatedCanvasX = modalOriginX + point3D.y * PIXELS_PER_UNIT;
                    recalculatedCanvasY = modalOriginY - point3D.z * PIXELS_PER_UNIT;
                }
                console.log(`[CoordCheck] Original click (scaled): (${finalCanvasX.toFixed(2)}, ${finalCanvasY.toFixed(2)})`);
                console.log(`[CoordCheck] World point: (${point3D.x.toFixed(2)}, ${point3D.y.toFixed(2)}, ${point3D.z.toFixed(2)})`);
                console.log(`[CoordCheck] Recalculated canvas coords: (${recalculatedCanvasX.toFixed(2)}, ${recalculatedCanvasY.toFixed(2)})`);
                console.log(`[CoordCheck] modalOrigin: (${modalOriginX.toFixed(2)}, ${modalOriginY.toFixed(2)}), PPU: ${PIXELS_PER_UNIT.toFixed(4)}`);

                temporaryNewPoints.push(point3D);
                drawModalCanvas();
                selectedTemporaryPointIndex = temporaryNewPoints.length - 1;
                console.log(`[CanvasClick] Added temporary point: (${point3D.x}, ${point3D.y}, ${point3D.z}), view: ${currentModalViewMode}. Index: ${selectedTemporaryPointIndex}`);
                // drawTemporaryPoints(shapeCanvasCtx); // ƒê√£ ƒë∆∞·ª£c g·ªçi trong drawModalCanvas(), kh√¥ng c·∫ßn g·ªçi l·∫°i ·ªü ƒë√¢y

                // Hi·ªÉn th·ªã v√† ƒëi·ªÅn d·ªØ li·ªáu v√†o input t·ªça ƒë·ªô
                console.log('[CanvasClick] Attempting to show coordinate inputs. Current mode:', currentModalInteractionMode);
                console.log('[CanvasClick] modalClickedPointCoordsContainer exists:', !!modalClickedPointCoordsContainer);
                if (modalClickedPointCoordsContainer) {
                    modalClickedPointCoordsContainer.style.display = 'block';
                    // S·ª≠ d·ª•ng getComputedStyle ƒë·ªÉ ki·ªÉm tra style th·ª±c t·∫ø ƒë∆∞·ª£c √°p d·ª•ng
                    console.log('[CanvasClick] Set display to block. Computed display style:', window.getComputedStyle(modalClickedPointCoordsContainer).display);
                } else {
                    console.error('[CanvasClick] modalClickedPointCoordsContainer is null or undefined!');
                }

                if (modalPointXInput) modalPointXInput.value = point3D.x.toFixed(2);
                if (modalPointYInput) modalPointYInput.value = point3D.y.toFixed(2);
                if (modalPointZInput) modalPointZInput.value = point3D.z.toFixed(2);
                console.log('[CanvasClick] Populated input fields.');

                // G·∫Øn (ho·∫∑c c·∫≠p nh·∫≠t) event listeners
                [modalPointXInput, modalPointYInput, modalPointZInput].forEach(input => {
                    if (input) {
                        // G·ª° b·ªè listener c≈© ƒë·ªÉ tr√°nh b·ªã g·ªçi nhi·ªÅu l·∫ßn
                        input.removeEventListener('input', updateTemporaryPointFromInputs);
                        input.addEventListener('input', updateTemporaryPointFromInputs);
                    }
                });
            });
        }


        // Event listener for mouse move on modal canvas to update cursor
        const shapeDetailCanvasForCursorUpdate = document.getElementById('shapeDetailCanvas');
        if (shapeDetailCanvasForCursorUpdate) {
            shapeDetailCanvasForCursorUpdate.addEventListener('mousemove', (event) => {
                if (showCrosshairAndCoords) {
                    const coords = getScaledMouseCoordinatesOnCanvas(event, shapeDetailCanvasForCursorUpdate);
                    modalCanvasMouseX = coords.x;
                    modalCanvasMouseY = coords.y;
                } else {
                    modalCanvasMouseX = null;
                    modalCanvasMouseY = null;
                }

                if (!isPanningWithRightMouse) {
                    updateCanvasCursor(); // Update cursor based on mode if not panning
                    if (showCrosshairAndCoords && currentModalInteractionMode === 'addPoint') {
                        drawModalCanvas(); // Redraw for crosshair movement
                    }
                } else {
                    // Panning cursor is handled by global mousemove. 
                    // drawModalCanvas is also called by global mousemove during panning.
                    // We've updated modalCanvasMouseX/Y above, so the crosshair during pan will use it.
                    // No explicit call to updateCanvasCursor() or drawModalCanvas() here to avoid conflict/redundancy.
                }
            });

            shapeDetailCanvasForCursorUpdate.addEventListener('mouseleave', () => {
                if (showCrosshairAndCoords && currentModalInteractionMode === 'addPoint') {
                    modalCanvasMouseX = null;
                    modalCanvasMouseY = null;
                    drawModalCanvas(); // Redraw to remove crosshair
                }
            });
        }

// Event listener for mouse wheel zoom on modal canvas
const shapeDetailCanvasForZoom = document.getElementById('shapeDetailCanvas');
if (shapeDetailCanvasForZoom) {
    shapeDetailCanvasForZoom.addEventListener('wheel', (event) => {
        event.preventDefault(); // Prevent page scrolling

        if (!currentEditingShapeInModal) return;

        const { x: mouseX, y: mouseY } = getScaledMouseCoordinatesOnCanvas(event, shapeDetailCanvasForZoom);

        let worldPointBeforeZoomX_axis1, worldPointBeforeZoomY_axis2;

        // Determine world coordinates under mouse before zoom based on the current view mode
        // The first component (worldPointBeforeZoomX_axis1) always corresponds to the first axis of the view mode (X in Oxy/Oxz, Y in Oyz)
        // The second component (worldPointBeforeZoomY_axis2) always corresponds to the second axis of the view mode (Y in Oxy, Z in Oxz/Oyz)
        worldPointBeforeZoomX_axis1 = (mouseX - modalOriginX) / PIXELS_PER_UNIT;
        worldPointBeforeZoomY_axis2 = (modalOriginY - mouseY) / PIXELS_PER_UNIT; // modalOriginY handles canvas Y inversion

        const zoomFactor = event.deltaY < 0 ? 1.1 : 1 / 1.1; // Zoom in or out
        let newPixelsPerUnit = PIXELS_PER_UNIT * zoomFactor;

        const MIN_PPU_CLAMP = 0.001;
        const MAX_PPU_CLAMP = 500;
        newPixelsPerUnit = Math.max(MIN_PPU_CLAMP, Math.min(newPixelsPerUnit, MAX_PPU_CLAMP));
        
        if (Math.abs(newPixelsPerUnit - PIXELS_PER_UNIT) < 0.00001) {
            return; // No significant change in PPU (e.g., hit clamp limit)
        }

        // Update origins to keep the world point under mouse stationary
        modalOriginX = mouseX - worldPointBeforeZoomX_axis1 * newPixelsPerUnit;
        modalOriginY = mouseY + worldPointBeforeZoomY_axis2 * newPixelsPerUnit;

        PIXELS_PER_UNIT = newPixelsPerUnit;

        console.log(`[Zoom] PPU: ${PIXELS_PER_UNIT.toFixed(4)}, Origin: (${modalOriginX.toFixed(2)}, ${modalOriginY.toFixed(2)})`);
        drawModalCanvas();

        // Restore cursor after zoom if not panning
            updateCanvasCursor();
        }
    , { passive: false }); // passive: false to allow preventDefault
}

// --- Pan Functionality Start ---
if (shapeDetailCanvasForZoom) { // Reuse the canvas element from zoom logic
    // 1. Prevent context menu on right-click
    shapeDetailCanvasForZoom.addEventListener('contextmenu', (event) => {
        event.preventDefault();
    });

    // 2. Mousedown to initiate panning
    shapeDetailCanvasForZoom.addEventListener('mousedown', (event) => {
        if (event.button === 2) { // Right mouse button
            if (!currentEditingShapeInModal) return;
            isPanningWithRightMouse = true;
            const { x: mouseX, y: mouseY } = getScaledMouseCoordinatesOnCanvas(event, shapeDetailCanvasForZoom);
            lastPanX = mouseX;
            lastPanY = mouseY;
            shapeDetailCanvasForZoom.style.cursor = 'grabbing';
            // console.log('[Pan] Mousedown - Start Panning');
        }
    });
}

// 3. Mousemove on document to pan (listens on document to allow panning even if mouse leaves canvas)
document.addEventListener('mousemove', (event) => {
    if (isPanningWithRightMouse) {
        if (!currentEditingShapeInModal || !shapeDetailCanvasForZoom) { // Ensure canvas context still valid
            isPanningWithRightMouse = false;
            if(shapeDetailCanvasForZoom) shapeDetailCanvasForZoom.style.cursor = 'default';
            return;
        }
        const { x: currentMouseX, y: currentMouseY } = getScaledMouseCoordinatesOnCanvas(event, shapeDetailCanvasForZoom);
        
        const deltaX = currentMouseX - lastPanX;
        const deltaY = currentMouseY - lastPanY;

        modalOriginX += deltaX;
        modalOriginY += deltaY;

        lastPanX = currentMouseX;
        lastPanY = currentMouseY;

        // console.log(`[Pan] Mousemove - Delta: (${deltaX.toFixed(2)}, ${deltaY.toFixed(2)}), New Origin: (${modalOriginX.toFixed(2)}, ${modalOriginY.toFixed(2)})`);
            if (showCrosshairAndCoords && shapeDetailCanvasForZoom) { // shapeDetailCanvasForZoom is the modal canvas
                const rect = shapeDetailCanvasForZoom.getBoundingClientRect();
                // Update modalCanvasMouseX/Y based on the global event's clientX/Y
                // relative to the canvas, as the mouse might be outside the canvas while panning.
                modalCanvasMouseX = event.clientX - rect.left;
                modalCanvasMouseY = event.clientY - rect.top;
            }
            drawModalCanvas();
    }
});

// 4. Mouseup on document to stop panning
document.addEventListener('mouseup', (event) => {
    if (event.button === 2 && isPanningWithRightMouse) { // Right mouse button released
        isPanningWithRightMouse = false;
        if (shapeDetailCanvasForZoom) { // Check if canvas element exists
            updateCanvasCursor();
        }
        // console.log('[Pan] Mouseup - Stop Panning');
    }
});
// --- Pan Functionality End ---

        if (viewOxyBtn) {
            viewOxyBtn.addEventListener('click', () => {
                console.log('[ViewControl] viewOxyBtn clicked. Current shape:', currentEditingShapeInModal, 'Mode before change:', currentModalViewMode);
                if (!currentEditingShapeInModal) {
                    console.warn('[ViewControl] viewOxyBtn: No currentEditingShapeInModal. Aborting.');
                    return;
                }
                currentModalViewMode = 'oxy';
                console.log('[ViewControl] viewOxyBtn: Mode set to oxy. Calling setActiveViewButton and drawModalCanvas.');
                setActiveViewButton('viewOxyBtn');
                drawModalCanvas();
            });
        }
        if (viewOxzBtn) {
            viewOxzBtn.addEventListener('click', () => {
                console.log('[ViewControl] viewOxzBtn clicked. Current shape:', currentEditingShapeInModal, 'Mode before change:', currentModalViewMode);
                if (!currentEditingShapeInModal) {
                    console.warn('[ViewControl] viewOxzBtn: No currentEditingShapeInModal. Aborting.');
                    return;
                }
                currentModalViewMode = 'oxz';
                console.log('[ViewControl] viewOxzBtn: Mode set to oxz. Calling setActiveViewButton and drawModalCanvas.');
                setActiveViewButton('viewOxzBtn');
                drawModalCanvas();
            });
        }
        if (viewOyzBtn) {
            viewOyzBtn.addEventListener('click', () => {
                console.log('[ViewControl] viewOyzBtn clicked. Current shape:', currentEditingShapeInModal, 'Mode before change:', currentModalViewMode);
                if (!currentEditingShapeInModal) {
                    console.warn('[ViewControl] viewOyzBtn: No currentEditingShapeInModal. Aborting.');
                    return;
                }
                currentModalViewMode = 'oyz';
                console.log('[ViewControl] viewOyzBtn: Mode set to oyz. Calling setActiveViewButton and drawModalCanvas.');
                setActiveViewButton('viewOyzBtn');
                drawModalCanvas();
            });
        }

        window.addEventListener('keydown', (event) => {
            const shapeCanvasModal = document.getElementById('shapeCanvasModal');
            if (event.key === 'Escape' && shapeCanvasModal && shapeCanvasModal.style.display === 'flex') {
                closeShapeEditorModal();
            }
        });
    }); // ƒê√≥ng DOMContentLoaded listener
    </script>
    <!-- Fullscreen Shape Canvas Modal -->
    <div id="shapeCanvasModal" class="fullscreen-modal">
        <div class="modal-content-wrapper">
            <div class="modal-header-controls">
                 <h5 id="shapeCanvasModalTitle">Shape Canvas Editor</h5>
                 <div class="modal-header-button-groups" style="display: flex; gap: 15px; margin: 0 auto;">
                    <div class="btn-group btn-group-sm" role="group" aria-label="View Controls">
                        <button type="button" class="btn btn-outline-secondary" id="viewOxyBtn" title="Ch·∫ø ƒë·ªô xem Oxy">Oxy</button>
                        <button type="button" class="btn btn-outline-secondary" id="viewOxzBtn" title="Ch·∫ø ƒë·ªô xem Oxz">Oxz</button>
                        <button type="button" class="btn btn-outline-secondary" id="viewOyzBtn" title="Ch·∫ø ƒë·ªô xem Oyz">Oyz</button>
                    </div>
                    <div class="btn-group btn-group-sm" role="group" aria-label="Interaction Mode Controls">
                        <button type="button" class="btn btn-outline-secondary" id="interactionModeNoneBtn" title="Ch·∫ø ƒë·ªô ch·ªçn (Kh√¥ng l√†m g√¨)">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-cursor-fill" viewBox="0 0 16 16"> <path d="M14.082 2.182a.5.5 0 0 1 .103.557L8.528 15.467a.5.5 0 0 1-.917-.007L5.57 10.694.803 8.652a.5.5 0 0 1-.006-.916l12.728-5.657a.5.5 0 0 1 .556.103z"/> </svg>
                            Ch·ªçn
                        </button>
                        <button type="button" class="btn btn-outline-secondary" id="interactionModeAddPointBtn" title="Ch·∫ø ƒë·ªô th√™m ƒëi·ªÉm">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-crosshair" viewBox="0 0 16 16"> <path d="M8.5.5a.5.5 0 0 0-1 0v.518A7 7 0 0 0 1.018 7.5H.5a.5.5 0 0 0 0 1h.518A7 7 0 0 0 7.5 14.982v.518a.5.5 0 0 0 1 0v-.518A7 7 0 0 0 14.982 8.5h.518a.5.5 0 0 0 0-1h-.518A7 7 0 0 0 8.5 1.018V.5Zm-6.48 7A6 6 0 0 1 7.5 2.02v10.96A6 6 0 0 1 2.02 8Zm11.96 0A6 6 0 0 1 8.5 13.98V2.02A6 6 0 0 1 13.98 8Z"/> </svg>
                            Th√™m ƒêi·ªÉm
                        </button>
                        <button type="button" class="btn btn-outline-secondary" id="interactionModeMoveObjectBtn" title="Ch·∫ø ƒë·ªô di chuy·ªÉn ƒëi·ªÉm/ƒë·ªëi t∆∞·ª£ng">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-hand-index-thumb" viewBox="0 0 16 16"> <path d="M6.75 1a.75.75 0 0 1 .75.75V8a.5.5 0 0 0 1 0V5.467l.086-.004c.317-.012.637-.008.949.004.312.012.624.03.928.058.283.027.564.064.83.115.27.052.53.115.776.193.248.079.484.172.702.278l.028.014c.218.104.422.218.612.34.19.122.364.258.52.408.158.15.295.315.413.49.117.177.212.365.284.562.072.195.122.4.146.612.024.21.028.428.02.638a4.007 4.007 0 0 1-.12.967c-.065.26-.15.507-.253.739-.104.233-.222.453-.356.657-.133.205-.28.392-.44.561-.16.17-.334.32-.524.452-.19.132-.392.243-.606.331a5.03 5.03 0 0 1-.707.215c-.22.061-.448.106-.68.132-.233.026-.47.038-.708.038-.313 0-.614-.014-.91-.043l-.02-.002-.02-.002A1.5 1.5 0 0 1 8 12.5V8.865a.5.5 0 0 0-.5-.5H4.25a.75.75 0 0 1-.75-.75V1.75A.75.75 0 0 1 4.25 1h2.5ZM4.25 8.115H6.5V12h1.5a.5.5 0 0 0 .478-.356c.09-.22.19-.43.292-.626.102-.197.21-.388.322-.572.113-.184.23-.357.348-.518.12-.162.235-.312.342-.45.108-.138.206-.263.295-.375.09-.113.17-.215.24-.304.07-.09.128-.17.176-.238.048-.07.085-.127.11-.175.026-.048.04-.086.044-.114.005-.028.002-.047-.003-.057a.316.316 0 0 0-.06-.137c-.03-.044-.068-.08-.11-.11-.043-.03-.09-.054-.14-.073a.97.97 0 0 0-.188-.09c-.077-.027-.158-.048-.24-.062-.084-.014-.17-.023-.258-.028-.09-.005-.178-.007-.266-.007l-.035.001-.031.001c-.25-.006-.5-.002-.732.007l-.07.003-.026.001H7.5V1.75h-3.5v6.365Z"/> </svg>
                            Di Chuy·ªÉn ƒêi·ªÉm
                        </button>
                    </div>
                 </div>
                 <div class="btn-group btn-group-sm" role="group" aria-label="Save Cancel Controls">
                        <button type="button" class="btn btn-success" id="saveModalBtn" onclick="saveAndCloseModal()" title="L∆∞u thay ƒë·ªïi">L∆∞u</button>
                        <button type="button" class="btn btn-secondary" id="cancelModalBtn" onclick="closeShapeEditorModal()" title="H·ªßy b·ªè">H·ªßy</button>
                    </div>
            </div>
            <div class="modal-main-content">
                <div id="modalCanvasContainer" class="modal-canvas-section">
                    <canvas id="shapeDetailCanvas"></canvas>
                </div>
                <div id="modalInfoSection" class="modal-info-section">
                    <div id="modalInfoContent"> <!-- Div for dynamic content -->
                       <h4>Th√¥ng tin</h4>
                       <p>N·ªôi dung th√¥ng tin s·∫Ω ƒë∆∞·ª£c hi·ªÉn th·ªã ·ªü ƒë√¢y khi m·ªôt shape ƒë∆∞·ª£c ch·ªçn v√† modal ƒë∆∞·ª£c m·ªü.</p>
                       <div id="modalClickedPointCoordsContainer" style="display:none; margin-top: 10px;">
                           <h5>T·ªça ƒë·ªô ƒëi·ªÉm ƒëang ch·ªçn:</h5>
                           <div>
                               <label for="modalPointX" style="display: inline-block; width: 20px;">X:</label>
                               <input type="number" id="modalPointX" step="any" style="width: calc(100% - 30px); margin-bottom: 5px;">
                           </div>
                           <div>
                               <label for="modalPointY" style="display: inline-block; width: 20px;">Y:</label>
                               <input type="number" id="modalPointY" step="any" style="width: calc(100% - 30px); margin-bottom: 5px;">
                           </div>
                           <div>
                               <label for="modalPointZ" style="display: inline-block; width: 20px;">Z:</label>
                               <input type="number" id="modalPointZ" step="any" style="width: calc(100% - 30px);">
                           </div>
                       </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</body>

</html>