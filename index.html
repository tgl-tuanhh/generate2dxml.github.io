<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kitect 3D JSON Studio</title>
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            /* NgƒÉn cu·ªôn ·ªü body */
        }

        header {
            background-color: #333;
            color: white;
            padding: 10px 20px;
            text-align: center;
            position: relative;
            /* ƒê·∫£m b·∫£o absolute positioning c·ªßa children l√† relative to header */
            display: flex;
            /* S·ª≠ d·ª•ng Flexbox */
            justify-content: space-between;
            /* CƒÉn ƒë·ªÅu c√°c nh√≥m controls */
            align-items: center;
            /* CƒÉn gi·ªØa theo chi·ªÅu d·ªçc */
        }

        header button,
        header .btn {
            /* Target Bootstrap buttons in header too */
            /* Style chung cho c√°c button trong header */
            padding: 0.25rem 0.5rem;
            /* ƒêi·ªÅu ch·ªânh padding ƒë·ªÉ gi·∫£m chi·ªÅu cao */
            /* background-color: #007bff; */
            /* Bootstrap handles this */
            font-size: 0.9em;
            /* color: white; */
            /* Bootstrap handles this */
            /* border: none; */
            /* Bootstrap handles this */
            border-radius: 3px;
            cursor: pointer;
            margin-left: 5px;
            /* Kho·∫£ng c√°ch gi·ªØa c√°c button trong c√πng m·ªôt nh√≥m */
        }

        #importJsonBtn {
            white-space: nowrap;
        }

        #uploadJsonBtn {
            white-space: nowrap;
        }

        /* header button:hover {
            background-color: #0056b3;
        } */
        /* Bootstrap handles this */

        .header-controls-group {
            display: flex;
            /* Cho ph√©p c√°c button trong nh√≥m n·∫±m tr√™n m·ªôt h√†ng */
            align-items: center;
        }

        /* C√≥ th·ªÉ th√™m style c·ª• th·ªÉ cho input-controls v√† output-controls n·∫øu c·∫ßn */
        #create2DXmlBtn {
            background-color: red;
            /* Keep this specific style if needed */
        }

        .main-container {
            display: flex;
            flex-grow: 1;
            overflow: hidden;
            /* Cho ph√©p c√°c panel con cu·ªôn */
            padding: 10px;
            gap: 10px;
        }

        .panel {
            background-color: white;
            border-radius: 5px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.1);
            padding: 15px;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            /* Cho ph√©p cu·ªôn n·ªôi dung panel */
        }

        #shapes-panel {
            flex: 0 0 250px;
            /* ƒê·ªô r·ªông c·ªë ƒë·ªãnh cho panel shapes */
        }

        #editor-panel {
            flex-grow: 1;
            /* Panel editor chi·∫øm ph·∫ßn c√≤n l·∫°i */
        }

        #viewer-3d-panel {
            flex-grow: 2;
            /* Cho panel 3D chi·∫øm nhi·ªÅu kh√¥ng gian h∆°n */
            min-width: 300px;
            /* ƒê·∫£m b·∫£o c√≥ kh√¥ng gian t·ªëi thi·ªÉu cho view 3D */
            position: relative;
            /* ƒê·ªÉ canvas c√≥ th·ªÉ ƒë∆∞·ª£c ƒë·ªãnh v·ªã tuy·ªát ƒë·ªëi b√™n trong */
        }

        #viewer-3d-panel canvas {
            display: block;
            /* Lo·∫°i b·ªè kho·∫£ng tr·∫Øng th·ª´a b√™n d∆∞·ªõi canvas */
            width: 100% !important;
            /* Ghi ƒë√® style m·∫∑c ƒë·ªãnh c·ªßa three.js n·∫øu c√≥ */
            height: 100% !important;
        }

        textarea {
            width: calc(100% - 10px);
            /* ƒêi·ªÅu ch·ªânh ƒë·ªÉ padding kh√¥ng l√†m v·ª° layout */
            flex-grow: 1;
            margin-top: 10px;
            border: 1px solid #ccc;
            border-radius: 3px;
            padding: 5px;
            font-family: monospace;
            resize: none;
            /* Kh√¥ng cho ph√©p resize textarea */
        }

        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 3px;
            cursor: pointer;
            margin-top: 5px;
            margin-bottom: 10px;
        }

        button:hover {
            background-color: #0056b3;
        }

        .shape-item {
            padding: 8px;
            border: 1px solid #eee;
            border-radius: 3px;
            margin-bottom: 5px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .shape-item:hover,
        .shape-item.selected {
            background-color: #e9ecef;
        }

        .shape-item button {
            background-color: #dc3545;
            padding: 3px 6px;
            font-size: 0.8em;
            margin: 0;
        }

        .shape-item button:hover {
            background-color: #c82333;
        }

        .section {
            margin-bottom: 15px;
            border: 1px solid #ddd;
            padding: 10px;
            border-radius: 3px;
        }

        .section h3 {
            margin-top: 0;
            font-size: 1.1em;
            color: #333;
        }

        label {
            display: block;
            margin-bottom: 3px;
            font-size: 0.9em;
            color: #555;
        }

        input[type="text"],
        input[type="number"] {
            width: calc(100% - 12px);
            /* width - padding */
            padding: 5px;
            margin-bottom: 8px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }

        .vertex-entry,
        .face-entry,
        .line-entry {
            display: flex;
            gap: 5px;
            align-items: center;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        .vertex-entry input[type="number"] {
            width: 50px;
        }

        .face-entry input[type="text"] {
            flex-grow: 1;
        }

        .vertex-list,
        .face-list,
        .line-list {
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid #eee;
            padding: 5px;
            margin-bottom: 10px;
        }

        .hidden {
            display: none;
        }

        /* Toast Styling */
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1050;
            /* Ensure toast is above other elements, including modals (Bootstrap modal z-index is 1040/1050) */
        }
        /* Styles for Shape Canvas Modal */
        .fullscreen-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 1060; /* Ensure it's above Bootstrap modals (1050) */
            display: none; /* Hidden by default */
            align-items: center;
            justify-content: center;
        }
        .modal-content-wrapper {
            background-color: #fff;
            width: 98%;
            height: 98%;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,.5);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .modal-header-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem;
            border-bottom: 1px solid #dee2e6;
        }
        .modal-header-controls h5 {
            margin-bottom: 0;
        }
        .modal-main-content {
            display: flex;
            flex-grow: 1;
            height: calc(100% - 70px); /* Adjust based on header height + padding */
            overflow: hidden; /* Prevent scrollbars on this container */
        }
        .modal-canvas-section {
            flex: 3;
            padding: 1rem;
            border-right: 1px solid #dee2e6;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden; /* Canvas itself might scroll if larger than container */
            background-color: #f8f9fa; /* Light background for canvas area */
        }
        #shapeDetailCanvas {
            max-width: 100%;
            max-height: 100%;
            border: 1px solid #ced4da;
            background-color: white;
        }
        .modal-info-section {
            flex: 1;
            padding: 1rem;
            overflow-y: auto;
            background-color: #fff;
        }
        .modal-info-section h5 {
            margin-top: 0;
            margin-bottom: 0.75rem;
        }
        .modal-info-section p {
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }
    </style>
</head>

<body>
    <header>
        <h1>Kitect 3D JSON Studio</h1>
        <div class="header-controls-group input-controls">
            <input type="text" id="objectNameInput" class="form-control form-control-sm mr-2"
                placeholder="Nh·∫≠p Object Name (v√≠ d·ª•: PFHP-PILLAR-B)" value="OBJECT-NAME">
            <button id="importJsonBtn" class="btn btn-primary btn-sm">ƒê·ªçc Clipboard</button>
            <input type="file" id="uploadJsonFile" accept=".json" style="display: none;">
            <button id="uploadJsonBtn" class="btn btn-secondary btn-sm ml-2">Upload File</button>
        </div>
        <div class="header-controls-group main-actions">
            <button id="openOptionsModalBtn" class="btn btn-info btn-sm mr-2" data-toggle="modal"
                data-target="#optionsModal">T√πy ch·ªçn & Sao ch√©p</button>
            <button id="create2DXmlBtn" class="btn btn-danger btn-sm"
                onclick="window.open('./generate-2d-xml.html', '_blank')">Create 2D XML</button>
        </div>
    </header>
    <div class="main-container">
        <div id="shapes-panel" class="panel">
            <h2>Shapes</h2>
            <button id="addShapeBtn">Th√™m Shape M·ªõi</button>
            <div id="shapesListContainer">
                <!-- Danh s√°ch shapes s·∫Ω ƒë∆∞·ª£c th√™m v√†o ƒë√¢y b·∫±ng JavaScript -->
            </div>
            <div id="noShapeSelectedMsg">
                <p>Vui l√≤ng ch·ªçn m·ªôt shape t·ª´ danh s√°ch ho·∫∑c th√™m shape m·ªõi ƒë·ªÉ b·∫Øt ƒë·∫ßu ch·ªânh s·ª≠a.</p>
            </div>
        </div>

        <div id="editor-panel" class="panel">
            <h2 style="display: flex; align-items: center; justify-content: space-between;"><span>Editor</span><button id="openShapeCanvasModalBtn" class="btn btn-sm btn-light ml-2" style="display: none; padding: 2px 6px; line-height: 1;" title="M·ªü tr√¨nh ch·ªânh s·ª≠a canvas"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-pencil-square" viewBox="0 0 16 16"><path d="M15.502 1.94a.5.5 0 0 1 0 .706L14.459 3.69l-2-2L13.502.646a.5.5 0 0 1 .707 0l1.293 1.293zm-1.75 2.456-2-2L4.939 9.21a.5.5 0 0 0-.121.196l-.805 2.414a.25.25 0 0 0 .316.316l2.414-.805a.5.5 0 0 0 .196-.12l6.813-6.813z"/><path fill-rule="evenodd" d="M1 13.5A1.5 1.5 0 0 0 2.5 15h11a1.5 1.5 0 0 0 1.5-1.5v-6a.5.5 0 0 0-1 0v6a.5.5 0 0 1-.5.5h-11a.5.5 0 0 1-.5-.5v-11a.5.5 0 0 1 .5-.5H9a.5.5 0 0 0 0-1H2.5A1.5 1.5 0 0 0 1 2.5z"/></svg></button></h2>
            <div id="shapeEditorContainer" class="hidden">
                <div class="section">
                    <h3>Th√¥ng tin Shape</h3>
                    <p><strong>T√™n Shape (Line Mode):</strong> <span id="generatedShapeNameLine"></span></p>
                    <p><strong>T√™n Shape (Std Mode):</strong> <span id="generatedShapeNameStd"></span></p>

                    <label for="stdMaterialInput">Std Material:</label>
                    <input type="text" id="stdMaterialInput" placeholder="V√≠ d·ª•: R110-0">

                    <h4>Deform Types</h4>
                    <div style="margin-bottom: 10px;">
                        <label style="display: inline-block; margin-right: 10px;">
                            <input type="checkbox" id="deformStretch2Checkbox"> Stretch2
                        </label>
                        <label style="display: inline-block;">
                            <input type="checkbox" id="deformClippingCheckbox"> Clipping
                        </label>
                    </div>
                    <div style="margin-bottom: 10px; font-size: 0.9em; color: #333;">
                        <strong>Current Deform Types:</strong> <span id="currentDeformTypesText"></span>
                    </div>

                    <h4>Custom Pivot (T·ªça ƒë·ªô Local c·ªßa Shape)</h4>
                    <div style="display: flex; gap: 5px; margin-bottom: 10px;">
                        <div style="flex: 1;">
                            <label for="pivotX">Pivot X:</label>
                            <input type="number" id="pivotX" value="0" step="1">
                        </div>
                        <div style="flex: 1;">
                            <label for="pivotY">Pivot Y:</label>
                            <input type="number" id="pivotY" value="0" step="1">
                        </div>
                        <div style="flex: 1;">
                            <label for="pivotZ">Pivot Z:</label>
                            <input type="number" id="pivotZ" value="0" step="1">
                        </div>
                    </div>
                </div>

                <div class="section">
                    <h3>Vertices (v)</h3>
                    <button id="addVertexBtn">Th√™m Vertex</button>
                    <div class="vertex-list" id="verticesList">
                        <!-- Vertices s·∫Ω ƒë∆∞·ª£c th√™m v√†o ƒë√¢y -->
                    </div>
                </div>

                <div class="section">
                    <h3>Faces</h3>
                    <label for="faceVertices">Vertices (ch·ªâ s·ªë, c√°ch nhau b·ªüi d·∫•u ph·∫©y):</label>
                    <input type="text" id="faceVertices" placeholder="V√≠ d·ª•: 0,1,13,12">
                    <button id="addFaceBtn">Th√™m Face</button>
                    <div class="face-list" id="facesListContainer">
                        <!-- Faces s·∫Ω ƒë∆∞·ª£c th√™m v√†o ƒë√¢y -->
                    </div>
                </div>

                <div class="section">
                    <h3>Lines</h3>
                    <label for="lineVerticesInput">Vertices (ID ƒë·ªânh 1, ID ƒë·ªânh 2, c√°ch nhau b·ªüi d·∫•u ph·∫©y):</label>
                    <input type="text" id="lineVerticesInput" placeholder="V√≠ d·ª•: 0,1">
                    <button id="addLineBtn">Th√™m Line</button>
                    <div class="line-list" id="linesListContainer">
                        <!-- Lines s·∫Ω ƒë∆∞·ª£c th√™m v√†o ƒë√¢y -->
                    </div>
                </div>

                <div class="section" id="transformationsSection">
                    <h3>Ph√©p bi·∫øn ƒë·ªïi (Transformations)</h3>

                    <div class="subsection">
                        <h4>T·ªãnh ti·∫øn (Translate)</h4>
                        <label for="translateX">Delta X:</label>
                        <input type="number" id="translateX" value="0" step="1">
                        <label for="translateY">Delta Y:</label>
                        <input type="number" id="translateY" value="0" step="1">
                        <label for="translateZ">Delta Z:</label>
                        <input type="number" id="translateZ" value="0" step="1">
                        <button id="applyTranslateBtn">√Åp d·ª•ng T·ªãnh ti·∫øn</button>
                    </div>

                    <div class="subsection">
                        <h4>Xoay quanh t√¢m Shape (Rotate around Shape Center)</h4>
                        <p style="font-size:0.8em; color:#555;">ƒê∆°n v·ªã: ƒê·ªô. Th·ª© t·ª± xoay: X -> Y -> Z.</p>
                        <label for="rotateX">G√≥c X:</label>
                        <input type="number" id="rotateX" value="0" step="1">
                        <label for="rotateY">G√≥c Y:</label>
                        <input type="number" id="rotateY" value="0" step="1">
                        <label for="rotateZ">G√≥c Z:</label>
                        <input type="number" id="rotateZ" value="0" step="1">
                        <button id="applyRotateBtn">√Åp d·ª•ng Xoay</button>
                    </div>

                    <div class="subsection">
                        <h4>L·∫≠t qua t√¢m Shape (Flip around Shape Center)</h4>
                        <button id="flipXBtn">L·∫≠t qua tr·ª•c X (YZ plane)</button>
                        <button id="flipYBtn">L·∫≠t qua tr·ª•c Y (XZ plane)</button>
                        <button id="flipZBtn">L·∫≠t qua tr·ª•c Z (XY plane)</button>
                    </div>
                </div>

            </div>
        </div>

        <div id="viewer-3d-panel" class="panel">
            <h2>3D View</h2>
            <div id="threejs-canvas-container" style="width: 100%; height: calc(100% - 40px);">
                <!-- Canvas cho Three.js s·∫Ω ƒë∆∞·ª£c th√™m v√†o ƒë√¢y -->
            </div>
        </div>
    </div>

    <!-- Toast Container -->
    <div aria-live="polite" aria-atomic="true" class="toast-container">
        <!-- Toasts will be appended here -->
    </div>

    <!-- Options Modal -->
    <div class="modal fade" id="optionsModal" tabindex="-1" aria-labelledby="optionsModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="optionsModalLabel">T√πy ch·ªçn & Sao ch√©p</h5>
                    <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                        <span aria-hidden="true">&times;</span>
                    </button>
                </div>
                <div class="modal-body">
                    <div class="container-fluid">
                        <div class="row">
                            <div class="col-md-6">
                                <h5>Sao ch√©p D·ªØ li·ªáu</h5>
                                <button id="copyLineGeometryBtn" class="btn btn-outline-primary btn-block mb-2">Copy
                                    Line Geometry</button>
                                <button id="copyStdGeometryBtn" class="btn btn-outline-primary btn-block mb-2">Copy Std
                                    Geometry</button>
                                <button id="copyLineMeshBtn" class="btn btn-outline-success btn-block mb-2">Copy Line
                                    Mesh</button>
                                <button id="copyStdMeshBtn" class="btn btn-outline-success btn-block mb-2">Copy Std
                                    Mesh</button>
                            </div>
                            <div class="col-md-6">
                                <h5>C√†i ƒë·∫∑t M·∫∑c ƒë·ªãnh cho Shape</h5>
                                <div class="form-group">
                                    <label for="defaultStdMaterialInput">Default Std Material:</label>
                                    <input type="text" id="defaultStdMaterialInput" class="form-control form-control-sm"
                                        placeholder="V√≠ d·ª•: R110-0">
                                </div>
                                <div class="form-group">
                                    <label>Default Deform Types:</label>
                                    <div class="form-check">
                                        <input class="form-check-input" type="checkbox"
                                            id="defaultDeformStretch2Checkbox"> <!-- B·ªè checked m·∫∑c ƒë·ªãnh -->
                                        <label class="form-check-label"
                                            for="defaultDeformStretch2Checkbox">Stretch2</label>
                                    </div>
                                    <div class="form-check">
                                        <input class="form-check-input" type="checkbox"
                                            id="defaultDeformClippingCheckbox">
                                        <label class="form-check-label"
                                            for="defaultDeformClippingCheckbox">Clipping</label>
                                    </div>
                                </div>
                                <button id="applyDefaultsBtn" class="btn btn-warning btn-block mt-3">√Åp d·ª•ng cho t·∫•t c·∫£
                                    Shapes hi·ªán t·∫°i</button>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-dismiss="modal">ƒê√≥ng</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.9.2/dist/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/lines/LineSegmentsGeometry.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/lines/LineMaterial.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/lines/LineSegments2.js"></script>
    <script>
        // Bi·∫øn to√†n c·ª•c cho modal canvas view
        let currentModalViewMode = 'oxy'; // M·∫∑c ƒë·ªãnh l√† Oxy
        const PIXELS_PER_UNIT = 20;
        const GRID_COLOR = '#cccccc';

        // Bi·∫øn to√†n c·ª•c cho ch·∫ø ƒë·ªô t∆∞∆°ng t√°c trong modal canvas
        let currentModalInteractionMode = 'none'; // 'none', 'addPoint', 'moveObject', etc.
        let temporaryNewPoints = []; // M·∫£ng l∆∞u c√°c ƒëi·ªÉm m·ªõi ƒë∆∞·ª£c click tr√™n canvas modal
        let selectedTemporaryPointIndex = -1; // Index c·ªßa ƒëi·ªÉm t·∫°m th·ªùi ƒëang ƒë∆∞·ª£c ch·ªânh s·ª≠a t·ªça ƒë·ªô
        const AXIS_COLOR = '#333333';
        const TEXT_COLOR = '#000000';
        // State c·ªßa ·ª©ng d·ª•ng
        let shapesData = [];
        let selectedShapeId = null;
        let currentJsonString = ''; // L∆∞u tr·ªØ chu·ªói JSON hi·ªán t·∫°i (ch·ªß y·∫øu cho Line Geometry v√† 3D view)
        let currentObjectName = 'OBJECT-NAME'; // L∆∞u tr·ªØ Object Name, kh·ªüi t·∫°o v·ªõi gi√° tr·ªã m·∫∑c ƒë·ªãnh

        // DOM Elements
        const addShapeBtn = document.getElementById('addShapeBtn');
        const shapesListContainer = document.getElementById('shapesListContainer');
        const importJsonBtn = document.getElementById('importJsonBtn');
        const copyLineGeometryBtn = document.getElementById('copyLineGeometryBtn');
        const copyStdGeometryBtn = document.getElementById('copyStdGeometryBtn');
        const copyLineMeshBtn = document.getElementById('copyLineMeshBtn');
        const copyStdMeshBtn = document.getElementById('copyStdMeshBtn');
        const objectNameInput = document.getElementById('objectNameInput');
        const uploadJsonBtn = document.getElementById('uploadJsonBtn');
        const uploadJsonFile = document.getElementById('uploadJsonFile');

        const shapeEditorContainer = document.getElementById('shapeEditorContainer');
        const noShapeSelectedMsg = document.getElementById('noShapeSelectedMsg');
        const generatedShapeNameLine = document.getElementById('generatedShapeNameLine');
        const generatedShapeNameStd = document.getElementById('generatedShapeNameStd');
        const stdMaterialInput = document.getElementById('stdMaterialInput');

        const addVertexBtn = document.getElementById('addVertexBtn');
        const verticesListContainer = document.getElementById('verticesList');

        const addFaceBtn = document.getElementById('addFaceBtn');
        const faceVerticesInput = document.getElementById('faceVertices');
        const facesListContainer = document.getElementById('facesListContainer');

        const addLineBtn = document.getElementById('addLineBtn');
        const lineVerticesInput = document.getElementById('lineVerticesInput');
        const linesListContainer = document.getElementById('linesListContainer');

        // Transformation UI Elements
        const translateXInput = document.getElementById('translateX');
        const translateYInput = document.getElementById('translateY');
        const translateZInput = document.getElementById('translateZ');
        const applyTranslateBtn = document.getElementById('applyTranslateBtn');
        const rotateXInput = document.getElementById('rotateX');
        const rotateYInput = document.getElementById('rotateY');
        const rotateZInput = document.getElementById('rotateZ');
        const applyRotateBtn = document.getElementById('applyRotateBtn');
        const flipXBtn = document.getElementById('flipXBtn');
        const flipYBtn = document.getElementById('flipYBtn');
        const flipZBtn = document.getElementById('flipZBtn');

        const currentDeformTypesText = document.getElementById('currentDeformTypesText');

        const threeJsCanvasContainer = document.getElementById('threejs-canvas-container');

        // Three.js specific variables
        let scene, camera, renderer, controls, shapesGroup;
        let vertexLabelsGroup; // Group cho c√°c nh√£n ID ƒë·ªânh
        let threeShapeObjects = {}; // Map t·ª´ shape._internalId sang { group, lineMaterial, faceMaterial, labelMaterial }

        // Materials for highlighting
        const NORMAL_LINE_COLOR = 0x0000ff;
        const HIGHLIGHTED_LINE_COLOR = 0x007bff; // Changed to Blue
        const NORMAL_FACE_COLOR = 0xcccccc;
        const HIGHLIGHTED_FACE_COLOR = 0xffd700; // Gold
        const NORMAL_LABEL_BG_COLOR = { r: 50, g: 50, b: 50, a: 0.7 };
        const HIGHLIGHTED_LABEL_BG_COLOR = { r: 255, g: 165, b: 0, a: 0.9 }; // Orange background for labels

        // Th√™m l·∫°i c√°c khai b√°o bi·∫øn b·ªã thi·∫øu
        const deformStretch2Checkbox = document.getElementById('deformStretch2Checkbox');
        const deformClippingCheckbox = document.getElementById('deformClippingCheckbox'); // ID n√†y ƒë√£ ƒë∆∞·ª£c ƒë·ªïi t·ª´ deformClipCheckbox
        const pivotXInput = document.getElementById('pivotX');
        const pivotYInput = document.getElementById('pivotY');
        const pivotZInput = document.getElementById('pivotZ');

        const defaultStdMaterialInput = document.getElementById('defaultStdMaterialInput');
        const defaultDeformStretch2Checkbox = document.getElementById('defaultDeformStretch2Checkbox');
        const defaultDeformClippingCheckbox = document.getElementById('defaultDeformClippingCheckbox');
        const applyDefaultsBtn = document.getElementById('applyDefaultsBtn');

        // Raycaster for picking objects
        let raycaster;
        let mouse;

        // --- Helper function to create text sprites (moved to a more global scope) ---
        function createTextSprite(message, parameters) {
            parameters = parameters || {};
            const fontface = parameters.fontface || 'Arial';
            const internalFontsize = parameters.internalFontsize || 32; // Fontsize v·∫Ω l√™n canvas
            const borderThickness = parameters.borderThickness || 2;
            const borderColor = parameters.borderColor || { r: 0, g: 0, b: 0, a: 1.0 };
            const backgroundColor = parameters.backgroundColor || { r: 255, g: 255, b: 255, a: 0.8 };
            const textColor = parameters.textColor || { r: 0, g: 0, b: 0, a: 1.0 };

            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');

            context.font = 'Bold ' + internalFontsize + 'px ' + fontface;
            const metrics = context.measureText(message);
            const textWidth = metrics.width;

            canvas.width = textWidth + borderThickness * 2 + 20; // Th√™m padding cho canvas
            canvas.height = internalFontsize * 1.4 + borderThickness * 2;

            context.font = 'Bold ' + internalFontsize + 'px ' + fontface;
            context.fillStyle = `rgba(${backgroundColor.r},${backgroundColor.g},${backgroundColor.b},${backgroundColor.a})`;
            context.strokeStyle = `rgba(${borderColor.r},${borderColor.g},${borderColor.b},${borderColor.a})`;
            context.lineWidth = borderThickness;

            context.fillStyle = `rgba(${textColor.r},${textColor.g},${textColor.b},${textColor.a})`;
            context.fillText(message, borderThickness + 5, internalFontsize + borderThickness);

            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter; // Th√™m magFilter cho nh·∫•t qu√°n
            texture.wrapS = THREE.ClampToEdgeWrapping;
            texture.wrapT = THREE.ClampToEdgeWrapping;

            const spriteMaterial = new THREE.SpriteMaterial({
                map: texture,
                sizeAttenuation: false, // THAY ƒê·ªîI ·ªû ƒê√ÇY: k√≠ch th∆∞·ªõc kh√¥ng ƒë·ªïi khi zoom
                transparent: true, // Cho ph√©p background trong su·ªët n·∫øu alpha < 1
                alphaTest: 0.1 // ƒê·ªÉ c√°c pixel g·∫ßn nh∆∞ trong su·ªët ho√†n to√†n kh√¥ng ƒë∆∞·ª£c v·∫Ω
            });
            const sprite = new THREE.Sprite(spriteMaterial);

            // ƒêi·ªÅu ch·ªânh scale ƒë·ªÉ sprite c√≥ chi·ªÅu cao mong mu·ªën 
            // Khi sizeAttenuation = false, scale n√†y s·∫Ω tr·ª±c ti·∫øp ·∫£nh h∆∞·ªüng ƒë·∫øn k√≠ch th∆∞·ªõc hi·ªÉn th·ªã tr√™n m√†n h√¨nh.
            // B·∫°n c√≥ th·ªÉ c·∫ßn ƒëi·ªÅu ch·ªânh gi√° tr·ªã n√†y ƒë·ªÉ ƒë·∫°t ƒë∆∞·ª£c k√≠ch th∆∞·ªõc mong mu·ªën.
            const desiredScreenHeightFactor = parameters.worldHeight || 50; // C√≥ th·ªÉ c·∫ßn ƒë·ªïi t√™n v√† gi√° tr·ªã
            // T·∫°m th·ªüi gi·ªØ nguy√™n logic scale c≈©, nh∆∞ng c√≥ th·ªÉ c·∫ßn ƒëi·ªÅu ch·ªânh l·∫°i 'desiredScreenHeightFactor'
            // ho·∫∑c c√°ch t√≠nh to√°n scale cho ph√π h·ª£p v·ªõi sizeAttenuation = false.
            // V√≠ d·ª•, b·∫°n c√≥ th·ªÉ mu·ªën ƒë·∫∑t m·ªôt scale c·ªë ƒë·ªãnh:
            // sprite.scale.set(50, 25, 1); // V√≠ d·ª•: r·ªông 50 units, cao 25 units tr√™n m√†n h√¨nh (c·∫ßn th·ª≠ nghi·ªám)
            sprite.scale.set((desiredScreenHeightFactor * canvas.width / canvas.height), desiredScreenHeightFactor, 1.0);

            return sprite;
        }

        // --- UUID Generation ---
        function generateUUID() {
            // Basic UUID v4 generator
            return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>
                (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
            );
        }

        // --- 3D Viewer Initialization ---
        function init3DViewer() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xeeeeee);

            // Camera
            const aspect = threeJsCanvasContainer.clientWidth / threeJsCanvasContainer.clientHeight;
            camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 10000);
            camera.position.set(100, 100, 500); // ƒêi·ªÅu ch·ªânh v·ªã tr√≠ camera cho ph√π h·ª£p v·ªõi d·ªØ li·ªáu c·ªßa b·∫°n
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(threeJsCanvasContainer.clientWidth, threeJsCanvasContainer.clientHeight);
            threeJsCanvasContainer.appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(200, 500, 300);
            scene.add(directionalLight);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 10;
            controls.maxDistance = 5000;
            controls.addEventListener('change', render3DScene); // render khi c√≥ t∆∞∆°ng t√°c

            // Shapes Group - to hold all dynamic shapes for easy clearing
            shapesGroup = new THREE.Group();
            scene.add(shapesGroup);

            vertexLabelsGroup = new THREE.Group(); // Kh·ªüi t·∫°o group cho nh√£n
            scene.add(vertexLabelsGroup);

            // Axes Helper
            const mainAxesHelper = new THREE.AxesHelper(10000); // TƒÉng chi·ªÅu d√†i tr·ª•c ch√≠nh
            scene.add(mainAxesHelper);

            // Grid/Ticks for Axes
            const ticksGroup = new THREE.Group();
            const tickLength = 20; // ƒê·ªô d√†i c·ªßa m·ªói v·∫°ch tick
            const tickStep = 100;  // Kho·∫£ng c√°ch gi·ªØa c√°c v·∫°ch tick
            const axisLength = 10000; // Ph·∫£i kh·ªõp v·ªõi AxesHelper ·ªü tr√™n
            const tickMaterialX = new THREE.LineBasicMaterial({ color: 0xff0000 }); // Red for X ticks
            const tickMaterialY = new THREE.LineBasicMaterial({ color: 0x00ff00 }); // Green for Y ticks
            const tickMaterialZ = new THREE.LineBasicMaterial({ color: 0x0000ff }); // Blue for Z ticks

            function createTicksForAxis(targetAxis, length, step, tickSize, material) {
                const points = [];
                for (let i = -length; i <= length; i += step) {
                    if (i === 0) continue; // B·ªè qua g·ªëc t·ªça ƒë·ªô

                    if (targetAxis === 'x') {
                        points.push(new THREE.Vector3(i, -tickSize / 2, 0));
                        points.push(new THREE.Vector3(i, tickSize / 2, 0));
                        points.push(new THREE.Vector3(i, 0, -tickSize / 2));
                        points.push(new THREE.Vector3(i, 0, tickSize / 2));
                    } else if (targetAxis === 'y') {
                        points.push(new THREE.Vector3(-tickSize / 2, i, 0));
                        points.push(new THREE.Vector3(tickSize / 2, i, 0));
                        points.push(new THREE.Vector3(0, i, -tickSize / 2));
                        points.push(new THREE.Vector3(0, i, tickSize / 2));
                    } else if (targetAxis === 'z') {
                        points.push(new THREE.Vector3(-tickSize / 2, 0, i));
                        points.push(new THREE.Vector3(tickSize / 2, 0, i));
                        points.push(new THREE.Vector3(0, -tickSize / 2, i));
                        points.push(new THREE.Vector3(0, tickSize / 2, i));
                    }
                }
                if (points.length > 0) {
                    const tickGeometry = new THREE.BufferGeometry().setFromPoints(points);
                    const ticks = new THREE.LineSegments(tickGeometry, material);
                    ticksGroup.add(ticks);
                }
            }

            createTicksForAxis('x', axisLength, tickStep, tickLength, tickMaterialX);
            createTicksForAxis('y', axisLength, tickStep, tickLength, tickMaterialY);
            createTicksForAxis('z', axisLength, tickStep, tickLength, tickMaterialZ);
            scene.add(ticksGroup);

            // Initialize Raycaster
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            renderer.domElement.addEventListener('pointerdown', onDocumentMouseDown, false);

            // Animation loop for controls damping
            function animate() {
                requestAnimationFrame(animate);
                controls.update(); // only required if controls.enableDamping or controls.autoRotate are set to true
                render3DScene();
            }
            animate();

            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);
            onWindowResize(); // Initial call to set size
        }

        function onWindowResize() {
            if (!renderer || !camera || !threeJsCanvasContainer) return;
            const newWidth = threeJsCanvasContainer.clientWidth;
            const newHeight = threeJsCanvasContainer.clientHeight;

            camera.aspect = newWidth / newHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(newWidth, newHeight);
            update3DView();
        }

        function render3DScene() {
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }

        // --- Update 3D View ---
        function update3DView() {
            if (!scene || !shapesGroup) return;

            // Clear previous shapes and labels first
            while (shapesGroup.children.length > 0) {
                shapesGroup.remove(shapesGroup.children[0]);
            }
            shapesGroup.clear(); // ƒê·∫£m b·∫£o group r·ªóng
            threeShapeObjects = {}; // Reset map object

            while (vertexLabelsGroup && vertexLabelsGroup.children.length > 0) {
                vertexLabelsGroup.remove(vertexLabelsGroup.children[0]);
            }
            if (vertexLabelsGroup) vertexLabelsGroup.clear();


            shapesData.forEach(shape => {
                const isSelected = shape._internalId === selectedShapeId;

                const shapeSpecificGroup = new THREE.Group(); // Group ri√™ng cho m·ªói shape
                shapeSpecificGroup.userData.shapeId = shape._internalId; // Store shapeId for picking
                shapesGroup.add(shapeSpecificGroup); // Th√™m group c·ªßa shape v√†o group ch√≠nh

                const currentLineMaterial = new THREE.LineBasicMaterial({
                    color: isSelected ? HIGHLIGHTED_LINE_COLOR : NORMAL_LINE_COLOR,
                    depthTest: false, // ƒê·ªÉ line kh√¥ng b·ªã ·∫©n b·ªüi face n·∫øu tr√πng
                });
                const currentFaceMaterial = new THREE.MeshStandardMaterial({
                    color: isSelected ? HIGHLIGHTED_FACE_COLOR : NORMAL_FACE_COLOR,
                    side: THREE.FrontSide,
                    metalness: 0.1,
                    roughness: 0.75,
                    depthTest: true
                });
                const currentLabelBackgroundColor = isSelected ? HIGHLIGHTED_LABEL_BG_COLOR : NORMAL_LABEL_BG_COLOR;
                const currentLabelTextColor = isSelected ? { r: 0, g: 0, b: 0, a: 1 } : { r: 255, g: 255, b: 255, a: 1 };


                // L∆∞u tr·ªØ c√°c ƒë·ªëi t∆∞·ª£ng three.js c·ªßa shape n√†y ƒë·ªÉ c√≥ th·ªÉ highlight sau
                threeShapeObjects[shape._internalId] = {
                    group: shapeSpecificGroup, // Group ch·ª©a t·∫•t c·∫£ elements c·ªßa shape n√†y
                    lines: null, // S·∫Ω ƒë∆∞·ª£c g√°n khi t·∫°o LineSegments
                    mesh: null,  // S·∫Ω ƒë∆∞·ª£c g√°n khi t·∫°o Mesh
                    labels: [] // M·∫£ng c√°c sprite nh√£n
                };

                if (!shape.v || Object.keys(shape.v).length === 0) return;

                const vertexMap = {};
                const points = [];
                Object.keys(shape.v).sort((a, b) => parseInt(a) - parseInt(b)).forEach((key, index) => {
                    const coords = shape.v[key];
                    const pivot = shape.pivot || [0, 0, 0]; // L·∫•y pivot, m·∫∑c ƒë·ªãnh [0,0,0]
                    const vertexPosition = new THREE.Vector3(
                        coords[0] + pivot[0],
                        coords[1] + pivot[1],
                        coords[2] + pivot[2]
                    );
                    points.push(vertexPosition);
                    vertexMap[key] = index;

                    const currentWorldHeight = 0.1; // ƒê·∫∑t l·∫°i k√≠ch th∆∞·ªõc nh√£n mong mu·ªën tr√™n m√†n h√¨nh
                    const labelSprite = createTextSprite(key.toString(), {
                        internalFontsize: 32,    // Gi·ªØ nguy√™n font size cho texture s·∫Øc n√©t
                        worldHeight: currentWorldHeight,
                        backgroundColor: currentLabelBackgroundColor,
                        textColor: currentLabelTextColor,
                        fontface: 'monospace'
                    });
                    labelSprite.position.copy(vertexPosition);
                    labelSprite.position.y += (currentWorldHeight * 0.5) + 2;
                    if (isSelected) { // Ch·ªâ th√™m label v√†o group c·ªßa shape n·∫øu shape ƒë∆∞·ª£c ch·ªçn
                        shapeSpecificGroup.add(labelSprite);
                    }
                    threeShapeObjects[shape._internalId].labels.push(labelSprite); // V·∫´n l∆∞u tr·ªØ tham chi·∫øu ƒë·∫øn label
                });

                if (points.length === 0) return;

                if (shape.lines && shape.lines.length > 0) {
                    const linePointsForBuffer = []; // For existing LineBasicMaterial if not selected
                    const flatLineVertices = [];   // For LineMaterial if selected

                    shape.lines.forEach(line => {
                        if (vertexMap[line.v1.toString()] !== undefined && vertexMap[line.v2.toString()] !== undefined) {
                            const p1 = points[vertexMap[line.v1.toString()]];
                            const p2 = points[vertexMap[line.v2.toString()]];

                            flatLineVertices.push(p1.x, p1.y, p1.z);
                            flatLineVertices.push(p2.x, p2.y, p2.z);
                        }
                    });

                    if (flatLineVertices.length > 0) {
                        if (isSelected) { // Ch·ªâ v·∫Ω lines n·∫øu shape ƒë∆∞·ª£c ch·ªçn
                            const lineGeo = new THREE.LineSegmentsGeometry();
                            lineGeo.setPositions(flatLineVertices);

                            const lineMat = new THREE.LineMaterial({
                                color: HIGHLIGHTED_LINE_COLOR,
                                linewidth: 3, // ƒê·ªô d√†y c·ªßa line (v√≠ d·ª•: 3 pixels)
                                resolution: new THREE.Vector2(threeJsCanvasContainer.clientWidth, threeJsCanvasContainer.clientHeight),
                                depthTest: true, // ƒê·ªïi th√†nh true ƒë·ªÉ ƒë∆∞·ªùng b·ªã khu·∫•t kh√¥ng hi·ªÉn th·ªã
                                dashed: false
                            });

                            const lineSegmentsFat = new THREE.LineSegments2(lineGeo, lineMat);
                            shapeSpecificGroup.add(lineSegmentsFat);
                            threeShapeObjects[shape._internalId].lines = lineSegmentsFat;
                        }
                    }
                }

                if (shape.faces && Object.keys(shape.faces).length > 0) {
                    const faceIndices = [];
                    Object.values(shape.faces).forEach(face => {
                        const vIndices = face.vertices;
                        const mappedVIndices = vIndices.map(vi => vertexMap[vi.toString()]).filter(vi => vi !== undefined);

                        if (mappedVIndices.length >= 3) {
                            for (let i = 1; i < mappedVIndices.length - 1; i++) {
                                faceIndices.push(mappedVIndices[0], mappedVIndices[i], mappedVIndices[i + 1]);
                            }
                        }
                    });

                    if (faceIndices.length > 0) {
                        const faceGeometry = new THREE.BufferGeometry().setFromPoints(points);
                        faceGeometry.setIndex(faceIndices);
                        faceGeometry.computeVertexNormals();
                        const mesh = new THREE.Mesh(faceGeometry, currentFaceMaterial);
                        shapeSpecificGroup.add(mesh); // Th√™m mesh v√†o group c·ªßa shape
                        threeShapeObjects[shape._internalId].mesh = mesh;
                    }
                }
            });
            render3DScene();
        }

        // --- Render Functions ---
        function renderShapesList() {
            shapesListContainer.innerHTML = '';
            if (shapesData.length === 0) {
                shapesListContainer.innerHTML = '<p>Ch∆∞a c√≥ shape n√†o.</p>';
            } else {
                shapesData.forEach((shape, index) => {
                    const shapeItem = document.createElement('div');
                    shapeItem.classList.add('shape-item');
                    if (shape._internalId === selectedShapeId) {
                        shapeItem.classList.add('selected');
                    }
                    // Hi·ªÉn th·ªã t√™n theo mode "Line" trong danh s√°ch cho nh·∫•t qu√°n, ho·∫∑c c√≥ th·ªÉ ch·ªçn m·ªôt mode c·ªë ƒë·ªãnh
                    const displayIdentifiers = generateShapeIdentifiers(index, "Line");
                    shapeItem.textContent = `Shape: ${displayIdentifiers.name}`;
                    shapeItem.dataset.shapeId = shape._internalId; // V·∫´n d√πng _internalId ƒë·ªÉ ch·ªçn

                    const deleteBtn = document.createElement('button');
                    deleteBtn.innerHTML = 'üóëÔ∏è';
                    deleteBtn.title = 'X√≥a Shape';
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        deleteShape(shape._internalId);
                    };

                    const copyShapeBtn = document.createElement('button');
                    copyShapeBtn.innerHTML = 'üìã';
                    copyShapeBtn.title = 'Sao ch√©p Shape';
                    copyShapeBtn.style.backgroundColor = '#28a745';
                    copyShapeBtn.style.marginLeft = '5px';
                    copyShapeBtn.onclick = (e) => {
                        e.stopPropagation();
                        copyShape(shape._internalId);
                    };

                    shapeItem.appendChild(copyShapeBtn);
                    shapeItem.appendChild(deleteBtn);

                    shapeItem.onclick = () => {
                        selectShape(shape._internalId);
                    };
                    shapesListContainer.appendChild(shapeItem);
                });
            }
            // Kh√¥ng c·∫ßn g·ªçi update3DView ·ªü ƒë√¢y n·ªØa v√¨ selectShape s·∫Ω l√†m ƒëi·ªÅu ƒë√≥ th√¥ng qua renderJsonOutput
        }

        function renderJsonOutput() {
            // H√†m n√†y gi·ªù ch·ªâ t·∫°o JSON cho Line Geometry v√† c·∫≠p nh·∫≠t 3D view
            currentJsonString = generateJsonString(true); // true ƒë·ªÉ bao g·ªìm lines
            update3DView(); // Update 3D view whenever JSON output changes
        }

        function generateJsonString(includeLines) {
            const shapesForJson = shapesData.map((s, index) => {
                const { _internalId, pivot, stdMaterial, deformTypes, ...shapeRest } = s; // L·∫•y th√™m stdMaterial, deformTypes
                const currentPivot = pivot && Array.isArray(pivot) && pivot.length === 3 ? pivot : [0, 0, 0];

                const mode = includeLines ? "Line" : "Std";
                const identifiers = generateShapeIdentifiers(index, mode);

                const worldVertices = {};
                if (shapeRest.v) {
                    Object.keys(shapeRest.v).forEach(vKey => {
                        const localCoord = shapeRest.v[vKey];
                        worldVertices[vKey] = [
                            parseFloat((localCoord[0] + currentPivot[0]).toFixed(1)),
                            parseFloat((localCoord[1] + currentPivot[1]).toFixed(1)),
                            parseFloat((localCoord[2] + currentPivot[2]).toFixed(1))
                        ];
                    });
                }

                const outputShape = {
                    ...shapeRest,
                    name: identifiers.name, // S·ª≠ d·ª•ng t√™n ƒë∆∞·ª£c t·∫°o ƒë·ªông
                    uuid: identifiers.uuid, // S·ª≠ d·ª•ng UUID ƒë∆∞·ª£c t·∫°o ƒë·ªông
                    v: worldVertices,
                    lines: includeLines ? (shapeRest.lines || []) : []
                };
                // Kh√¥ng th√™m stdMaterial v√† deformTypes v√†o ƒë√¢y v√¨ ƒë√¢y l√† JSON cho Geometry
                return outputShape;
            });

            const output = {
                shapes: shapesForJson
            };
            return JSON.stringify(output); // B·ªè null, 2 ƒë·ªÉ minimize
        }

        function renderSelectedShapeEditor() {
            if (!selectedShapeId) {
                shapeEditorContainer.classList.add('hidden');
                noShapeSelectedMsg.classList.remove('hidden');
                if (currentDeformTypesText) currentDeformTypesText.textContent = 'None';
                return;
            }

            shapeEditorContainer.classList.remove('hidden');
            noShapeSelectedMsg.classList.add('hidden');

            const shape = shapesData.find(s => s._internalId === selectedShapeId);
            if (!shape) return; // Should not happen

            const shapeIndex = shapesData.findIndex(s => s._internalId === selectedShapeId);
            if (shapeIndex === -1) return; // Should not happen

            const lineIdentifiers = generateShapeIdentifiers(shapeIndex, "Line");
            const stdIdentifiers = generateShapeIdentifiers(shapeIndex, "Std");

            generatedShapeNameLine.textContent = lineIdentifiers.name;
            generatedShapeNameStd.textContent = stdIdentifiers.name;
            // UUID hi·ªÉn th·ªã c√≥ th·ªÉ l·∫•y theo Line mode ho·∫∑c l√†m r√µ h∆°n
            // generatedShapeUuid.textContent = `${lineIdentifiers.uuid} (Line Mode) / ${stdIdentifiers.uuid} (Std Mode)`; // ƒê√É X√ìA

            stdMaterialInput.value = shape.stdMaterial || '';

            // X·ª≠ l√Ω Deform Types Checkboxes
            shape.deformTypes = shape.deformTypes || [];
            deformStretch2Checkbox.checked = shape.deformTypes.includes('Stretch2');
            deformClippingCheckbox.checked = shape.deformTypes.includes('Clipping');
            updateCurrentDeformTypesText(shape.deformTypes); // C·∫≠p nh·∫≠t text hi·ªÉn th·ªã

            // Hi·ªÉn th·ªã v√† x·ª≠ l√Ω pivot
            shape.pivot = shape.pivot || [0, 0, 0]; // ƒê·∫£m b·∫£o pivot t·ªìn t·∫°i
            pivotXInput.value = shape.pivot[0];
            pivotYInput.value = shape.pivot[1];
            pivotZInput.value = shape.pivot[2];

            renderVerticesList(shape);
            renderFacesList(shape);
            renderLinesList(shape);
            renderJsonOutput();
        }

        function renderVerticesList(shape) {
            verticesListContainer.innerHTML = '';
            if (!shape || !shape.v) return;

            Object.entries(shape.v).forEach(([key, coords], index) => {
                const vEntry = document.createElement('div');
                vEntry.classList.add('vertex-entry');

                const idLabel = document.createElement('span');
                idLabel.textContent = `ID(${key}):`;

                // G·ªôp th√†nh 1 input
                const coordsInput = document.createElement('input');
                coordsInput.type = 'text';
                coordsInput.value = coords.join(','); // Hi·ªÉn th·ªã d·∫°ng X,Y,Z
                coordsInput.dataset.vertexKey = key;
                coordsInput.style.flexGrow = 1; // Cho input chi·∫øm nhi·ªÅu kh√¥ng gian h∆°n
                coordsInput.onchange = handleVertexCoordsChange; // H√†m x·ª≠ l√Ω m·ªõi

                const copyBtn = document.createElement('button');
                copyBtn.innerHTML = 'üìã';
                copyBtn.title = 'Sao ch√©p Vertex';
                copyBtn.style.backgroundColor = '#17a2b8';
                copyBtn.onclick = () => copyVertex(key);

                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'üóëÔ∏è';
                deleteBtn.title = 'X√≥a Vertex';
                deleteBtn.style.backgroundColor = '#ffc107';
                deleteBtn.onclick = () => deleteVertex(key);

                vEntry.append(idLabel, coordsInput, copyBtn, deleteBtn);
                verticesListContainer.appendChild(vEntry);
            });
        }

        function renderFacesList(shape) {
            facesListContainer.innerHTML = '';
            if (!shape || !shape.faces) return;

            Object.entries(shape.faces).forEach(([key, faceData]) => {
                const fEntry = document.createElement('div');
                fEntry.classList.add('face-entry');
                fEntry.textContent = `Face ID(${key}): ${faceData.vertices.join(', ')}`;

                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'üóëÔ∏è';
                deleteBtn.title = 'X√≥a Face';
                deleteBtn.style.backgroundColor = '#ffc107';
                deleteBtn.onclick = () => deleteFace(key);

                fEntry.appendChild(deleteBtn);
                facesListContainer.appendChild(fEntry);
            });
        }

        function renderLinesList(shape) {
            linesListContainer.innerHTML = '';
            if (!shape || !shape.lines) return;

            shape.lines.forEach((line, index) => {
                const lEntry = document.createElement('div');
                lEntry.classList.add('line-entry');
                lEntry.textContent = `Line: v${line.v1} - v${line.v2}`;

                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'üóëÔ∏è';
                deleteBtn.title = 'X√≥a Line';
                deleteBtn.style.backgroundColor = '#ffc107';
                deleteBtn.onclick = () => deleteLine(index);

                lEntry.appendChild(deleteBtn);
                linesListContainer.appendChild(lEntry);
            });
        }


        // --- Event Handlers & Logic ---
        addShapeBtn.onclick = () => {
            const newShapeInternalId = Date.now() + Math.random(); // ID n·ªôi b·ªô duy nh·∫•t, kh√¥ng d√πng cho name/uuid n·ªØa
            const defaultStdMaterial = defaultStdMaterialInput.value.trim();
            const defaultDeformTypes = []; // Kh·ªüi t·∫°o m·∫£ng r·ªóng
            if (defaultDeformStretch2Checkbox.checked) defaultDeformTypes.push('Stretch2');
            if (defaultDeformClippingCheckbox.checked) defaultDeformTypes.push('Clipping');

            const newShape = {
                _internalId: newShapeInternalId,
                // name v√† uuid s·∫Ω ƒë∆∞·ª£c t·∫°o ƒë·ªông, kh√¥ng c·∫ßn l∆∞u tr·ªØ c·ªë ƒë·ªãnh trong shape object n·ªØa
                faces: {},
                lines: [],
                v: {},
                pivot: [0, 0, 0],
                deformTypes: defaultDeformTypes, // S·ª≠ d·ª•ng gi√° tr·ªã default
                stdMaterial: defaultStdMaterial  // S·ª≠ d·ª•ng gi√° tr·ªã default
            };
            shapesData.push(newShape);
            // Kh√¥ng c·∫ßn g√°n selectedShapeId ngay, v√¨ selectShape s·∫Ω l√†m ƒëi·ªÅu ƒë√≥ th√¥ng qua renderShapesList
            renderShapesList(); // C·∫≠p nh·∫≠t danh s√°ch tr∆∞·ªõc
            selectShape(newShapeInternalId); // T·ª± ƒë·ªông ch·ªçn shape m·ªõi
        };

        function selectShape(shapeIdToSelect) {
            selectedShapeId = shapeIdToSelect;
            renderShapesList();
            renderSelectedShapeEditor();
            renderJsonOutput(); // ƒêi·ªÅu n√†y s·∫Ω g·ªçi update3DView v√† √°p d·ª•ng highlight

            const editBtn = document.getElementById('openShapeCanvasModalBtn');
            if (editBtn) {
                editBtn.style.display = selectedShapeId ? 'inline-block' : 'none';
            }
            // N·∫øu kh√¥ng c√≥ shape n√†o ƒë∆∞·ª£c ch·ªçn, ƒë·∫£m b·∫£o modal c≈©ng ƒë√≥ng (n·∫øu ƒëang m·ªü)
            if (!selectedShapeId) {
                const shapeCanvasModal = document.getElementById('shapeCanvasModal');
                if (shapeCanvasModal && shapeCanvasModal.style.display === 'flex') {
                    shapeCanvasModal.style.display = 'none';
                }
            }
        }

        function deleteShape(shapeIdToDelete) {
            shapesData = shapesData.filter(s => s._internalId !== shapeIdToDelete);
            if (selectedShapeId === shapeIdToDelete) {
                selectedShapeId = null;
                if (currentDeformTypesText) currentDeformTypesText.textContent = 'None';
                // X√≥a lu√¥n text t√™n/uuid ƒëang hi·ªÉn th·ªã trong editor
                generatedShapeNameLine.textContent = '';
                generatedShapeNameStd.textContent = '';
                // generatedShapeUuid.textContent = ''; // ƒê√É X√ìA
            }
            renderShapesList();
            renderSelectedShapeEditor(); // C·∫≠p nh·∫≠t editor (c√≥ th·ªÉ ·∫©n ƒëi)
            renderJsonOutput();
        }

        function generateShapeIdentifiers(shapeIndex, mode) {
            const baseName = currentObjectName || "DEFAULT_OBJECT";
            const suffix = mode === "Line" ? "L" : "G";
            const name = `${baseName}-${suffix}_${shapeIndex + 1}`;
            return { name: name, uuid: name }; // UUID gi·ªëng h·ªát name
        }

        objectNameInput.onchange = (e) => {
            currentObjectName = e.target.value.trim();
            renderShapesList();
            renderSelectedShapeEditor(); // C·∫≠p nh·∫≠t t√™n hi·ªÉn th·ªã n·∫øu c√≥ shape ƒëang ch·ªçn
            renderJsonOutput(); // C·∫≠p nh·∫≠t JSON v√† 3D view
        };

        addVertexBtn.onclick = () => {
            if (!selectedShapeId) return;
            const shape = shapesData.find(s => s._internalId === selectedShapeId);
            if (!shape) return;

            const existingKeys = Object.keys(shape.v).map(k => parseInt(k)).filter(k => !isNaN(k));
            const newKey = existingKeys.length > 0 ? Math.max(...existingKeys) + 1 : 0;

            shape.v[newKey.toString()] = [0, 0, 0]; // Default coords
            renderVerticesList(shape);
            renderJsonOutput();
        };

        function handleVertexCoordsChange(event) {
            if (!selectedShapeId) return;
            const shape = shapesData.find(s => s._internalId === selectedShapeId);
            if (!shape) return;

            const vertexKey = event.target.dataset.vertexKey;
            const newCoordsStr = event.target.value.trim();
            const coordsArray = newCoordsStr.split(',').map(c => parseFloat(c.trim()));

            if (coordsArray.length === 3 && coordsArray.every(c => !isNaN(c))) {
                shape.v[vertexKey] = coordsArray;
                renderJsonOutput();
            } else {
                alert("ƒê·ªãnh d·∫°ng t·ªça ƒë·ªô kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p d∆∞·ªõi d·∫°ng X,Y,Z (v√≠ d·ª•: 10.5,20,30.2)");
                event.target.value = shape.v[vertexKey].join(',');
            }
        }

        function copyVertex(vertexKeyToCopy) {
            if (!selectedShapeId) {
                showToast('Vui l√≤ng ch·ªçn m·ªôt shape tr∆∞·ªõc.', 'warning');
                return;
            }
            const shape = shapesData.find(s => s._internalId === selectedShapeId);

            if (!shape) {
                showToast('Kh√¥ng t√¨m th·∫•y shape ƒë∆∞·ª£c ch·ªçn.', 'error');
                return;
            }

            // Ki·ªÉm tra shape.v v√† vertex ngu·ªìn
            if (typeof shape.v !== 'object' || shape.v === null || !shape.v[vertexKeyToCopy]) {
                showToast(`Kh√¥ng t√¨m th·∫•y vertex '${vertexKeyToCopy}' ho·∫∑c d·ªØ li·ªáu vertices kh√¥ng h·ª£p l·ªá.`, 'error');
                console.warn('[CopyVertex] Invalid shape.v or source vertex. Shape:', shape, 'VertexKey:', vertexKeyToCopy);
                return;
            }

            const coordsToCopy = [...shape.v[vertexKeyToCopy]];

            // T·∫°o key m·ªõi theo ƒë·ªãnh d·∫°ng 'vN', t∆∞∆°ng t·ª± nh∆∞ trong saveAndCloseModal
            let nextVertexNum = 1;
            const existingVertexKeys = Object.keys(shape.v);
            if (existingVertexKeys.length > 0) {
                const numericKeys = existingVertexKeys
                    .map(key => parseInt(String(key).replace('v', ''), 10))
                    .filter(num => !isNaN(num));
                if (numericKeys.length > 0) {
                    nextVertexNum = Math.max(...numericKeys) + 1;
                }
            }
            const newKey = String(nextVertexNum);

            shape.v[newKey] = coordsToCopy;
            renderVerticesList(shape); // V·∫Ω l·∫°i danh s√°ch vertices cho shape n√†y
            renderJsonOutput(); // C·∫≠p nh·∫≠t JSON v√† 3D view
            showToast(`Vertex ${vertexKeyToCopy} ƒë√£ ƒë∆∞·ª£c sao ch√©p th√†nh ${newKey}.`);
        }

        function deleteVertex(vertexKeyToDelete) {
            if (!selectedShapeId) return;
            const shape = shapesData.find(s => s._internalId === selectedShapeId);
            if (!shape || !shape.v[vertexKeyToDelete]) return;

            // B·ªè confirm, th·ª±c hi·ªán x√≥a tr·ª±c ti·∫øp
            // if (confirm(`B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a Vertex ID(${vertexKeyToDelete})? ƒêi·ªÅu n√†y c√≥ th·ªÉ ·∫£nh h∆∞·ªüng ƒë·∫øn Faces v√† Lines.`)) {
            delete shape.v[vertexKeyToDelete];
            renderVerticesList(shape);
            renderJsonOutput();
            showToast(`ƒê√£ x√≥a Vertex ID(${vertexKeyToDelete}). L∆∞u √Ω: Faces v√† Lines tham chi·∫øu ƒë·∫øn vertex n√†y c√≥ th·ªÉ kh√¥ng c√≤n h·ª£p l·ªá.`, 'warning');
            // }
        }

        addFaceBtn.onclick = () => {
            if (!selectedShapeId) return;
            const shape = shapesData.find(s => s._internalId === selectedShapeId);
            if (!shape) return;

            const verticesStr = faceVerticesInput.value.trim();
            const existingFaceKeys = Object.keys(shape.faces).map(k => parseInt(k)).filter(k => !isNaN(k));
            let newFaceKey = 0;
            if (existingFaceKeys.length > 0) {
                newFaceKey = Math.max(...existingFaceKeys) + 1;
            }
            const faceKey = newFaceKey.toString();

            if (!verticesStr) {
                showToast("Danh s√°ch vertices cho face kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng.", 'error');
                return;
            }
            const verticesIndices = verticesStr.split(',').map(v => parseInt(v.trim())).filter(v => !isNaN(v));
            if (verticesIndices.length < 3) {
                showToast("M·ªôt face c·∫ßn √≠t nh·∫•t 3 vertices.", 'error');
                return;
            }
            for (let vIndex of verticesIndices) {
                if (!shape.v[vIndex.toString()]) {
                    showToast(`Vertex ID '${vIndex}' kh√¥ng t·ªìn t·∫°i trong danh s√°ch vertices hi·ªán t·∫°i c·ªßa shape.`, 'error');
                    return;
                }
            }
            shape.faces[faceKey] = { vertices: verticesIndices };
            renderFacesList(shape);
            if (verticesIndices.length >= 2) {
                for (let i = 0; i < verticesIndices.length; i++) {
                    const vA = verticesIndices[i];
                    const vB = verticesIndices[(i + 1) % verticesIndices.length];
                    if (vA === vB || !shape.v[vA.toString()] || !shape.v[vB.toString()]) continue;
                    const lineExists = shape.lines.some(existingLine =>
                        (existingLine.v1 === vA && existingLine.v2 === vB) ||
                        (existingLine.v1 === vB && existingLine.v2 === vA)
                    );
                    if (!lineExists) {
                        shape.lines.push({ v1: vA, v2: vB });
                    }
                }
                renderLinesList(shape);
            }
            renderJsonOutput();
            faceVerticesInput.value = '';
        };

        function deleteFace(faceKeyToDelete) {
            if (!selectedShapeId) return;
            const shape = shapesData.find(s => s._internalId === selectedShapeId);
            if (!shape || !shape.faces[faceKeyToDelete]) return;
            delete shape.faces[faceKeyToDelete];
            renderFacesList(shape);
            renderJsonOutput();
        }

        addLineBtn.onclick = () => {
            if (!selectedShapeId) return;
            const shape = shapesData.find(s => s._internalId === selectedShapeId);
            if (!shape) return;
            const verticesStr = lineVerticesInput.value.trim();
            if (!verticesStr) {
                showToast("Vui l√≤ng nh·∫≠p ID c·ªßa hai ƒë·ªânh, c√°ch nhau b·ªüi d·∫•u ph·∫©y.", 'error');
                return;
            }
            const parts = verticesStr.split(',');
            if (parts.length !== 2) {
                showToast("ƒê·ªãnh d·∫°ng kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p hai ID ƒë·ªânh, c√°ch nhau b·ªüi d·∫•u ph·∫©y (v√≠ d·ª•: 0,1).", 'error');
                return;
            }
            const v1 = parseInt(parts[0].trim());
            const v2 = parseInt(parts[1].trim());
            if (isNaN(v1) || isNaN(v2)) {
                showToast("ID Vertex ph·∫£i l√† s·ªë.", 'error');
                return;
            }
            if (!shape.v[v1.toString()]) {
                showToast(`Vertex ID '${v1}' kh√¥ng t·ªìn t·∫°i trong shape n√†y.`, 'error');
                return;
            }
            if (!shape.v[v2.toString()]) {
                showToast(`Vertex ID '${v2}' kh√¥ng t·ªìn t·∫°i trong shape n√†y.`, 'error');
                return;
            }
            if (v1 === v2) {
                showToast("M·ªôt line kh√¥ng th·ªÉ b·∫Øt ƒë·∫ßu v√† k·∫øt th√∫c ·ªü c√πng m·ªôt vertex.", 'error');
                return;
            }
            const lineExists = shape.lines.some(existingLine =>
                (existingLine.v1 === v1 && existingLine.v2 === v2) || (existingLine.v1 === v2 && existingLine.v2 === v1)
            );
            if (lineExists) {
                showToast("Line n√†y ƒë√£ t·ªìn t·∫°i.", 'error');
                return;
            }
            shape.lines.push({ v1: v1, v2: v2 });
            renderLinesList(shape);
            renderJsonOutput();
            lineVerticesInput.value = '';
        };

        function deleteLine(lineIndexToDelete) {
            if (!selectedShapeId) return;
            const shape = shapesData.find(s => s._internalId === selectedShapeId);
            if (!shape || !shape.lines[lineIndexToDelete]) return;
            shape.lines.splice(lineIndexToDelete, 1);
            renderLinesList(shape);
            renderJsonOutput();
        }

        // --- Transformation Functions ---
        function calculateShapeCentroid(shape) {
            if (!shape || !shape.v || Object.keys(shape.v).length === 0) {
                return new THREE.Vector3(0, 0, 0); // Default to origin if no vertices
            }
            const centroid = new THREE.Vector3(0, 0, 0);
            const vertexKeys = Object.keys(shape.v);
            vertexKeys.forEach(key => {
                centroid.add(new THREE.Vector3(...shape.v[key]));
            });
            centroid.divideScalar(vertexKeys.length);
            return centroid;
        }

        applyTranslateBtn.onclick = () => {
            if (!selectedShapeId) return;
            const shape = shapesData.find(s => s._internalId === selectedShapeId);
            if (!shape || !shape.v) return;

            // ƒê·∫£m b·∫£o shape.pivot t·ªìn t·∫°i v√† l√† m·ªôt m·∫£ng
            shape.pivot = shape.pivot && Array.isArray(shape.pivot) && shape.pivot.length === 3 ? shape.pivot : [0, 0, 0];

            const deltaX = parseFloat(translateXInput.value) || 0;
            const deltaY = parseFloat(translateYInput.value) || 0;
            const deltaZ = parseFloat(translateZInput.value) || 0;

            shape.pivot[0] = parseFloat((shape.pivot[0] + deltaX).toFixed(1));
            shape.pivot[1] = parseFloat((shape.pivot[1] + deltaY).toFixed(1));
            shape.pivot[2] = parseFloat((shape.pivot[2] + deltaZ).toFixed(1));

            // Kh√¥ng c·∫ßn c·∫≠p nh·∫≠t shape.v n·ªØa v√¨ ch√∫ng l√† local
            // renderVerticesList(shape); // Kh√¥ng c·∫ßn thi·∫øt n·∫øu ch·ªâ pivot thay ƒë·ªïi
            renderSelectedShapeEditor(); // C·∫≠p nh·∫≠t gi√° tr·ªã pivot tr√™n UI
            renderJsonOutput(); // C·∫≠p nh·∫≠t JSON v√† 3D view
        };

        applyRotateBtn.onclick = () => {
            if (!selectedShapeId) return;
            const shape = shapesData.find(s => s._internalId === selectedShapeId);
            if (!shape || !shape.v) return;

            const angleX = THREE.MathUtils.degToRad(parseFloat(rotateXInput.value) || 0);
            const angleY = THREE.MathUtils.degToRad(parseFloat(rotateYInput.value) || 0);
            const angleZ = THREE.MathUtils.degToRad(parseFloat(rotateZInput.value) || 0);

            // const centroid = calculateShapeCentroid(shape); // Kh√¥ng c·∫ßn centroid n·ªØa v√¨ xoay local vertices
            const euler = new THREE.Euler(angleX, angleY, angleZ, 'XYZ'); // Th·ª© t·ª± xoay XYZ

            Object.keys(shape.v).forEach(key => {
                const vertex = new THREE.Vector3(...shape.v[key]); // ƒê√¢y l√† local vertex
                // vertex.sub(centroid); // Kh√¥ng c·∫ßn tr·ª´ centroid
                vertex.applyEuler(euler); // Xoay quanh g·ªëc (0,0,0) c·ªßa local space
                // vertex.add(centroid); // Kh√¥ng c·∫ßn c·ªông l·∫°i centroid
                shape.v[key] = [
                    parseFloat(vertex.x.toFixed(1)),
                    parseFloat(vertex.y.toFixed(1)),
                    parseFloat(vertex.z.toFixed(1))
                ];
            });
            renderVerticesList(shape);
            renderJsonOutput();
        };

        function applyFlip(axis) {
            if (!selectedShapeId) return;
            const shape = shapesData.find(s => s._internalId === selectedShapeId);
            if (!shape || !shape.v) return;

            // const centroid = calculateShapeCentroid(shape); // Kh√¥ng c·∫ßn centroid n·ªØa

            Object.keys(shape.v).forEach(key => {
                const vertex = new THREE.Vector3(...shape.v[key]); // Local vertex
                // vertex.sub(centroid); // Kh√¥ng c·∫ßn
                if (axis === 'x') vertex.x *= -1;
                if (axis === 'y') vertex.y *= -1;
                if (axis === 'z') vertex.z *= -1;
                // vertex.add(centroid); // Kh√¥ng c·∫ßn
                shape.v[key] = [
                    parseFloat(vertex.x.toFixed(1)),
                    parseFloat(vertex.y.toFixed(1)),
                    parseFloat(vertex.z.toFixed(1))
                ];
            });
            renderVerticesList(shape);
            renderJsonOutput();
        }

        flipXBtn.onclick = () => applyFlip('x');
        flipYBtn.onclick = () => applyFlip('y');
        flipZBtn.onclick = () => applyFlip('z');

        pivotXInput.onchange = handlePivotChange;
        pivotYInput.onchange = handlePivotChange;
        pivotZInput.onchange = handlePivotChange;

        function handlePivotChange() {
            if (!selectedShapeId) return;
            const shape = shapesData.find(s => s._internalId === selectedShapeId);
            if (!shape) return;

            const newPivotX = parseFloat(pivotXInput.value) || 0;
            const newPivotY = parseFloat(pivotYInput.value) || 0;
            const newPivotZ = parseFloat(pivotZInput.value) || 0;

            shape.pivot = [newPivotX, newPivotY, newPivotZ];
            renderJsonOutput(); // C·∫≠p nh·∫≠t 3D view v√† JSON
        }

        deformStretch2Checkbox.onchange = handleDeformTypeChange;
        deformClippingCheckbox.onchange = handleDeformTypeChange;

        function handleDeformTypeChange(event) {
            if (!selectedShapeId) return;
            const shape = shapesData.find(s => s._internalId === selectedShapeId);
            if (!shape) return;

            const type = event.target.id === 'deformStretch2Checkbox' ? 'Stretch2' : 'Clipping';
            shape.deformTypes = shape.deformTypes || [];

            if (event.target.checked) {
                // Th√™m n·∫øu ch∆∞a c√≥, gi·ªØ th·ª© t·ª± n·∫øu ƒë√£ c√≥ t·ª´ tr∆∞·ªõc (do uncheck r·ªìi check l·∫°i)
                if (!shape.deformTypes.includes(type)) {
                    shape.deformTypes.push(type);
                }
            } else {
                // X√≥a kh·ªèi m·∫£ng
                shape.deformTypes = shape.deformTypes.filter(dt => dt !== type);
            }
            updateCurrentDeformTypesText(shape.deformTypes); // C·∫≠p nh·∫≠t text hi·ªÉn th·ªã
            // Kh√¥ng c·∫ßn g·ªçi renderJsonOutput() ·ªü ƒë√¢y v√¨ JSON cho LineMesh ƒë∆∞·ª£c t·∫°o ri√™ng khi b·∫•m n√∫t
        }

        function updateCurrentDeformTypesText(deformTypesArray) {
            if (currentDeformTypesText) {
                currentDeformTypesText.textContent = deformTypesArray.join(', ') || 'None';
            }
        }

        function generateLineMeshJsonString() {
            const children = shapesData.map((shape, index) => {
                const identifiers = generateShapeIdentifiers(index, "Line");
                // ƒê·∫£m b·∫£o shape.name kh√¥ng r·ªóng, n·∫øu r·ªóng d√πng m·ªôt gi√° tr·ªã t·∫°m
                // const geometryName = (shape.name && shape.name.trim() !== '') ? shape.name.trim() : `Shape_${shape._internalId}`; // C≈©
                return {
                    "@type": ".Mesh2",
                    geometry: identifiers.name, // S·ª≠ d·ª•ng t√™n ƒë∆∞·ª£c t·∫°o ƒë·ªông
                    deformTypes: shape.deformTypes && Array.isArray(shape.deformTypes) ? shape.deformTypes : ['Stretch2'],
                    material: "MF", // Gi·ªØ nguy√™n nh∆∞ logic c≈© c·ªßa LineMesh
                    edgeMaterial: "ML0" // Gi·ªØ nguy√™n
                };
            });
            return JSON.stringify({ children: children }); // B·ªè null, 2 ƒë·ªÉ minimize
        }

        copyLineMeshBtn.onclick = () => {
            const lineMeshJson = generateLineMeshJsonString();
            navigator.clipboard.writeText(lineMeshJson).then(() => {
                showToast('ƒê√£ sao ch√©p Line Mesh JSON v√†o clipboard!', 'success');
            }).catch(err => {
                console.error('L·ªói khi sao ch√©p Line Mesh JSON: ', err);
                showToast('Kh√¥ng th·ªÉ t·ª± ƒë·ªông sao ch√©p Line Mesh JSON. Vui l√≤ng th·ª≠ l·∫°i.', 'error');
            });
        };

        function generateStdMeshJsonString() {
            const children = shapesData.map((shape, index) => {
                const identifiers = generateShapeIdentifiers(index, "Std");
                // const geometryName = (shape.name && shape.name.trim() !== '') ? shape.name.trim() : `Shape_${shape._internalId}`; // C≈©
                return {
                    "@type": ".Mesh2",
                    geometry: identifiers.name, // S·ª≠ d·ª•ng t√™n ƒë∆∞·ª£c t·∫°o ƒë·ªông
                    deformTypes: shape.deformTypes && Array.isArray(shape.deformTypes) ? shape.deformTypes : ['Stretch2'],
                    material: shape.stdMaterial || "",
                    matTag: "mat1"
                };
            });
            return JSON.stringify({ children: children }); // B·ªè null, 2 ƒë·ªÉ minimize
        }

        copyStdMeshBtn.onclick = () => {
            const stdMeshJson = generateStdMeshJsonString();
            navigator.clipboard.writeText(stdMeshJson).then(() => {
                showToast('ƒê√£ sao ch√©p Std Mesh JSON v√†o clipboard!', 'success');
            }).catch(err => {
                console.error('L·ªói khi sao ch√©p Std Mesh JSON: ', err);
                showToast('Kh√¥ng th·ªÉ t·ª± ƒë·ªông sao ch√©p Std Mesh JSON. Vui l√≤ng th·ª≠ l·∫°i.', 'error');
            });
        };

        stdMaterialInput.onchange = (e) => {
            if (selectedShapeId) {
                const shape = shapesData.find(s => s._internalId === selectedShapeId);
                if (shape) {
                    shape.stdMaterial = e.target.value;
                    // Kh√¥ng c·∫ßn renderJsonOutput() v√¨ stdMaterial kh√¥ng ·∫£nh h∆∞·ªüng tr·ª±c ti·∫øp ƒë·∫øn 3D view ho·∫∑c JSON c·ªßa c√°c n√∫t copy kh√°c
                }
            }
        };

        importJsonBtn.onclick = async () => {
            try {
                const textFromClipboard = await navigator.clipboard.readText();
                if (!textFromClipboard) {
                    showToast("Clipboard r·ªóng ho·∫∑c kh√¥ng ch·ª©a d·ªØ li·ªáu text.", 'info');
                    return;
                }

                const parsedData = JSON.parse(textFromClipboard);

                if (!parsedData || !Array.isArray(parsedData.shapes)) {
                    showToast("L·ªói: D·ªØ li·ªáu t·ª´ clipboard kh√¥ng ph·∫£i JSON h·ª£p l·ªá ho·∫∑c kh√¥ng c√≥ thu·ªôc t√≠nh 'shapes' d·∫°ng m·∫£ng.", 'error');
                    return;
                }

                const isValidShapeStructure = parsedData.shapes.every(shape =>
                    typeof shape.v === 'object' && shape.v !== null &&
                    typeof shape.faces === 'object' && shape.faces !== null &&
                    Array.isArray(shape.lines)
                );

                if (!isValidShapeStructure) {
                    showToast("L·ªói: M·ªôt ho·∫∑c nhi·ªÅu shape trong JSON t·ª´ clipboard kh√¥ng c√≥ c·∫•u tr√∫c v, faces, ho·∫∑c lines h·ª£p l·ªá.", 'error');
                    return;
                }

                if (!currentObjectName || currentObjectName.trim() === "") {
                    showToast("Vui l√≤ng nh·∫≠p Object Name tr∆∞·ªõc khi import JSON.", 'warning');
                    objectNameInput.focus();
                    return;
                }

                shapesData = parsedData.shapes.map((s, index) => {
                    const internalId = Date.now() + index + Math.random();
                    return {
                        _internalId: internalId,
                        v: s.v || {},
                        faces: s.faces || {},
                        lines: s.lines || [],
                        pivot: s.pivot && Array.isArray(s.pivot) && s.pivot.length === 3 ? s.pivot : [0, 0, 0],
                        // N·∫øu s.deformTypes kh√¥ng t·ªìn t·∫°i, s·∫Ω l·∫•y t·ª´ c√°c checkbox m·∫∑c ƒë·ªãnh (gi·ªù ƒë√¢y s·∫Ω l√† r·ªóng n·∫øu kh√¥ng check)
                        deformTypes: s.deformTypes && Array.isArray(s.deformTypes) ? s.deformTypes : (defaultDeformStretch2Checkbox.checked ? ['Stretch2'] : []).concat(defaultDeformClippingCheckbox.checked ? ['Clipping'] : []),
                        stdMaterial: s.stdMaterial || defaultStdMaterialInput.value.trim()
                    };
                });

                selectedShapeId = null;
                renderShapesList();
                renderSelectedShapeEditor();
                renderJsonOutput();

                if (shapesData.length > 0 && !selectedShapeId) {
                    // Option: select the first shape automatically after import
                    // selectShape(shapesData[0]._internalId);
                } else if (selectedShapeId) {
                    const currentSelectedShape = shapesData.find(s => s._internalId === selectedShapeId);
                    if (currentSelectedShape) {
                        updateCurrentDeformTypesText(currentSelectedShape.deformTypes);
                    }
                } else {
                    if (currentDeformTypesText) currentDeformTypesText.textContent = 'None';
                }

            } catch (error) {
                console.error("L·ªói khi import JSON t·ª´ clipboard:", error);
                if (error.name === 'NotAllowedError') {
                    showToast("L·ªói: Kh√¥ng ƒë∆∞·ª£c ph√©p truy c·∫≠p clipboard. Vui l√≤ng c·∫•p quy·ªÅn cho trang web.", 'error');
                } else if (error instanceof SyntaxError) {
                    showToast("L·ªói: D·ªØ li·ªáu trong clipboard kh√¥ng ph·∫£i l√† ƒë·ªãnh d·∫°ng JSON h·ª£p l·ªá.", 'error');
                } else {
                    showToast("ƒê√£ x·∫£y ra l·ªói khi ƒë·ªçc ho·∫∑c parse JSON t·ª´ clipboard. Vui l√≤ng ki·ªÉm tra console.", 'error');
                }
            }
        };

        uploadJsonBtn.onclick = () => {
            uploadJsonFile.click(); // Trigger click event c·ªßa input file ·∫©n
        };

        uploadJsonFile.onchange = async (event) => {
            const file = event.target.files[0];
            if (!file) {
                showToast("Kh√¥ng c√≥ file n√†o ƒë∆∞·ª£c ch·ªçn.", 'info');
                return;
            }

            if (file.type !== "application/json") {
                showToast("Vui l√≤ng ch·ªçn m·ªôt file .json h·ª£p l·ªá.", 'error');
                event.target.value = null; // Reset input file
                return;
            }

            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const textFromFile = e.target.result;
                    if (!textFromFile) {
                        showToast("File r·ªóng ho·∫∑c kh√¥ng th·ªÉ ƒë·ªçc.", 'error');
                        event.target.value = null; // Reset input file
                        return;
                    }

                    const parsedData = JSON.parse(textFromFile);

                    if (!parsedData || !Array.isArray(parsedData.shapes)) {
                        showToast("L·ªói: D·ªØ li·ªáu t·ª´ file kh√¥ng ph·∫£i JSON h·ª£p l·ªá ho·∫∑c kh√¥ng c√≥ thu·ªôc t√≠nh 'shapes' d·∫°ng m·∫£ng.", 'error');
                        event.target.value = null; // Reset input file
                        return;
                    }

                    const isValidShapeStructure = parsedData.shapes.every(shape =>
                        typeof shape.v === 'object' && shape.v !== null &&
                        typeof shape.faces === 'object' && shape.faces !== null &&
                        Array.isArray(shape.lines)
                    );

                    if (!isValidShapeStructure) {
                        showToast("L·ªói: M·ªôt ho·∫∑c nhi·ªÅu shape trong JSON t·ª´ file kh√¥ng c√≥ c·∫•u tr√∫c v, faces, ho·∫∑c lines h·ª£p l·ªá.", 'error');
                        event.target.value = null; // Reset input file
                        return;
                    }

                    if (!currentObjectName || currentObjectName.trim() === "") {
                        showToast("Vui l√≤ng nh·∫≠p Object Name tr∆∞·ªõc khi import JSON.", 'warning');
                        objectNameInput.focus();
                        event.target.value = null; // Reset input file
                        return;
                    }

                    shapesData = parsedData.shapes.map((s, index) => {
                        const internalId = Date.now() + index + Math.random();
                        return {
                            _internalId: internalId,
                            v: s.v || {},
                            faces: s.faces || {},
                            lines: s.lines || [],
                            pivot: s.pivot && Array.isArray(s.pivot) && s.pivot.length === 3 ? s.pivot : [0, 0, 0],
                            deformTypes: s.deformTypes && Array.isArray(s.deformTypes) ? s.deformTypes : (defaultDeformStretch2Checkbox.checked ? ['Stretch2'] : []).concat(defaultDeformClippingCheckbox.checked ? ['Clipping'] : []),
                            stdMaterial: s.stdMaterial || defaultStdMaterialInput.value.trim()
                        };
                    });

                    selectedShapeId = null;
                    renderShapesList();
                    renderSelectedShapeEditor();
                    renderJsonOutput();
                    showToast(`ƒê√£ import th√†nh c√¥ng d·ªØ li·ªáu t·ª´ file ${file.name}`, 'success');


                    if (shapesData.length > 0 && !selectedShapeId) {
                        // Option: select the first shape automatically after import
                        // selectShape(shapesData[0]._internalId);
                    } else if (selectedShapeId) {
                        const currentSelectedShape = shapesData.find(s => s._internalId === selectedShapeId);
                        if (currentSelectedShape) {
                            updateCurrentDeformTypesText(currentSelectedShape.deformTypes);
                        }
                    } else {
                        if (currentDeformTypesText) currentDeformTypesText.textContent = 'None';
                    }
                    event.target.value = null; // Reset input file sau khi x·ª≠ l√Ω th√†nh c√¥ng

                } catch (error) {
                    console.error("L·ªói khi import JSON t·ª´ file:", error);
                    if (error instanceof SyntaxError) {
                        showToast("L·ªói: D·ªØ li·ªáu trong file kh√¥ng ph·∫£i l√† ƒë·ªãnh d·∫°ng JSON h·ª£p l·ªá.", 'error');
                    } else {
                        showToast("ƒê√£ x·∫£y ra l·ªói khi ƒë·ªçc ho·∫∑c parse JSON t·ª´ file. Vui l√≤ng ki·ªÉm tra console.", 'error');
                    }
                    event.target.value = null; // Reset input file
                }
            };
            reader.onerror = () => {
                showToast("L·ªói khi ƒë·ªçc file.", 'error');
                event.target.value = null; // Reset input file
            };
            reader.readAsText(file);
        };

        function copyShape(shapeIdToCopy) {
            // T√¨m shape g·ªëc ƒë·ªÉ sao ch√©p
            const originalShape = shapesData.find(s => s._internalId === shapeIdToCopy);
            if (!originalShape) return;

            // T·∫°o m·ªôt b·∫£n sao s√¢u c·ªßa shape (tr·ª´ _internalId)
            // Quan tr·ªçng: C·∫ßn sao ch√©p s√¢u c√°c object v√† array b√™n trong (v, faces, lines, pivot, deformTypes)
            const newShapeInternalId = Date.now() + Math.random();
            const newV = JSON.parse(JSON.stringify(originalShape.v || {}));
            const newFaces = JSON.parse(JSON.stringify(originalShape.faces || {}));
            const newLines = JSON.parse(JSON.stringify(originalShape.lines || []));
            const newPivot = JSON.parse(JSON.stringify(originalShape.pivot || [0, 0, 0]));
            const newDeformTypes = JSON.parse(JSON.stringify(originalShape.deformTypes || []));

            const copiedShape = {
                _internalId: newShapeInternalId,
                v: newV,
                faces: newFaces,
                lines: newLines,
                pivot: newPivot, // Sao ch√©p pivot
                deformTypes: newDeformTypes, // Sao ch√©p deformTypes
                stdMaterial: originalShape.stdMaterial // Sao ch√©p stdMaterial
            };

            // Th√™m shape ƒë√£ sao ch√©p v√†o m·∫£ng shapesData
            shapesData.push(copiedShape);

            // C·∫≠p nh·∫≠t danh s√°ch shapes v√† t·ª± ƒë·ªông ch·ªçn shape m·ªõi ƒë∆∞·ª£c sao ch√©p
            renderShapesList();
            selectShape(newShapeInternalId); // Ch·ªçn shape m·ªõi ƒë∆∞·ª£c copy
        }

        applyDefaultsBtn.onclick = () => {
            const defaultStdMaterial = defaultStdMaterialInput.value.trim();
            const defaultDeformTypes = [];
            if (defaultDeformStretch2Checkbox.checked) defaultDeformTypes.push('Stretch2');
            if (defaultDeformClippingCheckbox.checked) defaultDeformTypes.push('Clipping');

            if (shapesData.length === 0) {
                showToast("Kh√¥ng c√≥ shape n√†o ƒë·ªÉ √°p d·ª•ng.", 'info');
                return;
            }

            const confirmApply = confirm(`B·∫°n c√≥ ch·∫Øc mu·ªën √°p d·ª•ng default Std Material '${defaultStdMaterial}' v√† Deform Types '${defaultDeformTypes.join(', ')}' cho t·∫•t c·∫£ ${shapesData.length} shapes kh√¥ng? H√†nh ƒë·ªông n√†y kh√¥ng th·ªÉ ho√†n t√°c.`);
            if (!confirmApply) return;

            shapesData.forEach(shape => {
                shape.stdMaterial = defaultStdMaterial;
                shape.deformTypes = [...defaultDeformTypes]; // T·∫°o b·∫£n sao ƒë·ªÉ tr√°nh tham chi·∫øu
            });

            if (selectedShapeId) {
                renderSelectedShapeEditor(); // C·∫≠p nh·∫≠t editor n·∫øu c√≥ shape ƒëang ƒë∆∞·ª£c ch·ªçn
            }
            renderJsonOutput(); // C·∫≠p nh·∫≠t 3D view
            showToast(`ƒê√£ √°p d·ª•ng gi√° tr·ªã m·∫∑c ƒë·ªãnh cho ${shapesData.length} shapes.`, 'success');
        };

        copyLineGeometryBtn.onclick = () => {
            const lineGeometryJsonString = generateJsonString(true); // true ƒë·ªÉ bao g·ªìm lines
            if (!lineGeometryJsonString) {
                showToast('Kh√¥ng c√≥ d·ªØ li·ªáu Line Geometry JSON ƒë·ªÉ sao ch√©p.', 'info');
                return;
            }
            navigator.clipboard.writeText(lineGeometryJsonString).then(() => {
                showToast('ƒê√£ sao ch√©p Line Geometry JSON v√†o clipboard!', 'success');
            }).catch(err => {
                console.error('L·ªói khi sao ch√©p Line Geometry JSON: ', err);
                showToast('Kh√¥ng th·ªÉ t·ª± ƒë·ªông sao ch√©p JSON. Vui l√≤ng th·ª≠ l·∫°i.', 'error');
            });
        };

        copyStdGeometryBtn.onclick = () => {
            const stdGeometryJsonString = generateJsonString(false); // false ƒë·ªÉ kh√¥ng bao g·ªìm lines
            if (!stdGeometryJsonString) {
                showToast('Kh√¥ng th·ªÉ t·∫°o Standard Geometry JSON.', 'info');
                return;
            }
            navigator.clipboard.writeText(stdGeometryJsonString).then(() => {
                showToast('ƒê√£ sao ch√©p Standard Geometry JSON (kh√¥ng c√≥ lines) v√†o clipboard!', 'success');
            }).catch(err => {
                console.error('L·ªói khi sao ch√©p Standard Geometry JSON: ', err);
                showToast('Kh√¥ng th·ªÉ t·ª± ƒë·ªông sao ch√©p JSON. Vui l√≤ng th·ª≠ l·∫°i.', 'error');
            });
        };

        // --- Toast Notification Function ---
        function showToast(message, type = 'info') {
            const toastContainer = document.querySelector('.toast-container');
            if (!toastContainer) return; // Should not happen if HTML is correct

            const toastId = 'toast-' + Date.now();
            let toastHeaderClass = '';
            let toastIcon = '';

            switch (type) {
                case 'success':
                    toastHeaderClass = 'bg-success text-white';
                    toastIcon = '‚úîÔ∏è'; // Simple check icon
                    break;
                case 'error':
                    toastHeaderClass = 'bg-danger text-white';
                    toastIcon = '‚ùå'; // Simple cross icon
                    break;
                case 'warning':
                    toastHeaderClass = 'bg-warning text-dark';
                    toastIcon = '‚ö†Ô∏è'; // Simple warning icon
                    break;
                default: // info
                    toastHeaderClass = 'bg-info text-white';
                    toastIcon = '‚ÑπÔ∏è'; // Simple info icon
                    break;
            }

            const toastHTML = `
                <div id="${toastId}" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-delay="5000">
                    <div class="toast-header ${toastHeaderClass}">
                        <strong class="mr-auto">${toastIcon} Th√¥ng b√°o</strong>
                        <button type="button" class="ml-2 mb-1 close" data-dismiss="toast" aria-label="Close">
                            <span aria-hidden="true">&times;</span>
                        </button>
                    </div>
                    <div class="toast-body">
                        ${message}
                    </div>
                </div>
            `;

            toastContainer.insertAdjacentHTML('beforeend', toastHTML);
            const toastElement = document.getElementById(toastId);
            $(toastElement).toast('show'); // Initialize and show the toast using jQuery

            // Optional: Remove the toast from DOM after it's hidden
            $(toastElement).on('hidden.bs.toast', function () {
                this.remove();
            });
        }

        // --- Initialization ---
        function init() {
            // C√≥ th·ªÉ load d·ªØ li·ªáu m·∫´u ho·∫∑c t·ª´ localStorage ·ªü ƒë√¢y
            objectNameInput.value = currentObjectName; // ƒê·∫£m b·∫£o input hi·ªÉn th·ªã gi√° tr·ªã kh·ªüi t·∫°o

            renderShapesList();
            renderSelectedShapeEditor(); // Ban ƒë·∫ßu s·∫Ω ·∫©n editor
            renderJsonOutput(); // This will also call update3DView
            init3DViewer();
        }

        init();

        // --- Raycaster Click Handler ---
        function onDocumentMouseDown(event) {
            event.preventDefault();
            console.log(event);

            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(shapesGroup.children, true);

            if (intersects.length > 0) {
                let clickedObject = intersects[0].object;
                let parentGroupWithShapeId = null;
                console.log(clickedObject);

                while (clickedObject && clickedObject !== scene) {
                    if (clickedObject.userData && clickedObject.userData.shapeId) {
                        parentGroupWithShapeId = clickedObject;
                        break;
                    }
                    clickedObject = clickedObject.parent;
                }

                if (parentGroupWithShapeId) {
                    const shapeId = parentGroupWithShapeId.userData.shapeId;
                    if (shapeId && shapeId !== selectedShapeId) {
                        selectShape(shapeId);
                    }
                }
            }
        }

        // --- Shape Canvas Modal Logic ---
        let currentEditingShapeInModal = null; // Shape ƒëang ƒë∆∞·ª£c ch·ªânh s·ª≠a trong modal

        function closeShapeEditorModal() {
            const shapeCanvasModal = document.getElementById('shapeCanvasModal');
            if (shapeCanvasModal) {
                shapeCanvasModal.style.display = 'none';
            }
            currentEditingShapeInModal = null; // X√≥a tham chi·∫øu khi ƒë√≥ng modal
            // console.log('Modal closed, currentEditingShapeInModal:', currentEditingShapeInModal);

            // Reset tr·∫°ng th√°i t∆∞∆°ng t√°c
            currentModalInteractionMode = 'none'; // Reset mode
            setActiveModalButton(null);
            if (modalClickedPointCoordsContainer) modalClickedPointCoordsContainer.style.display = 'none';
            selectedTemporaryPointIndex = -1; // B·ªè highlight t·∫•t c·∫£ c√°c n√∫t ch·∫ø ƒë·ªô
            const canvas = document.getElementById('shapeDetailCanvas');
            if (canvas) {
                canvas.style.cursor = 'default';
            }
        }

        function updateShapeInList(updatedShape) {
            if (!updatedShape || !updatedShape._internalId) {
                console.error('[UpdateShape] Invalid shape or missing _internalId for update.');
                return;
            }
            // 'shapesData' l√† m·∫£ng to√†n c·ª•c ch·ª©a c√°c shape objects
            const index = shapesData.findIndex(s => s._internalId === updatedShape._internalId);
            if (index !== -1) {
                shapesData[index] = updatedShape;
                console.log('[UpdateShape] Shape updated in list:', updatedShape);
            } else {
                console.warn('[UpdateShape] Shape not found in list for ID:', updatedShape._internalId);
            }
        }

        // H√†m c·∫≠p nh·∫≠t t·ªça ƒë·ªô ƒëi·ªÉm t·∫°m th·ªùi t·ª´ input
        function updateTemporaryPointFromInputs() {
            console.log('[UpdateTempPoint] Function called. Selected Index:', selectedTemporaryPointIndex);
            if (selectedTemporaryPointIndex === -1 || !temporaryNewPoints[selectedTemporaryPointIndex]) {
                console.warn('[UpdateTempPoint] No temporary point selected or invalid index. Current temporaryNewPoints:', JSON.stringify(temporaryNewPoints));
                return;
            }

            const currentPoint = temporaryNewPoints[selectedTemporaryPointIndex];
            console.log(`[UpdateTempPoint] Point ${selectedTemporaryPointIndex} BEFORE update: (${currentPoint.x}, ${currentPoint.y}, ${currentPoint.z})`);

            const newX = parseFloat(modalPointXInput.value);
            const newY = parseFloat(modalPointYInput.value);
            const newZ = parseFloat(modalPointZInput.value);

            let changed = false;
            if (!isNaN(newX) && currentPoint.x !== newX) { currentPoint.x = newX; changed = true; }
            if (!isNaN(newY) && currentPoint.y !== newY) { currentPoint.y = newY; changed = true; }
            if (!isNaN(newZ) && currentPoint.z !== newZ) { currentPoint.z = newZ; changed = true; }

            if (changed) {
                console.log(`[UpdateTempPoint] Point ${selectedTemporaryPointIndex} AFTER update: (${currentPoint.x}, ${currentPoint.y}, ${currentPoint.z})`);
                console.log('[UpdateTempPoint] Calling drawModalCanvas() to refresh.');
                drawModalCanvas(); // V·∫Ω l·∫°i to√†n b·ªô modal canvas ƒë·ªÉ ph·∫£n √°nh thay ƒë·ªïi
            } else {
                console.log(`[UpdateTempPoint] No change in values for point ${selectedTemporaryPointIndex}.`);
            }
        }

        function saveAndCloseModal() {
            console.log('[SaveModal] Attempting to save changes...');
            try {
                if (currentEditingShapeInModal && temporaryNewPoints && temporaryNewPoints.length > 0) {
                    // ƒê·∫£m b·∫£o currentEditingShapeInModal.v l√† m·ªôt ƒë·ªëi t∆∞·ª£ng
                    if (typeof currentEditingShapeInModal.v !== 'object' || currentEditingShapeInModal.v === null) {
                        currentEditingShapeInModal.v = {}; 
                    }

                    // X√°c ƒë·ªãnh ID ti·∫øp theo cho vertex
                    let nextVertexNum = 1;
                    const existingVertexKeys = Object.keys(currentEditingShapeInModal.v || {});
                    if (existingVertexKeys.length > 0) {
                        const numericKeys = existingVertexKeys
                            .map(key => parseInt(String(key).replace('v', ''), 10))
                            .filter(num => !isNaN(num));
                        if (numericKeys.length > 0) {
                            nextVertexNum = Math.max(...numericKeys) + 1;
                        }
                    }
                    console.log(`[SaveModal] Starting new vertex ID from ${nextVertexNum}`);

                    temporaryNewPoints.forEach((pointObj, index) => {
                        const newVertexId = String(nextVertexNum + index);
                        // Chuy·ªÉn ƒë·ªïi ƒëi·ªÉm t·ª´ {x,y,z} (trong temporaryNewPoints) sang [x,y,z] (cho shape.v)
                        currentEditingShapeInModal.v[newVertexId] = [pointObj.x, pointObj.y, pointObj.z];
                        console.log(`[SaveModal] Added vertex ${newVertexId}: [${pointObj.x}, ${pointObj.y}, ${pointObj.z}]`);
                    });

                    console.log('[SaveModal] Vertices object after adding new points:', JSON.stringify(currentEditingShapeInModal.v));
                    updateShapeInList(currentEditingShapeInModal);
                    renderShapesList();
                    selectShape(currentEditingShapeInModal._internalId);
                    
                    showToast(`ƒê√£ th√™m ${temporaryNewPoints.length} ƒëi·ªÉm v√†o shape '${currentEditingShapeInModal.n || currentEditingShapeInModal.name}'.`);
                } else {
                    console.log('[SaveModal] No new points to save or no shape currently being edited.');
                }
            } catch (error) {
                console.error('[SaveModal] Error during save operation:', error);
                showToast('L·ªói: Kh√¥ng th·ªÉ l∆∞u c√°c thay ƒë·ªïi. Vui l√≤ng ki·ªÉm tra Console.', 'error');
            } finally {
                closeShapeEditorModal(); // ƒê·∫£m b·∫£o modal lu√¥n ƒë√≥ng v√† reset tr·∫°ng th√°i
            }
        }

        // C·∫≠p nh·∫≠t n√∫t ƒë√≥ng tr√™n HTML c·ªßa modal ƒë·ªÉ g·ªçi h√†m n√†y
        // V√≠ d·ª•: onclick="closeShapeEditorModal()"

        document.addEventListener('DOMContentLoaded', () => {
            const openShapeCanvasModalBtn = document.getElementById('openShapeCanvasModalBtn');

        if (openShapeCanvasModalBtn) {
            openShapeCanvasModalBtn.addEventListener('click', () => {
                const shapeCanvasModal = document.getElementById('shapeCanvasModal');
                const shapeDetailCanvas = document.getElementById('shapeDetailCanvas');
                const modalCanvasContainer = document.getElementById('modalCanvasContainer');
                const shapeCanvasModalTitle = document.getElementById('shapeCanvasModalTitle');
                const modalInfoContent = document.getElementById('modalInfoContent');

                if (!shapeCanvasModal) {
                    console.error('Shape Canvas Modal element not found on click!');
                    showToast('L·ªói: Kh√¥ng t√¨m th·∫•y modal canvas (click).', 'error');
                    return;
                }

                if (!selectedShapeId) {
                    showToast('Vui l√≤ng ch·ªçn m·ªôt shape ƒë·ªÉ ch·ªânh s·ª≠a.', 'warning');
                    return;
                }
                const shape = shapesData.find(s => s._internalId === selectedShapeId);
                if (!shape) {
                    showToast('Kh√¥ng t√¨m th·∫•y shape ƒë∆∞·ª£c ch·ªçn.', 'error');
                    currentEditingShapeInModal = null;
                    return;
                }
                currentEditingShapeInModal = shape; // L∆∞u shape ƒëang ƒë∆∞·ª£c focus

                const shapeIndex = shapesData.findIndex(s => s._internalId === shape._internalId);
                let shapeDisplayName = 'Unnamed Shape';
                if (shapeIndex !== -1) {
                    const identifiers = generateShapeIdentifiers(shapeIndex, 'Line'); // L·∫•y t√™n d·∫°ng 'L'
                    shapeDisplayName = identifiers.name;
                }

                console.log('Modal Open: Target title element:', shapeCanvasModalTitle);
                console.log('Modal Open: Current shape object:', shape);
                console.log('Modal Open: Shape name to display (from generateShapeIdentifiers):', shapeDisplayName);

                if (shapeCanvasModalTitle) {
                    shapeCanvasModalTitle.textContent = `Canvas Editor: ${shapeDisplayName}`;
                }
                shapeCanvasModal.style.display = 'flex';

                if (shapeDetailCanvas && modalCanvasContainer) {
                    let shapeDetailCtx = shapeDetailCanvas.getContext('2d');
                    const containerWidth = modalCanvasContainer.clientWidth;
                    const containerHeight = modalCanvasContainer.clientHeight;
                    shapeDetailCanvas.width = containerWidth > 20 ? containerWidth - 20 : 200; 
                    shapeDetailCanvas.height = containerHeight > 20 ? containerHeight - 20 : 150;

                    currentModalViewMode = 'oxy'; // ƒê·∫∑t l·∫°i view m·∫∑c ƒë·ªãnh khi m·ªü modal
                    setActiveViewButton('viewOxyBtn'); // Highlight n√∫t m·∫∑c ƒë·ªãnh

                    // Reset tr·∫°ng th√°i t∆∞∆°ng t√°c khi m·ªü modal
                    currentModalInteractionMode = 'none';
                    temporaryNewPoints = []; // Kh·ªüi t·∫°o m·∫£ng ƒëi·ªÉm t·∫°m th·ªùi
                    setActiveModalModeButton(null);
                    if (shapeDetailCanvas) shapeDetailCanvas.style.cursor = 'default';

                    // N·∫°p c√°c ƒëi·ªÉm hi·ªán c√≥ c·ªßa shape v√†o temporaryNewPoints ƒë·ªÉ hi·ªÉn th·ªã
                    if (currentEditingShapeInModal && currentEditingShapeInModal.v) {
                        console.log('[OpenModal] Loading existing vertices into temporaryNewPoints. Original vertices:', JSON.stringify(currentEditingShapeInModal.v));
                        for (const vertexId in currentEditingShapeInModal.v) {
                            if (Object.hasOwnProperty.call(currentEditingShapeInModal.v, vertexId)) {
                                const vCoords = currentEditingShapeInModal.v[vertexId]; // [x, y, z]
                                if (Array.isArray(vCoords) && vCoords.length === 3) {
                                    temporaryNewPoints.push({ x: vCoords[0], y: vCoords[1], z: vCoords[2], originalId: vertexId }); // L∆∞u originalId ƒë·ªÉ c√≥ th·ªÉ x·ª≠ l√Ω sau n√†y
                                } else {
                                    console.warn(`[OpenModal] Vertex ${vertexId} has invalid format:`, vCoords);
                                }
                            }
                        }
                        console.log('[OpenModal] temporaryNewPoints after loading existing vertices:', JSON.stringify(temporaryNewPoints));
                        // TODO: C·∫ßn c∆° ch·∫ø ƒë·ªÉ ph√¢n bi·ªát ƒëi·ªÉm c≈© v√† ƒëi·ªÉm m·ªõi khi L∆ØU ƒë·ªÉ tr√°nh nh√¢n b·∫£n.
                        // Hi·ªán t·∫°i, h√†m saveAndCloseModal s·∫Ω coi t·∫•t c·∫£ ƒëi·ªÉm trong temporaryNewPoints l√† ƒëi·ªÉm m·ªõi.
                    }

                    drawModalCanvas();
                } else {
                    if (!shapeDetailCanvas) console.error('shapeDetailCanvas not found');
                    if (!modalCanvasContainer) console.error('modalCanvasContainer not found');
                }

                if(modalInfoContent) {
                    modalInfoContent.innerHTML = `<h5>${shapeDisplayName}</h5>
                                        <p><strong>ID:</strong> ${shape._internalId}</p>
                                        <p><strong>Lo·∫°i:</strong> ${shape.type}</p>
                                        <p><strong>S·ªë ƒë·ªânh:</strong> ${Object.keys(shape.vertices).length}</p>
                                        <p><strong>S·ªë m·∫∑t:</strong> ${shape.faces ? shape.faces.length : 0}</p>
                                        <p><strong>S·ªë ƒë∆∞·ªùng:</strong> ${shape.lines ? shape.lines.length : 0}</p>
                                        <!-- Th√™m th√¥ng tin kh√°c n·∫øu c·∫ßn -->`;
                } else {
                    const modalInfoSection = document.getElementById('modalInfoSection');
                    if(modalInfoSection) modalInfoSection.innerHTML = '<p>L·ªói khi t·∫£i chi ti·∫øt shape.</p>';
                    else console.error('modalInfoContent and modalInfoSection not found');
                }
                if (modalClickedPointCoordsContainer) modalClickedPointCoordsContainer.style.display = 'none'; // ·∫®n input t·ªça ƒë·ªô
                if (modalPointXInput) modalPointXInput.value = '';
                if (modalPointYInput) modalPointYInput.value = '';
                if (modalPointZInput) modalPointZInput.value = '';
            });
        }

        function drawGridAndAxes(ctx, viewMode, canvasWidth, canvasHeight) {
            const gridSize = 20; // K√≠ch th∆∞·ªõc c·ªßa m·ªói √¥ l∆∞·ªõi
            const axisColor = '#FF0000'; // M√†u ƒë·ªè cho tr·ª•c
            const gridColor = '#CCCCCC'; // M√†u x√°m cho l∆∞·ªõi
            const textColor = '#000000'; // M√†u ƒëen cho ch·ªØ
            const originX = canvasWidth / 2;
            const originY = canvasHeight / 2;

            // V·∫Ω l∆∞·ªõi
            ctx.beginPath();
            ctx.strokeStyle = gridColor;
            ctx.lineWidth = 0.5;

            // ƒê∆∞·ªùng l∆∞·ªõi d·ªçc
            for (let x = originX + gridSize; x < canvasWidth; x += gridSize) {
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvasHeight);
            }
            for (let x = originX - gridSize; x > 0; x -= gridSize) {
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvasHeight);
            }
            // ƒê∆∞·ªùng l∆∞·ªõi ngang
            for (let y = originY + gridSize; y < canvasHeight; y += gridSize) {
                ctx.moveTo(0, y);
                ctx.lineTo(canvasWidth, y);
            }
            for (let y = originY - gridSize; y > 0; y -= gridSize) {
                ctx.moveTo(0, y);
                ctx.lineTo(canvasWidth, y);
            }
            ctx.stroke();

            // V·∫Ω tr·ª•c t·ªça ƒë·ªô
            ctx.beginPath();
            ctx.strokeStyle = axisColor;
            ctx.lineWidth = 2;
            ctx.fillStyle = textColor;
            ctx.font = '12px Arial';

            let labelX = 'X';
            let labelY = 'Y'; // Tr·ª•c d·ªçc tr√™n m√†n h√¨nh

            if (viewMode === 'oxy') {
                labelX = 'X';
                labelY = 'Y';
                // Tr·ª•c X (ngang)
                ctx.moveTo(0, originY);
                ctx.lineTo(canvasWidth, originY);
                ctx.fillText('X', canvasWidth - 15, originY - 5);
                // Tr·ª•c Y (d·ªçc, d∆∞∆°ng h∆∞·ªõng l√™n)
                ctx.moveTo(originX, canvasHeight);
                ctx.lineTo(originX, 0);
                ctx.fillText('Y', originX + 5, 15);
            } else if (viewMode === 'oxz') {
                labelX = 'X';
                labelY = 'Z';
                // Tr·ª•c X (ngang)
                ctx.moveTo(0, originY);
                ctx.lineTo(canvasWidth, originY);
                ctx.fillText('X', canvasWidth - 15, originY - 5);
                // Tr·ª•c Z (d·ªçc, d∆∞∆°ng h∆∞·ªõng l√™n)
                ctx.moveTo(originX, canvasHeight);
                ctx.lineTo(originX, 0);
                ctx.fillText('Z', originX + 5, 15);
            } else if (viewMode === 'oyz') {
                labelX = 'Y';
                labelY = 'Z';
                // Tr·ª•c Y (ngang)
                ctx.moveTo(0, originY);
                ctx.lineTo(canvasWidth, originY);
                ctx.fillText('Y', canvasWidth - 15, originY - 5);
                // Tr·ª•c Z (d·ªçc, d∆∞∆°ng h∆∞·ªõng l√™n)
                ctx.moveTo(originX, canvasHeight);
                ctx.lineTo(originX, 0);
                ctx.fillText('Z', originX + 5, 15);
            }
            ctx.stroke();

            // V·∫Ω g·ªëc O
            ctx.fillText('O', originX - 15, originY + 15);

            console.log(`Grid and axes drawn for view: ${viewMode}. Origin: (${originX},${originY}), Labels: (${labelX}, ${labelY})`);
        }

        function drawModalCanvas() {
            const canvas = document.getElementById('shapeDetailCanvas');
            if (!canvas) {
                console.error('drawModalCanvas: Canvas element #shapeDetailCanvas not found!');
                return;
            }
            if (!currentEditingShapeInModal) {
                console.warn('drawModalCanvas: currentEditingShapeInModal is null or undefined. Cannot draw.');
                return;
            }
            const ctx = canvas.getContext('2d');
            if (!ctx) {
                console.error('drawModalCanvas: Failed to get 2D context from canvas.');
                return;
            }
            console.log(`Attempting to draw modal canvas. View: ${currentModalViewMode}, Shape ID: ${currentEditingShapeInModal._internalId}, Canvas WxH: ${canvas.width}x${canvas.height}`);
            // X√≥a canvas tr∆∞·ªõc khi v·∫Ω l·∫°i
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGridAndAxes(ctx, currentModalViewMode, canvas.width, canvas.height);
            // TODO: G·ªçi drawShapeProjection(...)
            drawTemporaryPoints(ctx); // V·∫Ω c√°c ƒëi·ªÉm t·∫°m th·ªüi
            console.log(`Finished drawing grid/axes for view: ${currentModalViewMode}`);
        }

        function drawTemporaryPoints(ctx) {
            if (!temporaryNewPoints || temporaryNewPoints.length === 0) return;

            const canvas = document.getElementById('shapeDetailCanvas');
            if (!canvas) return;
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;
            const originX = canvasWidth / 2;
            const originY = canvasHeight / 2;

            ctx.fillStyle = 'blue'; // M√†u cho ƒëi·ªÉm t·∫°m th·ªüi
            ctx.strokeStyle = 'darkblue';
            ctx.lineWidth = 1;

            temporaryNewPoints.forEach(point3D => {
                let pX, pY;
                // Chuy·ªÉn ƒë·ªïi t·ª´ t·ªça ƒë·ªô 3D c·ªßa ƒëi·ªÉm t·∫°m th·ªüi sang 2D tr√™n canvas
                // d·ª±a tr√™n currentModalViewMode
                if (currentModalViewMode === 'oxy') {
                    pX = originX + point3D.x * PIXELS_PER_UNIT;
                    pY = originY - point3D.y * PIXELS_PER_UNIT; // Y ng∆∞·ª£c l·∫°i tr√™n canvas
                } else if (currentModalViewMode === 'oxz') {
                    pX = originX + point3D.x * PIXELS_PER_UNIT;
                    pY = originY - point3D.z * PIXELS_PER_UNIT; // Z thay cho Y
                } else if (currentModalViewMode === 'oyz') {
                    pX = originX + point3D.y * PIXELS_PER_UNIT; // Y thay cho X
                    pY = originY - point3D.z * PIXELS_PER_UNIT; // Z thay cho Y
                }
                
                pX = parseFloat(pX.toFixed(2));
                pY = parseFloat(pY.toFixed(2));

                ctx.beginPath();
                ctx.arc(pX, pY, 4, 0, 2 * Math.PI); // V·∫Ω m·ªôt ch·∫•m tr√≤n nh·ªè
                ctx.fill();
                ctx.stroke();
            });
        }

        function setActiveViewButton(activeButtonId) {
            const buttonIds = ['viewOxyBtn', 'viewOxzBtn', 'viewOyzBtn'];
            buttonIds.forEach(id => {
                const btn = document.getElementById(id);
                if (btn) {
                    btn.classList.remove('btn-primary');
                    btn.classList.add('btn-outline-secondary');
                }
            });
            const activeBtn = document.getElementById(activeButtonId);
            if (activeBtn) {
                activeBtn.classList.remove('btn-outline-secondary');
                activeBtn.classList.add('btn-primary');
            }
        }

        function setActiveModalModeButton(activeButtonId) {
            const buttonIds = ['modalAddBtn', 'modalMoveBtn']; // Th√™m ID c√°c n√∫t ch·∫ø ƒë·ªô kh√°c n·∫øu c√≥
            buttonIds.forEach(id => {
                const btn = document.getElementById(id);
                if (btn) {
                    btn.classList.remove('btn-primary'); // Gi·∫£ s·ª≠ active l√† 'btn-primary'
                    btn.classList.add('btn-outline-primary'); // Inactive l√† 'btn-outline-primary'
                }
            });
            if (activeButtonId) {
                const activeBtn = document.getElementById(activeButtonId);
                if (activeBtn) {
                    activeBtn.classList.remove('btn-outline-primary');
                    activeBtn.classList.add('btn-primary');
                }
            }
        }

        // Event listeners cho c√°c n√∫t View Control tr√™n Modal
        const viewOxyBtn = document.getElementById('viewOxyBtn');
        const viewOxzBtn = document.getElementById('viewOxzBtn');
        const viewOyzBtn = document.getElementById('viewOyzBtn');
        console.log('[ViewControlButtons] viewOxyBtn element:', viewOxyBtn);
        console.log('[ViewControlButtons] viewOxzBtn element:', viewOxzBtn);
        console.log('[ViewControlButtons] viewOyzBtn element:', viewOyzBtn);

        // Event listener cho n√∫t 'Th√™m' tr√™n Modal
        const modalMessage = document.getElementById('modalMessage'); // For error/info messages

        const modalClickedPointCoordsContainer = document.getElementById('modalClickedPointCoordsContainer');
        const modalPointXInput = document.getElementById('modalPointX');
        const modalPointYInput = document.getElementById('modalPointY');
        const modalPointZInput = document.getElementById('modalPointZ');

        const modalAddBtn = document.getElementById('modalAddBtn');
        const modalSaveBtn = document.getElementById('saveModalBtn');

        if (modalAddBtn) {
            modalAddBtn.addEventListener('click', () => {
                console.log('[ModalMode] Add button clicked.');
                currentModalInteractionMode = 'addPoint';
                setActiveModalModeButton('modalAddBtn');
                const canvas = document.getElementById('shapeDetailCanvas');
                if (canvas) {
                    canvas.style.cursor = 'crosshair';
                }
                // T·∫Øt highlight c·ªßa c√°c n√∫t view control n·∫øu c·∫ßn, ho·∫∑c ƒë·ªÉ ng∆∞·ªùi d√πng t·ª± ch·ªçn view tr∆∞·ªõc khi th√™m ƒëi·ªÉm
            });
        }

        // Event listener cho vi·ªác click tr√™n canvas ƒë·ªÉ th√™m ƒëi·ªÉm
        const shapeDetailCanvasForClick = document.getElementById('shapeDetailCanvas');
        if (shapeDetailCanvasForClick) {
            shapeDetailCanvasForClick.addEventListener('click', (event) => {
                if (currentModalInteractionMode !== 'addPoint' || !currentEditingShapeInModal) return;

                const canvasRect = shapeDetailCanvasForClick.getBoundingClientRect();
                
                // T·ªça ƒë·ªô chu·ªôt g·ªëc so v·ªõi viewport
                // console.log(`[DebugOffset] Mouse Click: clientX=${event.clientX}, clientY=${event.clientY}`);
                // console.log(`[DebugOffset] Canvas Rect: left=${canvasRect.left}, top=${canvasRect.top}, width=${canvasRect.width}, height=${canvasRect.height}`);

                // T·ªça ƒë·ªô chu·ªôt so v·ªõi g√≥c tr√™n b√™n tr√°i c·ªßa ph·∫ßn t·ª≠ canvas
                let mouseX_relative_to_canvas_element = event.clientX - canvasRect.left;
                let mouseY_relative_to_canvas_element = event.clientY - canvasRect.top;

                // console.log(`[DebugOffset] Mouse relative to canvas element: x=${mouseX_relative_to_canvas_element}, y=${mouseY_relative_to_canvas_element}`);
                // console.log(`[DebugOffset] Canvas drawing surface size: width=${shapeDetailCanvasForClick.width}, height=${shapeDetailCanvasForClick.height}`);

                // ƒêi·ªÅu ch·ªânh t·ªça ƒë·ªô chu·ªôt n·∫øu k√≠ch th∆∞·ªõc hi·ªÉn th·ªã c·ªßa canvas kh√°c v·ªõi k√≠ch th∆∞·ªõc b·ªÅ m·∫∑t v·∫Ω
                // (v√≠ d·ª•: khi canvas ƒë∆∞·ª£c scale b·∫±ng CSS)
                const scaleX = shapeDetailCanvasForClick.width / canvasRect.width;
                const scaleY = shapeDetailCanvasForClick.height / canvasRect.height;
                
                const finalCanvasX = mouseX_relative_to_canvas_element * scaleX;
                const finalCanvasY = mouseY_relative_to_canvas_element * scaleY;

                // console.log(`[DebugOffset] Scaling factors: scaleX=${scaleX}, scaleY=${scaleY}`);
                // console.log(`[DebugOffset] Final scaled mouse coords on canvas: x=${finalCanvasX}, y=${finalCanvasY}`);

                const originCanvasX = shapeDetailCanvasForClick.width / 2;
                const originCanvasY = shapeDetailCanvasForClick.height / 2;

                let point3D = { x: 0, y: 0, z: 0 };

                if (currentModalViewMode === 'oxy') {
                    point3D.x = (finalCanvasX - originCanvasX) / PIXELS_PER_UNIT;
                    point3D.y = (originCanvasY - finalCanvasY) / PIXELS_PER_UNIT;
                    point3D.z = 0;
                } else if (currentModalViewMode === 'oxz') {
                    point3D.x = (finalCanvasX - originCanvasX) / PIXELS_PER_UNIT;
                    point3D.z = (originCanvasY - finalCanvasY) / PIXELS_PER_UNIT;
                    point3D.y = 0;
                } else if (currentModalViewMode === 'oyz') {
                    point3D.y = (finalCanvasX - originCanvasX) / PIXELS_PER_UNIT;
                    point3D.z = (originCanvasY - finalCanvasY) / PIXELS_PER_UNIT;
                    point3D.x = 0;
                }
                
                point3D.x = parseFloat(point3D.x.toFixed(2));
                point3D.y = parseFloat(point3D.y.toFixed(2));
                point3D.z = parseFloat(point3D.z.toFixed(2));

                // console.log(`[DebugOffset] World coords before PIXELS_PER_UNIT: x_raw=${(finalCanvasX - originCanvasX)}, y_raw=${(originCanvasY - finalCanvasY)} (for Oxy)`);
                console.log(`[AddPoint] Attempting to add point. Mode: ${currentModalViewMode}, OrigCanvas:(${originCanvasX.toFixed(2)},${originCanvasY.toFixed(2)}), FinalCanvasClick:(${finalCanvasX.toFixed(2)},${finalCanvasY.toFixed(2)}), PIXELS: ${PIXELS_PER_UNIT}`);
                console.log('[AddPoint] Calculated 3D point:', point3D);

                temporaryNewPoints.push(point3D);
                drawModalCanvas();
                selectedTemporaryPointIndex = temporaryNewPoints.length - 1;
                console.log(`[CanvasClick] Added temporary point: (${point3D.x}, ${point3D.y}, ${point3D.z}), view: ${currentModalViewMode}. Index: ${selectedTemporaryPointIndex}`);
                // drawTemporaryPoints(shapeCanvasCtx); // ƒê√£ ƒë∆∞·ª£c g·ªçi trong drawModalCanvas(), kh√¥ng c·∫ßn g·ªçi l·∫°i ·ªü ƒë√¢y

                // Hi·ªÉn th·ªã v√† ƒëi·ªÅn d·ªØ li·ªáu v√†o input t·ªça ƒë·ªô
                console.log('[CanvasClick] Attempting to show coordinate inputs. Current mode:', currentModalInteractionMode);
                console.log('[CanvasClick] modalClickedPointCoordsContainer exists:', !!modalClickedPointCoordsContainer);
                if (modalClickedPointCoordsContainer) {
                    modalClickedPointCoordsContainer.style.display = 'block';
                    // S·ª≠ d·ª•ng getComputedStyle ƒë·ªÉ ki·ªÉm tra style th·ª±c t·∫ø ƒë∆∞·ª£c √°p d·ª•ng
                    console.log('[CanvasClick] Set display to block. Computed display style:', window.getComputedStyle(modalClickedPointCoordsContainer).display);
                } else {
                    console.error('[CanvasClick] modalClickedPointCoordsContainer is null or undefined!');
                }

                if (modalPointXInput) modalPointXInput.value = point3D.x.toFixed(2);
                if (modalPointYInput) modalPointYInput.value = point3D.y.toFixed(2);
                if (modalPointZInput) modalPointZInput.value = point3D.z.toFixed(2);
                console.log('[CanvasClick] Populated input fields.');

                // G·∫Øn (ho·∫∑c c·∫≠p nh·∫≠t) event listeners
                [modalPointXInput, modalPointYInput, modalPointZInput].forEach(input => {
                    if (input) {
                        // G·ª° b·ªè listener c≈© ƒë·ªÉ tr√°nh b·ªã g·ªçi nhi·ªÅu l·∫ßn
                        input.removeEventListener('input', updateTemporaryPointFromInputs);
                        input.addEventListener('input', updateTemporaryPointFromInputs);
                    }
                });
            });
        }

        if (viewOxyBtn) {
            viewOxyBtn.addEventListener('click', () => {
                console.log('[ViewControl] viewOxyBtn clicked. Current shape:', currentEditingShapeInModal, 'Mode before change:', currentModalViewMode);
                if (!currentEditingShapeInModal) {
                    console.warn('[ViewControl] viewOxyBtn: No currentEditingShapeInModal. Aborting.');
                    return;
                }
                currentModalViewMode = 'oxy';
                console.log('[ViewControl] viewOxyBtn: Mode set to oxy. Calling setActiveViewButton and drawModalCanvas.');
                setActiveViewButton('viewOxyBtn');
                drawModalCanvas();
            });
        }
        if (viewOxzBtn) {
            viewOxzBtn.addEventListener('click', () => {
                console.log('[ViewControl] viewOxzBtn clicked. Current shape:', currentEditingShapeInModal, 'Mode before change:', currentModalViewMode);
                if (!currentEditingShapeInModal) {
                    console.warn('[ViewControl] viewOxzBtn: No currentEditingShapeInModal. Aborting.');
                    return;
                }
                currentModalViewMode = 'oxz';
                console.log('[ViewControl] viewOxzBtn: Mode set to oxz. Calling setActiveViewButton and drawModalCanvas.');
                setActiveViewButton('viewOxzBtn');
                drawModalCanvas();
            });
        }
        if (viewOyzBtn) {
            viewOyzBtn.addEventListener('click', () => {
                console.log('[ViewControl] viewOyzBtn clicked. Current shape:', currentEditingShapeInModal, 'Mode before change:', currentModalViewMode);
                if (!currentEditingShapeInModal) {
                    console.warn('[ViewControl] viewOyzBtn: No currentEditingShapeInModal. Aborting.');
                    return;
                }
                currentModalViewMode = 'oyz';
                console.log('[ViewControl] viewOyzBtn: Mode set to oyz. Calling setActiveViewButton and drawModalCanvas.');
                setActiveViewButton('viewOyzBtn');
                drawModalCanvas();
            });
        }

        window.addEventListener('keydown', (event) => {
            const shapeCanvasModal = document.getElementById('shapeCanvasModal');
            if (event.key === 'Escape' && shapeCanvasModal && shapeCanvasModal.style.display === 'flex') {
                closeShapeEditorModal();
            }
        });
    }); // ƒê√≥ng DOMContentLoaded listener
        
    </script>
    <!-- Fullscreen Shape Canvas Modal -->
    <div id="shapeCanvasModal" class="fullscreen-modal">
        <div class="modal-content-wrapper">
            <div class="modal-header-controls">
                 <h5 id="shapeCanvasModalTitle">Shape Canvas Editor</h5>
                 <div class="modal-header-button-groups" style="display: flex; gap: 15px; margin: 0 auto;">
                    <div class="btn-group btn-group-sm" role="group" aria-label="View Controls">
                        <button type="button" class="btn btn-outline-secondary" id="viewOxyBtn" title="Ch·∫ø ƒë·ªô xem Oxy">Oxy</button>
                        <button type="button" class="btn btn-outline-secondary" id="viewOxzBtn" title="Ch·∫ø ƒë·ªô xem Oxz">Oxz</button>
                        <button type="button" class="btn btn-outline-secondary" id="viewOyzBtn" title="Ch·∫ø ƒë·ªô xem Oyz">Oyz</button>
                    </div>
                    <div class="btn-group btn-group-sm" role="group" aria-label="Action Controls">
                        <button type="button" class="btn btn-outline-primary" id="modalAddBtn" title="Th√™m ƒë·ªëi t∆∞·ª£ng">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-plus-lg" viewBox="0 0 16 16">
                                <path fill-rule="evenodd" d="M8 2a.5.5 0 0 1 .5.5v5h5a.5.5 0 0 1 0 1h-5v5a.5.5 0 0 1-1 0v-5h-5a.5.5 0 0 1 0-1h5v-5A.5.5 0 0 1 8 2Z"/>
                            </svg> Th√™m
                        </button>
                        <button type="button" class="btn btn-outline-primary" id="modalMoveBtn" title="Di chuy·ªÉn ƒë·ªëi t∆∞·ª£ng">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-arrows-move" viewBox="0 0 16 16">
                                <path fill-rule="evenodd" d="M7.646.146a.5.5 0 0 1 .708 0l2 2a.5.5 0 0 1-.708.708L8.5 1.707V5.5a.5.5 0 0 1-1 0V1.707L6.354 2.854a.5.5 0 1 1-.708-.708l2-2zM8 10a.5.5 0 0 1 .5.5v3.793l1.146-1.147a.5.5 0 0 1 .708.708l-2 2a.5.5 0 0 1-.708 0l-2-2a.5.5 0 0 1 .708-.708L7.5 14.293V10.5A.5.5 0 0 1 8 10zM.146 8.354a.5.5 0 0 1 0-.708l2-2a.5.5 0 1 1 .708.708L1.707 7.5H5.5a.5.5 0 0 1 0 1H1.707l1.147 1.146a.5.5 0 1 1-.708.708l-2-2zM10 8a.5.5 0 0 1 .5-.5h3.793l-1.147-1.146a.5.5 0 0 1 .708-.708l2 2a.5.5 0 0 1 0 .708l-2 2a.5.5 0 0 1-.708-.708L14.293 8.5H10.5A.5.5 0 0 1 10 8z"/>
                            </svg> Di chuy·ªÉn
                        </button>
                    </div>
                 </div>
                 <div class="btn-group btn-group-sm" role="group" aria-label="Save Cancel Controls">
                        <button type="button" class="btn btn-success" id="saveModalBtn" onclick="saveAndCloseModal()" title="L∆∞u thay ƒë·ªïi">L∆∞u</button>
                        <button type="button" class="btn btn-secondary" id="cancelModalBtn" onclick="closeShapeEditorModal()" title="H·ªßy b·ªè">H·ªßy</button>
                    </div>
            </div>
            <div class="modal-main-content">
                <div id="modalCanvasContainer" class="modal-canvas-section">
                    <canvas id="shapeDetailCanvas"></canvas>
                </div>
                <div id="modalInfoSection" class="modal-info-section">
                    <div id="modalInfoContent"> <!-- Div for dynamic content -->
                       <h4>Th√¥ng tin</h4>
                       <p>N·ªôi dung th√¥ng tin s·∫Ω ƒë∆∞·ª£c hi·ªÉn th·ªã ·ªü ƒë√¢y khi m·ªôt shape ƒë∆∞·ª£c ch·ªçn v√† modal ƒë∆∞·ª£c m·ªü.</p>
                       <div id="modalClickedPointCoordsContainer" style="display:none; margin-top: 10px;">
                           <h5>T·ªça ƒë·ªô ƒëi·ªÉm ƒëang ch·ªçn:</h5>
                           <div>
                               <label for="modalPointX" style="display: inline-block; width: 20px;">X:</label>
                               <input type="number" id="modalPointX" step="any" style="width: calc(100% - 30px); margin-bottom: 5px;">
                           </div>
                           <div>
                               <label for="modalPointY" style="display: inline-block; width: 20px;">Y:</label>
                               <input type="number" id="modalPointY" step="any" style="width: calc(100% - 30px); margin-bottom: 5px;">
                           </div>
                           <div>
                               <label for="modalPointZ" style="display: inline-block; width: 20px;">Z:</label>
                               <input type="number" id="modalPointZ" step="any" style="width: calc(100% - 30px);">
                           </div>
                       </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</body>

</html>