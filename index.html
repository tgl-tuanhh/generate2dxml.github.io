<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kitect 3D JSON Studio</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            /* NgƒÉn cu·ªôn ·ªü body */
        }

        header {
            background-color: #333;
            color: white;
            padding: 10px 20px;
            text-align: center;
            position: relative;
            /* ƒê·∫£m b·∫£o absolute positioning c·ªßa children l√† relative to header */
            display: flex;
            /* S·ª≠ d·ª•ng Flexbox */
            justify-content: space-between;
            /* CƒÉn ƒë·ªÅu c√°c nh√≥m controls */
            align-items: center;
            /* CƒÉn gi·ªØa theo chi·ªÅu d·ªçc */
        }

        header button {
            /* Style chung cho c√°c button trong header */
            padding: 6px 12px;
            background-color: #007bff;
            font-size: 0.9em;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            margin-left: 5px;
            /* Kho·∫£ng c√°ch gi·ªØa c√°c button trong c√πng m·ªôt nh√≥m */
        }

        header button:hover {
            background-color: #0056b3;
        }

        .header-controls-group {
            display: flex;
            /* Cho ph√©p c√°c button trong nh√≥m n·∫±m tr√™n m·ªôt h√†ng */
            align-items: center;
        }

        /* C√≥ th·ªÉ th√™m style c·ª• th·ªÉ cho input-controls v√† output-controls n·∫øu c·∫ßn */
        #create2DXmlBtn {
            background-color: red;
        }

        .main-container {
            display: flex;
            flex-grow: 1;
            overflow: hidden;
            /* Cho ph√©p c√°c panel con cu·ªôn */
            padding: 10px;
            gap: 10px;
        }

        .panel {
            background-color: white;
            border-radius: 5px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.1);
            padding: 15px;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            /* Cho ph√©p cu·ªôn n·ªôi dung panel */
        }

        #shapes-panel {
            flex: 0 0 250px;
            /* ƒê·ªô r·ªông c·ªë ƒë·ªãnh cho panel shapes */
        }

        #editor-panel {
            flex-grow: 1;
            /* Panel editor chi·∫øm ph·∫ßn c√≤n l·∫°i */
        }

        #viewer-3d-panel {
            flex-grow: 2;
            /* Cho panel 3D chi·∫øm nhi·ªÅu kh√¥ng gian h∆°n */
            min-width: 300px;
            /* ƒê·∫£m b·∫£o c√≥ kh√¥ng gian t·ªëi thi·ªÉu cho view 3D */
            position: relative;
            /* ƒê·ªÉ canvas c√≥ th·ªÉ ƒë∆∞·ª£c ƒë·ªãnh v·ªã tuy·ªát ƒë·ªëi b√™n trong */
        }

        #viewer-3d-panel canvas {
            display: block;
            /* Lo·∫°i b·ªè kho·∫£ng tr·∫Øng th·ª´a b√™n d∆∞·ªõi canvas */
            width: 100% !important;
            /* Ghi ƒë√® style m·∫∑c ƒë·ªãnh c·ªßa three.js n·∫øu c√≥ */
            height: 100% !important;
        }

        textarea {
            width: calc(100% - 10px);
            /* ƒêi·ªÅu ch·ªânh ƒë·ªÉ padding kh√¥ng l√†m v·ª° layout */
            flex-grow: 1;
            margin-top: 10px;
            border: 1px solid #ccc;
            border-radius: 3px;
            padding: 5px;
            font-family: monospace;
            resize: none;
            /* Kh√¥ng cho ph√©p resize textarea */
        }

        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 3px;
            cursor: pointer;
            margin-top: 5px;
            margin-bottom: 10px;
        }

        button:hover {
            background-color: #0056b3;
        }

        .shape-item {
            padding: 8px;
            border: 1px solid #eee;
            border-radius: 3px;
            margin-bottom: 5px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .shape-item:hover,
        .shape-item.selected {
            background-color: #e9ecef;
        }

        .shape-item button {
            background-color: #dc3545;
            padding: 3px 6px;
            font-size: 0.8em;
            margin: 0;
        }

        .shape-item button:hover {
            background-color: #c82333;
        }

        .section {
            margin-bottom: 15px;
            border: 1px solid #ddd;
            padding: 10px;
            border-radius: 3px;
        }

        .section h3 {
            margin-top: 0;
            font-size: 1.1em;
            color: #333;
        }

        label {
            display: block;
            margin-bottom: 3px;
            font-size: 0.9em;
            color: #555;
        }

        input[type="text"],
        input[type="number"] {
            width: calc(100% - 12px);
            /* width - padding */
            padding: 5px;
            margin-bottom: 8px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }

        .vertex-entry,
        .face-entry,
        .line-entry {
            display: flex;
            gap: 5px;
            align-items: center;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        .vertex-entry input[type="number"] {
            width: 50px;
        }

        .face-entry input[type="text"] {
            flex-grow: 1;
        }

        .vertex-list,
        .face-list,
        .line-list {
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid #eee;
            padding: 5px;
            margin-bottom: 10px;
        }

        .hidden {
            display: none;
        }
    </style>
</head>

<body>
    <header>
        <h1>Kitect 3D JSON Studio</h1>
        <div class="header-controls-group input-controls">
            <input type="text" id="objectNameInput" placeholder="Nh·∫≠p Object Name (v√≠ d·ª•: PFHP-PILLAR-B)"
                style="margin-right: 10px; padding: 6px; border-radius: 3px; border: 1px solid #ccc;">
            <button id="importJsonBtn">ƒê·ªçc Clipboard</button>
        </div>
        <div class="header-controls-group default-settings-controls">
            <input type="text" id="defaultStdMaterialInput" placeholder="Default Std Material"
                style="margin-right: 5px; padding: 6px; border-radius: 3px; border: 1px solid #ccc; width: 150px;">
            <label style="margin-right: 5px; color: white;"><input type="checkbox" id="defaultDeformStretch2Checkbox"
                    checked> Stretch2</label>
            <label style="margin-right: 10px; color: white;"><input type="checkbox" id="defaultDeformClippingCheckbox">
                Clipping</label>
            <button id="applyDefaultsBtn" style="background-color: #28a745;">√Åp d·ª•ng cho t·∫•t c·∫£</button>
        </div>
        <div class="header-controls-group output-controls">
            <button id="copyLineGeometryBtn">Copy Line Geometry</button>
            <button id="copyStdGeometryBtn">Copy Std Geometry</button>
            <button id="copyLineMeshBtn">Copy Line Mesh</button>
            <button id="copyStdMeshBtn">Copy Std Mesh</button>
            <button id="create2DXmlBtn" onclick="window.open('./generate-2d-xml.html', '_blank')">Create 2D XML</button>
        </div>
    </header>
    <div class="main-container">
        <div id="shapes-panel" class="panel">
            <h2>Shapes</h2>
            <button id="addShapeBtn">Th√™m Shape M·ªõi</button>
            <div id="shapesListContainer">
                <!-- Danh s√°ch shapes s·∫Ω ƒë∆∞·ª£c th√™m v√†o ƒë√¢y b·∫±ng JavaScript -->
            </div>
            <div id="noShapeSelectedMsg">
                <p>Vui l√≤ng ch·ªçn m·ªôt shape t·ª´ danh s√°ch ho·∫∑c th√™m shape m·ªõi ƒë·ªÉ b·∫Øt ƒë·∫ßu ch·ªânh s·ª≠a.</p>
            </div>
        </div>

        <div id="editor-panel" class="panel">
            <h2>Editor</h2>
            <div id="shapeEditorContainer" class="hidden">
                <div class="section">
                    <h3>Th√¥ng tin Shape</h3>
                    <p><strong>T√™n Shape (Line Mode):</strong> <span id="generatedShapeNameLine"></span></p>
                    <p><strong>T√™n Shape (Std Mode):</strong> <span id="generatedShapeNameStd"></span></p>

                    <label for="stdMaterialInput">Std Material:</label>
                    <input type="text" id="stdMaterialInput" placeholder="V√≠ d·ª•: R110-0">

                    <h4>Deform Types</h4>
                    <div style="margin-bottom: 10px;">
                        <label style="display: inline-block; margin-right: 10px;">
                            <input type="checkbox" id="deformStretch2Checkbox"> Stretch2
                        </label>
                        <label style="display: inline-block;">
                            <input type="checkbox" id="deformClippingCheckbox"> Clipping
                        </label>
                    </div>
                    <div style="margin-bottom: 10px; font-size: 0.9em; color: #333;">
                        <strong>Current Deform Types:</strong> <span id="currentDeformTypesText"></span>
                    </div>

                    <h4>Custom Pivot (T·ªça ƒë·ªô Local c·ªßa Shape)</h4>
                    <div style="display: flex; gap: 5px; margin-bottom: 10px;">
                        <div style="flex: 1;">
                            <label for="pivotX">Pivot X:</label>
                            <input type="number" id="pivotX" value="0" step="1">
                        </div>
                        <div style="flex: 1;">
                            <label for="pivotY">Pivot Y:</label>
                            <input type="number" id="pivotY" value="0" step="1">
                        </div>
                        <div style="flex: 1;">
                            <label for="pivotZ">Pivot Z:</label>
                            <input type="number" id="pivotZ" value="0" step="1">
                        </div>
                    </div>
                </div>

                <div class="section">
                    <h3>Vertices (v)</h3>
                    <button id="addVertexBtn">Th√™m Vertex</button>
                    <div class="vertex-list" id="verticesList">
                        <!-- Vertices s·∫Ω ƒë∆∞·ª£c th√™m v√†o ƒë√¢y -->
                    </div>
                </div>

                <div class="section">
                    <h3>Faces</h3>
                    <label for="faceVertices">Vertices (ch·ªâ s·ªë, c√°ch nhau b·ªüi d·∫•u ph·∫©y):</label>
                    <input type="text" id="faceVertices" placeholder="V√≠ d·ª•: 0,1,13,12">
                    <button id="addFaceBtn">Th√™m Face</button>
                    <div class="face-list" id="facesListContainer">
                        <!-- Faces s·∫Ω ƒë∆∞·ª£c th√™m v√†o ƒë√¢y -->
                    </div>
                </div>

                <div class="section">
                    <h3>Lines</h3>
                    <label for="lineVerticesInput">Vertices (ID ƒë·ªânh 1, ID ƒë·ªânh 2, c√°ch nhau b·ªüi d·∫•u ph·∫©y):</label>
                    <input type="text" id="lineVerticesInput" placeholder="V√≠ d·ª•: 0,1">
                    <button id="addLineBtn">Th√™m Line</button>
                    <div class="line-list" id="linesListContainer">
                        <!-- Lines s·∫Ω ƒë∆∞·ª£c th√™m v√†o ƒë√¢y -->
                    </div>
                </div>

                <div class="section" id="transformationsSection">
                    <h3>Ph√©p bi·∫øn ƒë·ªïi (Transformations)</h3>

                    <div class="subsection">
                        <h4>T·ªãnh ti·∫øn (Translate)</h4>
                        <label for="translateX">Delta X:</label>
                        <input type="number" id="translateX" value="0" step="1">
                        <label for="translateY">Delta Y:</label>
                        <input type="number" id="translateY" value="0" step="1">
                        <label for="translateZ">Delta Z:</label>
                        <input type="number" id="translateZ" value="0" step="1">
                        <button id="applyTranslateBtn">√Åp d·ª•ng T·ªãnh ti·∫øn</button>
                    </div>

                    <div class="subsection">
                        <h4>Xoay quanh t√¢m Shape (Rotate around Shape Center)</h4>
                        <p style="font-size:0.8em; color:#555;">ƒê∆°n v·ªã: ƒê·ªô. Th·ª© t·ª± xoay: X -> Y -> Z.</p>
                        <label for="rotateX">G√≥c X:</label>
                        <input type="number" id="rotateX" value="0" step="1">
                        <label for="rotateY">G√≥c Y:</label>
                        <input type="number" id="rotateY" value="0" step="1">
                        <label for="rotateZ">G√≥c Z:</label>
                        <input type="number" id="rotateZ" value="0" step="1">
                        <button id="applyRotateBtn">√Åp d·ª•ng Xoay</button>
                    </div>

                    <div class="subsection">
                        <h4>L·∫≠t qua t√¢m Shape (Flip around Shape Center)</h4>
                        <button id="flipXBtn">L·∫≠t qua tr·ª•c X (YZ plane)</button>
                        <button id="flipYBtn">L·∫≠t qua tr·ª•c Y (XZ plane)</button>
                        <button id="flipZBtn">L·∫≠t qua tr·ª•c Z (XY plane)</button>
                    </div>
                </div>

            </div>
        </div>

        <div id="viewer-3d-panel" class="panel">
            <h2>3D View</h2>
            <div id="threejs-canvas-container" style="width: 100%; height: calc(100% - 40px);">
                <!-- Canvas cho Three.js s·∫Ω ƒë∆∞·ª£c th√™m v√†o ƒë√¢y -->
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/lines/LineSegmentsGeometry.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/lines/LineMaterial.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/lines/LineSegments2.js"></script>
    <script>
        // State c·ªßa ·ª©ng d·ª•ng
        let shapesData = [];
        let selectedShapeId = null; // S·∫Ω l∆∞u _internalId c·ªßa shape ƒë∆∞·ª£c ch·ªçn
        let currentJsonString = ''; // L∆∞u tr·ªØ chu·ªói JSON hi·ªán t·∫°i (ch·ªß y·∫øu cho Line Geometry v√† 3D view)
        let currentObjectName = ''; // L∆∞u tr·ªØ Object Name

        // DOM Elements
        const addShapeBtn = document.getElementById('addShapeBtn');
        const shapesListContainer = document.getElementById('shapesListContainer');
        const importJsonBtn = document.getElementById('importJsonBtn');
        const copyLineGeometryBtn = document.getElementById('copyLineGeometryBtn');
        const copyStdGeometryBtn = document.getElementById('copyStdGeometryBtn');
        const copyLineMeshBtn = document.getElementById('copyLineMeshBtn');
        const copyStdMeshBtn = document.getElementById('copyStdMeshBtn');
        const objectNameInput = document.getElementById('objectNameInput');

        const shapeEditorContainer = document.getElementById('shapeEditorContainer');
        const noShapeSelectedMsg = document.getElementById('noShapeSelectedMsg');
        const generatedShapeNameLine = document.getElementById('generatedShapeNameLine');
        const generatedShapeNameStd = document.getElementById('generatedShapeNameStd');
        const stdMaterialInput = document.getElementById('stdMaterialInput');

        const addVertexBtn = document.getElementById('addVertexBtn');
        const verticesListContainer = document.getElementById('verticesList');

        const addFaceBtn = document.getElementById('addFaceBtn');
        const faceVerticesInput = document.getElementById('faceVertices');
        const facesListContainer = document.getElementById('facesListContainer');

        const addLineBtn = document.getElementById('addLineBtn');
        const lineVerticesInput = document.getElementById('lineVerticesInput');
        const linesListContainer = document.getElementById('linesListContainer');

        // Transformation UI Elements
        const translateXInput = document.getElementById('translateX');
        const translateYInput = document.getElementById('translateY');
        const translateZInput = document.getElementById('translateZ');
        const applyTranslateBtn = document.getElementById('applyTranslateBtn');
        const rotateXInput = document.getElementById('rotateX');
        const rotateYInput = document.getElementById('rotateY');
        const rotateZInput = document.getElementById('rotateZ');
        const applyRotateBtn = document.getElementById('applyRotateBtn');
        const flipXBtn = document.getElementById('flipXBtn');
        const flipYBtn = document.getElementById('flipYBtn');
        const flipZBtn = document.getElementById('flipZBtn');

        const currentDeformTypesText = document.getElementById('currentDeformTypesText');

        const threeJsCanvasContainer = document.getElementById('threejs-canvas-container');

        // Three.js specific variables
        let scene, camera, renderer, controls, shapesGroup;
        let vertexLabelsGroup; // Group cho c√°c nh√£n ID ƒë·ªânh
        let threeShapeObjects = {}; // Map t·ª´ shape._internalId sang { group, lineMaterial, faceMaterial, labelMaterial }

        // Materials for highlighting
        const NORMAL_LINE_COLOR = 0x0000ff;
        const HIGHLIGHTED_LINE_COLOR = 0x007bff; // Changed to Blue
        const NORMAL_FACE_COLOR = 0xcccccc;
        const HIGHLIGHTED_FACE_COLOR = 0xffd700; // Gold
        const NORMAL_LABEL_BG_COLOR = { r: 50, g: 50, b: 50, a: 0.7 };
        const HIGHLIGHTED_LABEL_BG_COLOR = { r: 255, g: 165, b: 0, a: 0.9 }; // Orange background for labels

        // Th√™m l·∫°i c√°c khai b√°o bi·∫øn b·ªã thi·∫øu
        const deformStretch2Checkbox = document.getElementById('deformStretch2Checkbox');
        const deformClippingCheckbox = document.getElementById('deformClippingCheckbox'); // ID n√†y ƒë√£ ƒë∆∞·ª£c ƒë·ªïi t·ª´ deformClipCheckbox
        const pivotXInput = document.getElementById('pivotX');
        const pivotYInput = document.getElementById('pivotY');
        const pivotZInput = document.getElementById('pivotZ');

        const defaultStdMaterialInput = document.getElementById('defaultStdMaterialInput');
        const defaultDeformStretch2Checkbox = document.getElementById('defaultDeformStretch2Checkbox');
        const defaultDeformClippingCheckbox = document.getElementById('defaultDeformClippingCheckbox');
        const applyDefaultsBtn = document.getElementById('applyDefaultsBtn');

        // --- Helper function to create text sprites (moved to a more global scope) ---
        function createTextSprite(message, parameters) {
            parameters = parameters || {};
            const fontface = parameters.fontface || 'Arial';
            const internalFontsize = parameters.internalFontsize || 32; // Fontsize v·∫Ω l√™n canvas
            const borderThickness = parameters.borderThickness || 2;
            const borderColor = parameters.borderColor || { r: 0, g: 0, b: 0, a: 1.0 };
            const backgroundColor = parameters.backgroundColor || { r: 255, g: 255, b: 255, a: 0.8 };
            const textColor = parameters.textColor || { r: 0, g: 0, b: 0, a: 1.0 };

            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');

            context.font = 'Bold ' + internalFontsize + 'px ' + fontface;
            const metrics = context.measureText(message);
            const textWidth = metrics.width;

            canvas.width = textWidth + borderThickness * 2 + 20; // Th√™m padding cho canvas
            canvas.height = internalFontsize * 1.4 + borderThickness * 2;

            context.font = 'Bold ' + internalFontsize + 'px ' + fontface;
            context.fillStyle = `rgba(${backgroundColor.r},${backgroundColor.g},${backgroundColor.b},${backgroundColor.a})`;
            context.strokeStyle = `rgba(${borderColor.r},${borderColor.g},${borderColor.b},${borderColor.a})`;
            context.lineWidth = borderThickness;

            context.fillStyle = `rgba(${textColor.r},${textColor.g},${textColor.b},${textColor.a})`;
            context.fillText(message, borderThickness + 5, internalFontsize + borderThickness);

            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter; // Th√™m magFilter cho nh·∫•t qu√°n
            texture.wrapS = THREE.ClampToEdgeWrapping;
            texture.wrapT = THREE.ClampToEdgeWrapping;

            const spriteMaterial = new THREE.SpriteMaterial({
                map: texture,
                sizeAttenuation: false, // THAY ƒê·ªîI ·ªû ƒê√ÇY: k√≠ch th∆∞·ªõc kh√¥ng ƒë·ªïi khi zoom
                transparent: true, // Cho ph√©p background trong su·ªët n·∫øu alpha < 1
                alphaTest: 0.1 // ƒê·ªÉ c√°c pixel g·∫ßn nh∆∞ trong su·ªët ho√†n to√†n kh√¥ng ƒë∆∞·ª£c v·∫Ω
            });
            const sprite = new THREE.Sprite(spriteMaterial);

            // ƒêi·ªÅu ch·ªânh scale ƒë·ªÉ sprite c√≥ chi·ªÅu cao mong mu·ªën 
            // Khi sizeAttenuation = false, scale n√†y s·∫Ω tr·ª±c ti·∫øp ·∫£nh h∆∞·ªüng ƒë·∫øn k√≠ch th∆∞·ªõc hi·ªÉn th·ªã tr√™n m√†n h√¨nh.
            // B·∫°n c√≥ th·ªÉ c·∫ßn ƒëi·ªÅu ch·ªânh gi√° tr·ªã n√†y ƒë·ªÉ ƒë·∫°t ƒë∆∞·ª£c k√≠ch th∆∞·ªõc mong mu·ªën.
            const desiredScreenHeightFactor = parameters.worldHeight || 50; // C√≥ th·ªÉ c·∫ßn ƒë·ªïi t√™n v√† gi√° tr·ªã
            // T·∫°m th·ªùi gi·ªØ nguy√™n logic scale c≈©, nh∆∞ng c√≥ th·ªÉ c·∫ßn ƒëi·ªÅu ch·ªânh l·∫°i 'desiredScreenHeightFactor'
            // ho·∫∑c c√°ch t√≠nh to√°n scale cho ph√π h·ª£p v·ªõi sizeAttenuation = false.
            // V√≠ d·ª•, b·∫°n c√≥ th·ªÉ mu·ªën ƒë·∫∑t m·ªôt scale c·ªë ƒë·ªãnh:
            // sprite.scale.set(50, 25, 1); // V√≠ d·ª•: r·ªông 50 units, cao 25 units tr√™n m√†n h√¨nh (c·∫ßn th·ª≠ nghi·ªám)
            sprite.scale.set((desiredScreenHeightFactor * canvas.width / canvas.height), desiredScreenHeightFactor, 1.0);

            return sprite;
        }

        // --- UUID Generation ---
        function generateUUID() {
            // Basic UUID v4 generator
            return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>
                (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
            );
        }

        // --- 3D Viewer Initialization ---
        function init3DViewer() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xeeeeee);

            // Camera
            const aspect = threeJsCanvasContainer.clientWidth / threeJsCanvasContainer.clientHeight;
            camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 10000);
            camera.position.set(100, 100, 500); // ƒêi·ªÅu ch·ªânh v·ªã tr√≠ camera cho ph√π h·ª£p v·ªõi d·ªØ li·ªáu c·ªßa b·∫°n
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(threeJsCanvasContainer.clientWidth, threeJsCanvasContainer.clientHeight);
            threeJsCanvasContainer.appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(200, 500, 300);
            scene.add(directionalLight);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 10;
            controls.maxDistance = 5000;
            controls.addEventListener('change', render3DScene); // render khi c√≥ t∆∞∆°ng t√°c

            // Shapes Group - to hold all dynamic shapes for easy clearing
            shapesGroup = new THREE.Group();
            scene.add(shapesGroup);

            vertexLabelsGroup = new THREE.Group(); // Kh·ªüi t·∫°o group cho nh√£n
            scene.add(vertexLabelsGroup);

            // Axes Helper
            const mainAxesHelper = new THREE.AxesHelper(10000); // TƒÉng chi·ªÅu d√†i tr·ª•c ch√≠nh
            scene.add(mainAxesHelper);

            // Grid/Ticks for Axes
            const ticksGroup = new THREE.Group();
            const tickLength = 20; // ƒê·ªô d√†i c·ªßa m·ªói v·∫°ch tick
            const tickStep = 100;  // Kho·∫£ng c√°ch gi·ªØa c√°c v·∫°ch tick
            const axisLength = 10000; // Ph·∫£i kh·ªõp v·ªõi AxesHelper ·ªü tr√™n
            const tickMaterialX = new THREE.LineBasicMaterial({ color: 0xff0000 }); // Red for X ticks
            const tickMaterialY = new THREE.LineBasicMaterial({ color: 0x00ff00 }); // Green for Y ticks
            const tickMaterialZ = new THREE.LineBasicMaterial({ color: 0x0000ff }); // Blue for Z ticks

            function createTicksForAxis(targetAxis, length, step, tickSize, material) {
                const points = [];
                for (let i = -length; i <= length; i += step) {
                    if (i === 0) continue; // B·ªè qua g·ªëc t·ªça ƒë·ªô

                    if (targetAxis === 'x') {
                        points.push(new THREE.Vector3(i, -tickSize / 2, 0));
                        points.push(new THREE.Vector3(i, tickSize / 2, 0));
                        points.push(new THREE.Vector3(i, 0, -tickSize / 2));
                        points.push(new THREE.Vector3(i, 0, tickSize / 2));
                    } else if (targetAxis === 'y') {
                        points.push(new THREE.Vector3(-tickSize / 2, i, 0));
                        points.push(new THREE.Vector3(tickSize / 2, i, 0));
                        points.push(new THREE.Vector3(0, i, -tickSize / 2));
                        points.push(new THREE.Vector3(0, i, tickSize / 2));
                    } else if (targetAxis === 'z') {
                        points.push(new THREE.Vector3(-tickSize / 2, 0, i));
                        points.push(new THREE.Vector3(tickSize / 2, 0, i));
                        points.push(new THREE.Vector3(0, -tickSize / 2, i));
                        points.push(new THREE.Vector3(0, tickSize / 2, i));
                    }
                }
                if (points.length > 0) {
                    const tickGeometry = new THREE.BufferGeometry().setFromPoints(points);
                    const ticks = new THREE.LineSegments(tickGeometry, material);
                    ticksGroup.add(ticks);
                }
            }

            createTicksForAxis('x', axisLength, tickStep, tickLength, tickMaterialX);
            createTicksForAxis('y', axisLength, tickStep, tickLength, tickMaterialY);
            createTicksForAxis('z', axisLength, tickStep, tickLength, tickMaterialZ);
            scene.add(ticksGroup);

            // Animation loop for controls damping
            function animate() {
                requestAnimationFrame(animate);
                controls.update(); // only required if controls.enableDamping or controls.autoRotate are set to true
                render3DScene();
            }
            animate();

            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);
            onWindowResize(); // Initial call to set size
        }

        function onWindowResize() {
            if (!renderer || !camera || !threeJsCanvasContainer) return;
            const newWidth = threeJsCanvasContainer.clientWidth;
            const newHeight = threeJsCanvasContainer.clientHeight;

            camera.aspect = newWidth / newHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(newWidth, newHeight);
            update3DView();
        }

        function render3DScene() {
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }

        // --- Update 3D View ---
        function update3DView() {
            if (!scene || !shapesGroup) return;

            // Clear previous shapes and labels first
            while (shapesGroup.children.length > 0) {
                shapesGroup.remove(shapesGroup.children[0]);
            }
            shapesGroup.clear(); // ƒê·∫£m b·∫£o group r·ªóng
            threeShapeObjects = {}; // Reset map object

            while (vertexLabelsGroup && vertexLabelsGroup.children.length > 0) {
                vertexLabelsGroup.remove(vertexLabelsGroup.children[0]);
            }
            if (vertexLabelsGroup) vertexLabelsGroup.clear();


            shapesData.forEach(shape => {
                const isSelected = shape._internalId === selectedShapeId;

                const shapeSpecificGroup = new THREE.Group(); // Group ri√™ng cho m·ªói shape
                shapesGroup.add(shapeSpecificGroup); // Th√™m group c·ªßa shape v√†o group ch√≠nh

                const currentLineMaterial = new THREE.LineBasicMaterial({
                    color: isSelected ? HIGHLIGHTED_LINE_COLOR : NORMAL_LINE_COLOR,
                    depthTest: false, // ƒê·ªÉ line kh√¥ng b·ªã ·∫©n b·ªüi face n·∫øu tr√πng
                });
                const currentFaceMaterial = new THREE.MeshStandardMaterial({
                    color: isSelected ? HIGHLIGHTED_FACE_COLOR : NORMAL_FACE_COLOR,
                    side: THREE.FrontSide,
                    metalness: 0.1,
                    roughness: 0.75,
                    depthTest: true
                });
                const currentLabelBackgroundColor = isSelected ? HIGHLIGHTED_LABEL_BG_COLOR : NORMAL_LABEL_BG_COLOR;
                const currentLabelTextColor = isSelected ? { r: 0, g: 0, b: 0, a: 1 } : { r: 255, g: 255, b: 255, a: 1 };


                // L∆∞u tr·ªØ c√°c ƒë·ªëi t∆∞·ª£ng three.js c·ªßa shape n√†y ƒë·ªÉ c√≥ th·ªÉ highlight sau
                threeShapeObjects[shape._internalId] = {
                    group: shapeSpecificGroup, // Group ch·ª©a t·∫•t c·∫£ elements c·ªßa shape n√†y
                    lines: null, // S·∫Ω ƒë∆∞·ª£c g√°n khi t·∫°o LineSegments
                    mesh: null,  // S·∫Ω ƒë∆∞·ª£c g√°n khi t·∫°o Mesh
                    labels: [] // M·∫£ng c√°c sprite nh√£n
                };

                if (!shape.v || Object.keys(shape.v).length === 0) return;

                const vertexMap = {};
                const points = [];
                Object.keys(shape.v).sort((a, b) => parseInt(a) - parseInt(b)).forEach((key, index) => {
                    const coords = shape.v[key];
                    const pivot = shape.pivot || [0, 0, 0]; // L·∫•y pivot, m·∫∑c ƒë·ªãnh [0,0,0]
                    const vertexPosition = new THREE.Vector3(
                        coords[0] + pivot[0],
                        coords[1] + pivot[1],
                        coords[2] + pivot[2]
                    );
                    points.push(vertexPosition);
                    vertexMap[key] = index;

                    const currentWorldHeight = 0.1; // ƒê·∫∑t l·∫°i k√≠ch th∆∞·ªõc nh√£n mong mu·ªën tr√™n m√†n h√¨nh
                    const labelSprite = createTextSprite(key.toString(), {
                        internalFontsize: 32,    // Gi·ªØ nguy√™n font size cho texture s·∫Øc n√©t
                        worldHeight: currentWorldHeight,
                        backgroundColor: currentLabelBackgroundColor,
                        textColor: currentLabelTextColor,
                        fontface: 'monospace'
                    });
                    labelSprite.position.copy(vertexPosition);
                    labelSprite.position.y += (currentWorldHeight * 0.5) + 2;
                    if (isSelected) { // Ch·ªâ th√™m label v√†o group c·ªßa shape n·∫øu shape ƒë∆∞·ª£c ch·ªçn
                        shapeSpecificGroup.add(labelSprite);
                    }
                    threeShapeObjects[shape._internalId].labels.push(labelSprite); // V·∫´n l∆∞u tr·ªØ tham chi·∫øu ƒë·∫øn label
                });

                if (points.length === 0) return;

                if (shape.lines && shape.lines.length > 0) {
                    const linePointsForBuffer = []; // For existing LineBasicMaterial if not selected
                    const flatLineVertices = [];   // For LineMaterial if selected

                    shape.lines.forEach(line => {
                        if (vertexMap[line.v1.toString()] !== undefined && vertexMap[line.v2.toString()] !== undefined) {
                            const p1 = points[vertexMap[line.v1.toString()]];
                            const p2 = points[vertexMap[line.v2.toString()]];

                            flatLineVertices.push(p1.x, p1.y, p1.z);
                            flatLineVertices.push(p2.x, p2.y, p2.z);
                        }
                    });

                    if (flatLineVertices.length > 0) {
                        if (isSelected) { // Ch·ªâ v·∫Ω lines n·∫øu shape ƒë∆∞·ª£c ch·ªçn
                            const lineGeo = new THREE.LineSegmentsGeometry();
                            lineGeo.setPositions(flatLineVertices);

                            const lineMat = new THREE.LineMaterial({
                                color: HIGHLIGHTED_LINE_COLOR,
                                linewidth: 3, // ƒê·ªô d√†y c·ªßa line (v√≠ d·ª•: 3 pixels)
                                resolution: new THREE.Vector2(threeJsCanvasContainer.clientWidth, threeJsCanvasContainer.clientHeight),
                                depthTest: true, // ƒê·ªïi th√†nh true ƒë·ªÉ ƒë∆∞·ªùng b·ªã khu·∫•t kh√¥ng hi·ªÉn th·ªã
                                dashed: false
                            });

                            const lineSegmentsFat = new THREE.LineSegments2(lineGeo, lineMat);
                            shapeSpecificGroup.add(lineSegmentsFat);
                            threeShapeObjects[shape._internalId].lines = lineSegmentsFat;
                        }
                    }
                }

                if (shape.faces && Object.keys(shape.faces).length > 0) {
                    const faceIndices = [];
                    Object.values(shape.faces).forEach(face => {
                        const vIndices = face.vertices;
                        const mappedVIndices = vIndices.map(vi => vertexMap[vi.toString()]).filter(vi => vi !== undefined);

                        if (mappedVIndices.length >= 3) {
                            for (let i = 1; i < mappedVIndices.length - 1; i++) {
                                faceIndices.push(mappedVIndices[0], mappedVIndices[i], mappedVIndices[i + 1]);
                            }
                        }
                    });

                    if (faceIndices.length > 0) {
                        const faceGeometry = new THREE.BufferGeometry().setFromPoints(points);
                        faceGeometry.setIndex(faceIndices);
                        faceGeometry.computeVertexNormals();
                        const mesh = new THREE.Mesh(faceGeometry, currentFaceMaterial);
                        shapeSpecificGroup.add(mesh); // Th√™m mesh v√†o group c·ªßa shape
                        threeShapeObjects[shape._internalId].mesh = mesh;
                    }
                }
            });
            render3DScene();
        }

        // --- Render Functions ---
        function renderShapesList() {
            shapesListContainer.innerHTML = '';
            if (shapesData.length === 0) {
                shapesListContainer.innerHTML = '<p>Ch∆∞a c√≥ shape n√†o.</p>';
            } else {
                shapesData.forEach((shape, index) => {
                    const shapeItem = document.createElement('div');
                    shapeItem.classList.add('shape-item');
                    if (shape._internalId === selectedShapeId) {
                        shapeItem.classList.add('selected');
                    }
                    // Hi·ªÉn th·ªã t√™n theo mode "Line" trong danh s√°ch cho nh·∫•t qu√°n, ho·∫∑c c√≥ th·ªÉ ch·ªçn m·ªôt mode c·ªë ƒë·ªãnh
                    const displayIdentifiers = generateShapeIdentifiers(index, "Line");
                    shapeItem.textContent = `Shape: ${displayIdentifiers.name}`;
                    shapeItem.dataset.shapeId = shape._internalId; // V·∫´n d√πng _internalId ƒë·ªÉ ch·ªçn

                    const deleteBtn = document.createElement('button');
                    deleteBtn.innerHTML = 'üóëÔ∏è';
                    deleteBtn.title = 'X√≥a Shape';
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        deleteShape(shape._internalId);
                    };

                    const copyShapeBtn = document.createElement('button');
                    copyShapeBtn.innerHTML = 'üìã';
                    copyShapeBtn.title = 'Sao ch√©p Shape';
                    copyShapeBtn.style.backgroundColor = '#28a745';
                    copyShapeBtn.style.marginLeft = '5px';
                    copyShapeBtn.onclick = (e) => {
                        e.stopPropagation();
                        copyShape(shape._internalId);
                    };

                    shapeItem.appendChild(copyShapeBtn);
                    shapeItem.appendChild(deleteBtn);

                    shapeItem.onclick = () => {
                        selectShape(shape._internalId);
                    };
                    shapesListContainer.appendChild(shapeItem);
                });
            }
            // Kh√¥ng c·∫ßn g·ªçi update3DView ·ªü ƒë√¢y n·ªØa v√¨ selectShape s·∫Ω l√†m ƒëi·ªÅu ƒë√≥ th√¥ng qua renderJsonOutput
        }

        function renderJsonOutput() {
            // H√†m n√†y gi·ªù ch·ªâ t·∫°o JSON cho Line Geometry v√† c·∫≠p nh·∫≠t 3D view
            currentJsonString = generateJsonString(true); // true ƒë·ªÉ bao g·ªìm lines
            update3DView(); // Update 3D view whenever JSON output changes
        }

        function generateJsonString(includeLines) {
            const shapesForJson = shapesData.map((s, index) => {
                const { _internalId, pivot, stdMaterial, deformTypes, ...shapeRest } = s; // L·∫•y th√™m stdMaterial, deformTypes
                const currentPivot = pivot && Array.isArray(pivot) && pivot.length === 3 ? pivot : [0, 0, 0];

                const mode = includeLines ? "Line" : "Std";
                const identifiers = generateShapeIdentifiers(index, mode);

                const worldVertices = {};
                if (shapeRest.v) {
                    Object.keys(shapeRest.v).forEach(vKey => {
                        const localCoord = shapeRest.v[vKey];
                        worldVertices[vKey] = [
                            parseFloat((localCoord[0] + currentPivot[0]).toFixed(1)),
                            parseFloat((localCoord[1] + currentPivot[1]).toFixed(1)),
                            parseFloat((localCoord[2] + currentPivot[2]).toFixed(1))
                        ];
                    });
                }

                const outputShape = {
                    ...shapeRest,
                    name: identifiers.name, // S·ª≠ d·ª•ng t√™n ƒë∆∞·ª£c t·∫°o ƒë·ªông
                    uuid: identifiers.uuid, // S·ª≠ d·ª•ng UUID ƒë∆∞·ª£c t·∫°o ƒë·ªông
                    v: worldVertices,
                    lines: includeLines ? (shapeRest.lines || []) : []
                };
                // Kh√¥ng th√™m stdMaterial v√† deformTypes v√†o ƒë√¢y v√¨ ƒë√¢y l√† JSON cho Geometry
                return outputShape;
            });

            const output = {
                shapes: shapesForJson
            };
            return JSON.stringify(output); // B·ªè null, 2 ƒë·ªÉ minimize
        }

        function renderSelectedShapeEditor() {
            if (!selectedShapeId) {
                shapeEditorContainer.classList.add('hidden');
                noShapeSelectedMsg.classList.remove('hidden');
                if (currentDeformTypesText) currentDeformTypesText.textContent = 'None';
                return;
            }

            shapeEditorContainer.classList.remove('hidden');
            noShapeSelectedMsg.classList.add('hidden');

            const shape = shapesData.find(s => s._internalId === selectedShapeId);
            if (!shape) return; // Should not happen

            const shapeIndex = shapesData.findIndex(s => s._internalId === selectedShapeId);
            if (shapeIndex === -1) return; // Should not happen

            const lineIdentifiers = generateShapeIdentifiers(shapeIndex, "Line");
            const stdIdentifiers = generateShapeIdentifiers(shapeIndex, "Std");

            generatedShapeNameLine.textContent = lineIdentifiers.name;
            generatedShapeNameStd.textContent = stdIdentifiers.name;
            // UUID hi·ªÉn th·ªã c√≥ th·ªÉ l·∫•y theo Line mode ho·∫∑c l√†m r√µ h∆°n
            // generatedShapeUuid.textContent = `${lineIdentifiers.uuid} (Line Mode) / ${stdIdentifiers.uuid} (Std Mode)`; // ƒê√É X√ìA

            stdMaterialInput.value = shape.stdMaterial || '';

            // X·ª≠ l√Ω Deform Types Checkboxes
            shape.deformTypes = shape.deformTypes || [];
            deformStretch2Checkbox.checked = shape.deformTypes.includes('Stretch2');
            deformClippingCheckbox.checked = shape.deformTypes.includes('Clipping');
            updateCurrentDeformTypesText(shape.deformTypes); // C·∫≠p nh·∫≠t text hi·ªÉn th·ªã

            // Hi·ªÉn th·ªã v√† x·ª≠ l√Ω pivot
            shape.pivot = shape.pivot || [0, 0, 0]; // ƒê·∫£m b·∫£o pivot t·ªìn t·∫°i
            pivotXInput.value = shape.pivot[0];
            pivotYInput.value = shape.pivot[1];
            pivotZInput.value = shape.pivot[2];

            renderVerticesList(shape);
            renderFacesList(shape);
            renderLinesList(shape);
            renderJsonOutput();
        }

        function renderVerticesList(shape) {
            verticesListContainer.innerHTML = '';
            if (!shape || !shape.v) return;

            Object.entries(shape.v).forEach(([key, coords], index) => {
                const vEntry = document.createElement('div');
                vEntry.classList.add('vertex-entry');

                const idLabel = document.createElement('span');
                idLabel.textContent = `ID(${key}):`;

                // G·ªôp th√†nh 1 input
                const coordsInput = document.createElement('input');
                coordsInput.type = 'text';
                coordsInput.value = coords.join(','); // Hi·ªÉn th·ªã d·∫°ng X,Y,Z
                coordsInput.dataset.vertexKey = key;
                coordsInput.style.flexGrow = 1; // Cho input chi·∫øm nhi·ªÅu kh√¥ng gian h∆°n
                coordsInput.onchange = handleVertexCoordsChange; // H√†m x·ª≠ l√Ω m·ªõi

                const copyBtn = document.createElement('button');
                copyBtn.innerHTML = 'üìã';
                copyBtn.title = 'Sao ch√©p Vertex';
                copyBtn.style.backgroundColor = '#17a2b8';
                copyBtn.onclick = () => copyVertex(key);

                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'üóëÔ∏è';
                deleteBtn.title = 'X√≥a Vertex';
                deleteBtn.style.backgroundColor = '#ffc107';
                deleteBtn.onclick = () => deleteVertex(key);

                vEntry.append(idLabel, coordsInput, copyBtn, deleteBtn);
                verticesListContainer.appendChild(vEntry);
            });
        }

        function renderFacesList(shape) {
            facesListContainer.innerHTML = '';
            if (!shape || !shape.faces) return;

            Object.entries(shape.faces).forEach(([key, faceData]) => {
                const fEntry = document.createElement('div');
                fEntry.classList.add('face-entry');
                fEntry.textContent = `Face ID(${key}): ${faceData.vertices.join(', ')}`;

                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'üóëÔ∏è';
                deleteBtn.title = 'X√≥a Face';
                deleteBtn.style.backgroundColor = '#ffc107';
                deleteBtn.onclick = () => deleteFace(key);

                fEntry.appendChild(deleteBtn);
                facesListContainer.appendChild(fEntry);
            });
        }

        function renderLinesList(shape) {
            linesListContainer.innerHTML = '';
            if (!shape || !shape.lines) return;

            shape.lines.forEach((line, index) => {
                const lEntry = document.createElement('div');
                lEntry.classList.add('line-entry');
                lEntry.textContent = `Line: v${line.v1} - v${line.v2}`;

                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'üóëÔ∏è';
                deleteBtn.title = 'X√≥a Line';
                deleteBtn.style.backgroundColor = '#ffc107';
                deleteBtn.onclick = () => deleteLine(index);

                lEntry.appendChild(deleteBtn);
                linesListContainer.appendChild(lEntry);
            });
        }


        // --- Event Handlers & Logic ---
        addShapeBtn.onclick = () => {
            const newShapeInternalId = Date.now() + Math.random(); // ID n·ªôi b·ªô duy nh·∫•t, kh√¥ng d√πng cho name/uuid n·ªØa
            const defaultStdMaterial = defaultStdMaterialInput.value.trim();
            const defaultDeformTypes = [];
            if (defaultDeformStretch2Checkbox.checked) defaultDeformTypes.push('Stretch2');
            if (defaultDeformClippingCheckbox.checked) defaultDeformTypes.push('Clipping');

            const newShape = {
                _internalId: newShapeInternalId,
                // name v√† uuid s·∫Ω ƒë∆∞·ª£c t·∫°o ƒë·ªông, kh√¥ng c·∫ßn l∆∞u tr·ªØ c·ªë ƒë·ªãnh trong shape object n·ªØa
                faces: {},
                lines: [],
                v: {},
                pivot: [0, 0, 0],
                deformTypes: defaultDeformTypes, // S·ª≠ d·ª•ng gi√° tr·ªã default
                stdMaterial: defaultStdMaterial  // S·ª≠ d·ª•ng gi√° tr·ªã default
            };
            shapesData.push(newShape);
            // Kh√¥ng c·∫ßn g√°n selectedShapeId ngay, v√¨ selectShape s·∫Ω l√†m ƒëi·ªÅu ƒë√≥ th√¥ng qua renderShapesList
            renderShapesList(); // C·∫≠p nh·∫≠t danh s√°ch tr∆∞·ªõc
            selectShape(newShapeInternalId); // T·ª± ƒë·ªông ch·ªçn shape m·ªõi
        };

        function selectShape(shapeIdToSelect) {
            selectedShapeId = shapeIdToSelect;
            renderShapesList();
            renderSelectedShapeEditor();
            renderJsonOutput(); // ƒêi·ªÅu n√†y s·∫Ω g·ªçi update3DView v√† √°p d·ª•ng highlight
        }

        function deleteShape(shapeIdToDelete) {
            shapesData = shapesData.filter(s => s._internalId !== shapeIdToDelete);
            if (selectedShapeId === shapeIdToDelete) {
                selectedShapeId = null;
                if (currentDeformTypesText) currentDeformTypesText.textContent = 'None';
                // X√≥a lu√¥n text t√™n/uuid ƒëang hi·ªÉn th·ªã trong editor
                generatedShapeNameLine.textContent = '';
                generatedShapeNameStd.textContent = '';
                // generatedShapeUuid.textContent = ''; // ƒê√É X√ìA
            }
            renderShapesList();
            renderSelectedShapeEditor(); // C·∫≠p nh·∫≠t editor (c√≥ th·ªÉ ·∫©n ƒëi)
            renderJsonOutput();
        }

        function generateShapeIdentifiers(shapeIndex, mode) {
            const baseName = currentObjectName || "DEFAULT_OBJECT";
            const suffix = mode === "Line" ? "L" : "G";
            const name = `${baseName}-${suffix}_${shapeIndex + 1}`;
            return { name: name, uuid: name }; // UUID gi·ªëng h·ªát name
        }

        objectNameInput.onchange = (e) => {
            currentObjectName = e.target.value.trim();
            renderShapesList();
            renderSelectedShapeEditor(); // C·∫≠p nh·∫≠t t√™n hi·ªÉn th·ªã n·∫øu c√≥ shape ƒëang ch·ªçn
            renderJsonOutput(); // C·∫≠p nh·∫≠t JSON v√† 3D view
        };

        addVertexBtn.onclick = () => {
            if (!selectedShapeId) return;
            const shape = shapesData.find(s => s._internalId === selectedShapeId);
            if (!shape) return;

            const existingKeys = Object.keys(shape.v).map(k => parseInt(k)).filter(k => !isNaN(k));
            const newKey = existingKeys.length > 0 ? Math.max(...existingKeys) + 1 : 0;

            shape.v[newKey.toString()] = [0, 0, 0]; // Default coords
            renderVerticesList(shape);
            renderJsonOutput();
        };

        function handleVertexCoordsChange(event) {
            if (!selectedShapeId) return;
            const shape = shapesData.find(s => s._internalId === selectedShapeId);
            if (!shape) return;

            const vertexKey = event.target.dataset.vertexKey;
            const newCoordsStr = event.target.value.trim();
            const coordsArray = newCoordsStr.split(',').map(c => parseFloat(c.trim()));

            if (coordsArray.length === 3 && coordsArray.every(c => !isNaN(c))) {
                shape.v[vertexKey] = coordsArray;
                renderJsonOutput();
            } else {
                alert("ƒê·ªãnh d·∫°ng t·ªça ƒë·ªô kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p d∆∞·ªõi d·∫°ng X,Y,Z (v√≠ d·ª•: 10.5,20,30.2)");
                event.target.value = shape.v[vertexKey].join(',');
            }
        }

        function copyVertex(vertexKeyToCopy) {
            if (!selectedShapeId) return;
            const shape = shapesData.find(s => s._internalId === selectedShapeId);
            if (!shape || !shape.v[vertexKeyToCopy]) return;

            const coordsToCopy = [...shape.v[vertexKeyToCopy]];

            const existingKeys = Object.keys(shape.v).map(k => parseInt(k)).filter(k => !isNaN(k));
            const newKey = existingKeys.length > 0 ? Math.max(...existingKeys) + 1 : 0;

            shape.v[newKey.toString()] = coordsToCopy;
            renderVerticesList(shape);
            renderJsonOutput();
        }

        function deleteVertex(vertexKeyToDelete) {
            if (!selectedShapeId) return;
            const shape = shapesData.find(s => s._internalId === selectedShapeId);
            if (!shape || !shape.v[vertexKeyToDelete]) return;

            if (confirm(`B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a Vertex ID(${vertexKeyToDelete})? ƒêi·ªÅu n√†y c√≥ th·ªÉ ·∫£nh h∆∞·ªüng ƒë·∫øn Faces v√† Lines.`)) {
                delete shape.v[vertexKeyToDelete];
                // TODO: Consider auto-deleting/updating faces/lines referencing this vertex
                renderVerticesList(shape);
                renderJsonOutput();
                alert("L∆∞u √Ω: Faces v√† Lines tham chi·∫øu ƒë·∫øn vertex n√†y c√≥ th·ªÉ kh√¥ng c√≤n h·ª£p l·ªá.");
            }
        }

        addFaceBtn.onclick = () => {
            if (!selectedShapeId) return;
            const shape = shapesData.find(s => s._internalId === selectedShapeId);
            if (!shape) return;

            const verticesStr = faceVerticesInput.value.trim();
            const existingFaceKeys = Object.keys(shape.faces).map(k => parseInt(k)).filter(k => !isNaN(k));
            let newFaceKey = 0;
            if (existingFaceKeys.length > 0) {
                newFaceKey = Math.max(...existingFaceKeys) + 1;
            }
            const faceKey = newFaceKey.toString();

            if (!verticesStr) {
                alert("Danh s√°ch vertices cho face kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng.");
                return;
            }
            const verticesIndices = verticesStr.split(',').map(v => parseInt(v.trim())).filter(v => !isNaN(v));
            if (verticesIndices.length < 3) {
                alert("M·ªôt face c·∫ßn √≠t nh·∫•t 3 vertices.");
                return;
            }
            for (let vIndex of verticesIndices) {
                if (!shape.v[vIndex.toString()]) {
                    alert(`Vertex ID '${vIndex}' kh√¥ng t·ªìn t·∫°i trong danh s√°ch vertices hi·ªán t·∫°i c·ªßa shape.`);
                    return;
                }
            }
            shape.faces[faceKey] = { vertices: verticesIndices };
            renderFacesList(shape);
            if (verticesIndices.length >= 2) {
                for (let i = 0; i < verticesIndices.length; i++) {
                    const vA = verticesIndices[i];
                    const vB = verticesIndices[(i + 1) % verticesIndices.length];
                    if (vA === vB || !shape.v[vA.toString()] || !shape.v[vB.toString()]) continue;
                    const lineExists = shape.lines.some(existingLine =>
                        (existingLine.v1 === vA && existingLine.v2 === vB) ||
                        (existingLine.v1 === vB && existingLine.v2 === vA)
                    );
                    if (!lineExists) {
                        shape.lines.push({ v1: vA, v2: vB });
                    }
                }
                renderLinesList(shape);
            }
            renderJsonOutput();
            faceVerticesInput.value = '';
        };

        function deleteFace(faceKeyToDelete) {
            if (!selectedShapeId) return;
            const shape = shapesData.find(s => s._internalId === selectedShapeId);
            if (!shape || !shape.faces[faceKeyToDelete]) return;
            delete shape.faces[faceKeyToDelete];
            renderFacesList(shape);
            renderJsonOutput();
        }

        addLineBtn.onclick = () => {
            if (!selectedShapeId) return;
            const shape = shapesData.find(s => s._internalId === selectedShapeId);
            if (!shape) return;
            const verticesStr = lineVerticesInput.value.trim();
            if (!verticesStr) {
                alert("Vui l√≤ng nh·∫≠p ID c·ªßa hai ƒë·ªânh, c√°ch nhau b·ªüi d·∫•u ph·∫©y.");
                return;
            }
            const parts = verticesStr.split(',');
            if (parts.length !== 2) {
                alert("ƒê·ªãnh d·∫°ng kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p hai ID ƒë·ªânh, c√°ch nhau b·ªüi d·∫•u ph·∫©y (v√≠ d·ª•: 0,1).");
                return;
            }
            const v1 = parseInt(parts[0].trim());
            const v2 = parseInt(parts[1].trim());
            if (isNaN(v1) || isNaN(v2)) {
                alert("ID Vertex ph·∫£i l√† s·ªë.");
                return;
            }
            if (!shape.v[v1.toString()]) {
                alert(`Vertex ID '${v1}' kh√¥ng t·ªìn t·∫°i trong shape n√†y.`);
                return;
            }
            if (!shape.v[v2.toString()]) {
                alert(`Vertex ID '${v2}' kh√¥ng t·ªìn t·∫°i trong shape n√†y.`);
                return;
            }
            if (v1 === v2) {
                alert("M·ªôt line kh√¥ng th·ªÉ b·∫Øt ƒë·∫ßu v√† k·∫øt th√∫c ·ªü c√πng m·ªôt vertex.");
                return;
            }
            const lineExists = shape.lines.some(existingLine =>
                (existingLine.v1 === v1 && existingLine.v2 === v2) || (existingLine.v1 === v2 && existingLine.v2 === v1)
            );
            if (lineExists) {
                alert("Line n√†y ƒë√£ t·ªìn t·∫°i.");
                return;
            }
            shape.lines.push({ v1: v1, v2: v2 });
            renderLinesList(shape);
            renderJsonOutput();
            lineVerticesInput.value = '';
        };

        function deleteLine(lineIndexToDelete) {
            if (!selectedShapeId) return;
            const shape = shapesData.find(s => s._internalId === selectedShapeId);
            if (!shape || !shape.lines[lineIndexToDelete]) return;
            shape.lines.splice(lineIndexToDelete, 1);
            renderLinesList(shape);
            renderJsonOutput();
        }

        // --- Transformation Functions ---
        function calculateShapeCentroid(shape) {
            if (!shape || !shape.v || Object.keys(shape.v).length === 0) {
                return new THREE.Vector3(0, 0, 0); // Default to origin if no vertices
            }
            const centroid = new THREE.Vector3(0, 0, 0);
            const vertexKeys = Object.keys(shape.v);
            vertexKeys.forEach(key => {
                centroid.add(new THREE.Vector3(...shape.v[key]));
            });
            centroid.divideScalar(vertexKeys.length);
            return centroid;
        }

        applyTranslateBtn.onclick = () => {
            if (!selectedShapeId) return;
            const shape = shapesData.find(s => s._internalId === selectedShapeId);
            if (!shape || !shape.v) return;

            // ƒê·∫£m b·∫£o shape.pivot t·ªìn t·∫°i v√† l√† m·ªôt m·∫£ng
            shape.pivot = shape.pivot && Array.isArray(shape.pivot) && shape.pivot.length === 3 ? shape.pivot : [0, 0, 0];

            const deltaX = parseFloat(translateXInput.value) || 0;
            const deltaY = parseFloat(translateYInput.value) || 0;
            const deltaZ = parseFloat(translateZInput.value) || 0;

            shape.pivot[0] = parseFloat((shape.pivot[0] + deltaX).toFixed(1));
            shape.pivot[1] = parseFloat((shape.pivot[1] + deltaY).toFixed(1));
            shape.pivot[2] = parseFloat((shape.pivot[2] + deltaZ).toFixed(1));

            // Kh√¥ng c·∫ßn c·∫≠p nh·∫≠t shape.v n·ªØa v√¨ ch√∫ng l√† local
            // renderVerticesList(shape); // Kh√¥ng c·∫ßn thi·∫øt n·∫øu ch·ªâ pivot thay ƒë·ªïi
            renderSelectedShapeEditor(); // C·∫≠p nh·∫≠t gi√° tr·ªã pivot tr√™n UI
            renderJsonOutput(); // C·∫≠p nh·∫≠t JSON v√† 3D view
        };

        applyRotateBtn.onclick = () => {
            if (!selectedShapeId) return;
            const shape = shapesData.find(s => s._internalId === selectedShapeId);
            if (!shape || !shape.v) return;

            const angleX = THREE.MathUtils.degToRad(parseFloat(rotateXInput.value) || 0);
            const angleY = THREE.MathUtils.degToRad(parseFloat(rotateYInput.value) || 0);
            const angleZ = THREE.MathUtils.degToRad(parseFloat(rotateZInput.value) || 0);

            // const centroid = calculateShapeCentroid(shape); // Kh√¥ng c·∫ßn centroid n·ªØa v√¨ xoay local vertices
            const euler = new THREE.Euler(angleX, angleY, angleZ, 'XYZ'); // Th·ª© t·ª± xoay XYZ

            Object.keys(shape.v).forEach(key => {
                const vertex = new THREE.Vector3(...shape.v[key]); // ƒê√¢y l√† local vertex
                // vertex.sub(centroid); // Kh√¥ng c·∫ßn tr·ª´ centroid
                vertex.applyEuler(euler); // Xoay quanh g·ªëc (0,0,0) c·ªßa local space
                // vertex.add(centroid); // Kh√¥ng c·∫ßn c·ªông l·∫°i centroid
                shape.v[key] = [
                    parseFloat(vertex.x.toFixed(1)),
                    parseFloat(vertex.y.toFixed(1)),
                    parseFloat(vertex.z.toFixed(1))
                ];
            });
            renderVerticesList(shape);
            renderJsonOutput();
        };

        function applyFlip(axis) {
            if (!selectedShapeId) return;
            const shape = shapesData.find(s => s._internalId === selectedShapeId);
            if (!shape || !shape.v) return;

            // const centroid = calculateShapeCentroid(shape); // Kh√¥ng c·∫ßn centroid n·ªØa

            Object.keys(shape.v).forEach(key => {
                const vertex = new THREE.Vector3(...shape.v[key]); // Local vertex
                // vertex.sub(centroid); // Kh√¥ng c·∫ßn
                if (axis === 'x') vertex.x *= -1;
                if (axis === 'y') vertex.y *= -1;
                if (axis === 'z') vertex.z *= -1;
                // vertex.add(centroid); // Kh√¥ng c·∫ßn
                shape.v[key] = [
                    parseFloat(vertex.x.toFixed(1)),
                    parseFloat(vertex.y.toFixed(1)),
                    parseFloat(vertex.z.toFixed(1))
                ];
            });
            renderVerticesList(shape);
            renderJsonOutput();
        }

        flipXBtn.onclick = () => applyFlip('x');
        flipYBtn.onclick = () => applyFlip('y');
        flipZBtn.onclick = () => applyFlip('z');

        pivotXInput.onchange = handlePivotChange;
        pivotYInput.onchange = handlePivotChange;
        pivotZInput.onchange = handlePivotChange;

        function handlePivotChange() {
            if (!selectedShapeId) return;
            const shape = shapesData.find(s => s._internalId === selectedShapeId);
            if (!shape) return;

            const newPivotX = parseFloat(pivotXInput.value) || 0;
            const newPivotY = parseFloat(pivotYInput.value) || 0;
            const newPivotZ = parseFloat(pivotZInput.value) || 0;

            shape.pivot = [newPivotX, newPivotY, newPivotZ];
            renderJsonOutput(); // C·∫≠p nh·∫≠t 3D view v√† JSON
        }

        deformStretch2Checkbox.onchange = handleDeformTypeChange;
        deformClippingCheckbox.onchange = handleDeformTypeChange;

        function handleDeformTypeChange(event) {
            if (!selectedShapeId) return;
            const shape = shapesData.find(s => s._internalId === selectedShapeId);
            if (!shape) return;

            const type = event.target.id === 'deformStretch2Checkbox' ? 'Stretch2' : 'Clipping';
            shape.deformTypes = shape.deformTypes || [];

            if (event.target.checked) {
                // Th√™m n·∫øu ch∆∞a c√≥, gi·ªØ th·ª© t·ª± n·∫øu ƒë√£ c√≥ t·ª´ tr∆∞·ªõc (do uncheck r·ªìi check l·∫°i)
                if (!shape.deformTypes.includes(type)) {
                    shape.deformTypes.push(type);
                }
            } else {
                // X√≥a kh·ªèi m·∫£ng
                shape.deformTypes = shape.deformTypes.filter(dt => dt !== type);
            }
            updateCurrentDeformTypesText(shape.deformTypes); // C·∫≠p nh·∫≠t text hi·ªÉn th·ªã
            // Kh√¥ng c·∫ßn g·ªçi renderJsonOutput() ·ªü ƒë√¢y v√¨ JSON cho LineMesh ƒë∆∞·ª£c t·∫°o ri√™ng khi b·∫•m n√∫t
        }

        function updateCurrentDeformTypesText(deformTypesArray) {
            if (currentDeformTypesText) {
                currentDeformTypesText.textContent = deformTypesArray.join(', ') || 'None';
            }
        }

        function generateLineMeshJsonString() {
            const children = shapesData.map((shape, index) => {
                const identifiers = generateShapeIdentifiers(index, "Line");
                // ƒê·∫£m b·∫£o shape.name kh√¥ng r·ªóng, n·∫øu r·ªóng d√πng m·ªôt gi√° tr·ªã t·∫°m
                // const geometryName = (shape.name && shape.name.trim() !== '') ? shape.name.trim() : `Shape_${shape._internalId}`; // C≈©
                return {
                    "@type": ".Mesh2",
                    geometry: identifiers.name, // S·ª≠ d·ª•ng t√™n ƒë∆∞·ª£c t·∫°o ƒë·ªông
                    deformTypes: shape.deformTypes && Array.isArray(shape.deformTypes) ? shape.deformTypes : ['Stretch2'],
                    material: "MF", // Gi·ªØ nguy√™n nh∆∞ logic c≈© c·ªßa LineMesh
                    edgeMaterial: "ML0" // Gi·ªØ nguy√™n
                };
            });
            return JSON.stringify({ children: children }); // B·ªè null, 2 ƒë·ªÉ minimize
        }

        copyLineMeshBtn.onclick = () => {
            const lineMeshJson = generateLineMeshJsonString();
            navigator.clipboard.writeText(lineMeshJson).then(() => {
                alert('ƒê√£ sao ch√©p Line Mesh JSON v√†o clipboard!');
            }).catch(err => {
                console.error('L·ªói khi sao ch√©p Line Mesh JSON: ', err);
                alert('Kh√¥ng th·ªÉ t·ª± ƒë·ªông sao ch√©p Line Mesh JSON. Vui l√≤ng th·ª≠ l·∫°i.');
            });
        };

        function generateStdMeshJsonString() {
            const children = shapesData.map((shape, index) => {
                const identifiers = generateShapeIdentifiers(index, "Std");
                // const geometryName = (shape.name && shape.name.trim() !== '') ? shape.name.trim() : `Shape_${shape._internalId}`; // C≈©
                return {
                    "@type": ".Mesh2",
                    geometry: identifiers.name, // S·ª≠ d·ª•ng t√™n ƒë∆∞·ª£c t·∫°o ƒë·ªông
                    deformTypes: shape.deformTypes && Array.isArray(shape.deformTypes) ? shape.deformTypes : ['Stretch2'],
                    material: shape.stdMaterial || "",
                    matTag: "mat1"
                };
            });
            return JSON.stringify({ children: children }); // B·ªè null, 2 ƒë·ªÉ minimize
        }

        copyStdMeshBtn.onclick = () => {
            const stdMeshJson = generateStdMeshJsonString();
            navigator.clipboard.writeText(stdMeshJson).then(() => {
                alert('ƒê√£ sao ch√©p Std Mesh JSON v√†o clipboard!');
            }).catch(err => {
                console.error('L·ªói khi sao ch√©p Std Mesh JSON: ', err);
                alert('Kh√¥ng th·ªÉ t·ª± ƒë·ªông sao ch√©p Std Mesh JSON. Vui l√≤ng th·ª≠ l·∫°i.');
            });
        };

        stdMaterialInput.onchange = (e) => {
            if (selectedShapeId) {
                const shape = shapesData.find(s => s._internalId === selectedShapeId);
                if (shape) {
                    shape.stdMaterial = e.target.value;
                    // Kh√¥ng c·∫ßn renderJsonOutput() v√¨ stdMaterial kh√¥ng ·∫£nh h∆∞·ªüng tr·ª±c ti·∫øp ƒë·∫øn 3D view ho·∫∑c JSON c·ªßa c√°c n√∫t copy kh√°c
                }
            }
        };

        importJsonBtn.onclick = async () => {
            try {
                const textFromClipboard = await navigator.clipboard.readText();
                if (!textFromClipboard) {
                    alert("Clipboard r·ªóng ho·∫∑c kh√¥ng ch·ª©a d·ªØ li·ªáu text.");
                    return;
                }

                const parsedData = JSON.parse(textFromClipboard);

                if (!parsedData || !Array.isArray(parsedData.shapes)) {
                    alert("L·ªói: D·ªØ li·ªáu t·ª´ clipboard kh√¥ng ph·∫£i JSON h·ª£p l·ªá ho·∫∑c kh√¥ng c√≥ thu·ªôc t√≠nh 'shapes' d·∫°ng m·∫£ng.");
                    return;
                }

                const isValidShapeStructure = parsedData.shapes.every(shape =>
                    typeof shape.v === 'object' && shape.v !== null &&
                    typeof shape.faces === 'object' && shape.faces !== null &&
                    Array.isArray(shape.lines)
                );

                if (!isValidShapeStructure) {
                    alert("L·ªói: M·ªôt ho·∫∑c nhi·ªÅu shape trong JSON t·ª´ clipboard kh√¥ng c√≥ c·∫•u tr√∫c v, faces, ho·∫∑c lines h·ª£p l·ªá.");
                    return;
                }

                if (!currentObjectName || currentObjectName.trim() === "") {
                    alert("Vui l√≤ng nh·∫≠p Object Name tr∆∞·ªõc khi import JSON.");
                    objectNameInput.focus();
                    return;
                }

                shapesData = parsedData.shapes.map((s, index) => {
                    const internalId = Date.now() + index + Math.random();
                    return {
                        _internalId: internalId,
                        v: s.v || {},
                        faces: s.faces || {},
                        lines: s.lines || [],
                        pivot: s.pivot && Array.isArray(s.pivot) && s.pivot.length === 3 ? s.pivot : [0, 0, 0],
                        deformTypes: s.deformTypes && Array.isArray(s.deformTypes) ? s.deformTypes : (parsedData.shapes.length === 1 && s.deformTypes === undefined ? ['Stretch2'] : (s.deformTypes || (defaultDeformStretch2Checkbox.checked ? ['Stretch2'] : []).concat(defaultDeformClippingCheckbox.checked ? ['Clipping'] : []))),
                        stdMaterial: s.stdMaterial || defaultStdMaterialInput.value.trim()
                    };
                });

                selectedShapeId = null;
                renderShapesList();
                renderSelectedShapeEditor();
                renderJsonOutput();

                if (shapesData.length > 0 && !selectedShapeId) {
                    // Option: select the first shape automatically after import
                    // selectShape(shapesData[0]._internalId);
                } else if (selectedShapeId) {
                    const currentSelectedShape = shapesData.find(s => s._internalId === selectedShapeId);
                    if (currentSelectedShape) {
                        updateCurrentDeformTypesText(currentSelectedShape.deformTypes);
                    }
                } else {
                    if (currentDeformTypesText) currentDeformTypesText.textContent = 'None';
                }

            } catch (error) {
                console.error("L·ªói khi import JSON t·ª´ clipboard:", error);
                if (error.name === 'NotAllowedError') {
                    alert("L·ªói: Kh√¥ng ƒë∆∞·ª£c ph√©p truy c·∫≠p clipboard. Vui l√≤ng c·∫•p quy·ªÅn cho trang web.");
                } else if (error instanceof SyntaxError) {
                    alert("L·ªói: D·ªØ li·ªáu trong clipboard kh√¥ng ph·∫£i l√† ƒë·ªãnh d·∫°ng JSON h·ª£p l·ªá.");
                } else {
                    alert("ƒê√£ x·∫£y ra l·ªói khi ƒë·ªçc ho·∫∑c parse JSON t·ª´ clipboard. Vui l√≤ng ki·ªÉm tra console.");
                }
            }
        };

        function copyShape(shapeIdToCopy) {
            // T√¨m shape g·ªëc ƒë·ªÉ sao ch√©p
            const originalShape = shapesData.find(s => s._internalId === shapeIdToCopy);
            if (!originalShape) return;

            // T·∫°o m·ªôt b·∫£n sao s√¢u c·ªßa shape (tr·ª´ _internalId)
            // Quan tr·ªçng: C·∫ßn sao ch√©p s√¢u c√°c object v√† array b√™n trong (v, faces, lines, pivot, deformTypes)
            const newShapeInternalId = Date.now() + Math.random();
            const newV = JSON.parse(JSON.stringify(originalShape.v || {}));
            const newFaces = JSON.parse(JSON.stringify(originalShape.faces || {}));
            const newLines = JSON.parse(JSON.stringify(originalShape.lines || []));
            const newPivot = JSON.parse(JSON.stringify(originalShape.pivot || [0, 0, 0]));
            const newDeformTypes = JSON.parse(JSON.stringify(originalShape.deformTypes || []));

            const copiedShape = {
                _internalId: newShapeInternalId,
                v: newV,
                faces: newFaces,
                lines: newLines,
                pivot: newPivot, // Sao ch√©p pivot
                deformTypes: newDeformTypes, // Sao ch√©p deformTypes
                stdMaterial: originalShape.stdMaterial // Sao ch√©p stdMaterial
            };

            // Th√™m shape ƒë√£ sao ch√©p v√†o m·∫£ng shapesData
            shapesData.push(copiedShape);

            // C·∫≠p nh·∫≠t danh s√°ch shapes v√† t·ª± ƒë·ªông ch·ªçn shape m·ªõi ƒë∆∞·ª£c sao ch√©p
            renderShapesList();
            selectShape(newShapeInternalId); // Ch·ªçn shape m·ªõi ƒë∆∞·ª£c copy
        }

        applyDefaultsBtn.onclick = () => {
            const defaultStdMaterial = defaultStdMaterialInput.value.trim();
            const defaultDeformTypes = [];
            if (defaultDeformStretch2Checkbox.checked) defaultDeformTypes.push('Stretch2');
            if (defaultDeformClippingCheckbox.checked) defaultDeformTypes.push('Clipping');

            if (shapesData.length === 0) {
                alert("Kh√¥ng c√≥ shape n√†o ƒë·ªÉ √°p d·ª•ng.");
                return;
            }

            const confirmApply = confirm(`B·∫°n c√≥ ch·∫Øc mu·ªën √°p d·ª•ng default Std Material '${defaultStdMaterial}' v√† Deform Types '${defaultDeformTypes.join(', ')}' cho t·∫•t c·∫£ ${shapesData.length} shapes kh√¥ng? H√†nh ƒë·ªông n√†y kh√¥ng th·ªÉ ho√†n t√°c.`);
            if (!confirmApply) return;

            shapesData.forEach(shape => {
                shape.stdMaterial = defaultStdMaterial;
                shape.deformTypes = [...defaultDeformTypes]; // T·∫°o b·∫£n sao ƒë·ªÉ tr√°nh tham chi·∫øu
            });

            if (selectedShapeId) {
                renderSelectedShapeEditor(); // C·∫≠p nh·∫≠t editor n·∫øu c√≥ shape ƒëang ƒë∆∞·ª£c ch·ªçn
            }
            renderJsonOutput(); // C·∫≠p nh·∫≠t 3D view
            alert(`ƒê√£ √°p d·ª•ng gi√° tr·ªã m·∫∑c ƒë·ªãnh cho ${shapesData.length} shapes.`);
        };

        copyLineGeometryBtn.onclick = () => {
            const lineGeometryJsonString = generateJsonString(true); // true ƒë·ªÉ bao g·ªìm lines
            if (!lineGeometryJsonString) {
                alert('Kh√¥ng c√≥ d·ªØ li·ªáu Line Geometry JSON ƒë·ªÉ sao ch√©p.');
                return;
            }
            navigator.clipboard.writeText(lineGeometryJsonString).then(() => {
                alert('ƒê√£ sao ch√©p Line Geometry JSON v√†o clipboard!');
            }).catch(err => {
                console.error('L·ªói khi sao ch√©p Line Geometry JSON: ', err);
                alert('Kh√¥ng th·ªÉ t·ª± ƒë·ªông sao ch√©p JSON. Vui l√≤ng th·ª≠ l·∫°i.');
            });
        };

        copyStdGeometryBtn.onclick = () => {
            const stdGeometryJsonString = generateJsonString(false); // false ƒë·ªÉ kh√¥ng bao g·ªìm lines
            if (!stdGeometryJsonString) {
                alert('Kh√¥ng th·ªÉ t·∫°o Standard Geometry JSON.');
                return;
            }
            navigator.clipboard.writeText(stdGeometryJsonString).then(() => {
                alert('ƒê√£ sao ch√©p Standard Geometry JSON (kh√¥ng c√≥ lines) v√†o clipboard!');
            }).catch(err => {
                console.error('L·ªói khi sao ch√©p Standard Geometry JSON: ', err);
                alert('Kh√¥ng th·ªÉ t·ª± ƒë·ªông sao ch√©p JSON. Vui l√≤ng th·ª≠ l·∫°i.');
            });
        };

        // --- Initialization ---
        function init() {
            // C√≥ th·ªÉ load d·ªØ li·ªáu m·∫´u ho·∫∑c t·ª´ localStorage ·ªü ƒë√¢y

            renderShapesList();
            renderSelectedShapeEditor(); // Ban ƒë·∫ßu s·∫Ω ·∫©n editor
            renderJsonOutput(); // This will also call update3DView
            init3DViewer();
        }

        init();
    </script>
</body>

</html>