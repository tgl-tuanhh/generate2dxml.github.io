<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kitect 3D JSON Studio</title>
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            /* Ngăn cuộn ở body */
        }

        header {
            background-color: #333;
            color: white;
            padding: 10px 20px;
            text-align: center;
            position: relative;
            /* Đảm bảo absolute positioning của children là relative to header */
            display: flex;
            /* Sử dụng Flexbox */
            justify-content: space-between;
            /* Căn đều các nhóm controls */
            align-items: center;
            /* Căn giữa theo chiều dọc */
        }

        header button,
        header .btn {
            /* Target Bootstrap buttons in header too */
            /* Style chung cho các button trong header */
            padding: 0.25rem 0.5rem;
            /* Điều chỉnh padding để giảm chiều cao */
            /* background-color: #007bff; */
            /* Bootstrap handles this */
            font-size: 0.9em;
            /* color: white; */
            /* Bootstrap handles this */
            /* border: none; */
            /* Bootstrap handles this */
            border-radius: 3px;
            cursor: pointer;
            margin-left: 5px;
            /* Khoảng cách giữa các button trong cùng một nhóm */
        }

        #importJsonBtn {
            white-space: nowrap;
        }

        #uploadJsonBtn {
            white-space: nowrap;
        }

        /* header button:hover {
            background-color: #0056b3;
        } */
        /* Bootstrap handles this */

        .header-controls-group {
            display: flex;
            /* Cho phép các button trong nhóm nằm trên một hàng */
            align-items: center;
        }

        /* Có thể thêm style cụ thể cho input-controls và output-controls nếu cần */
        #create2DXmlBtn {
            background-color: red;
            /* Keep this specific style if needed */
        }

        .main-container {
            display: flex;
            flex-grow: 1;
            overflow: hidden;
            /* Cho phép các panel con cuộn */
            padding: 10px;
            gap: 10px;
        }

        .panel {
            background-color: white;
            border-radius: 5px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.1);
            padding: 15px;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            /* Cho phép cuộn nội dung panel */
        }

        #shapes-panel {
            flex: 0 0 250px;
            /* Độ rộng cố định cho panel shapes */
        }

        #editor-panel {
            flex-grow: 1;
            /* Panel editor chiếm phần còn lại */
        }

        #viewer-3d-panel {
            flex-grow: 2;
            /* Cho panel 3D chiếm nhiều không gian hơn */
            min-width: 300px;
            /* Đảm bảo có không gian tối thiểu cho view 3D */
            position: relative;
            /* Để canvas có thể được định vị tuyệt đối bên trong */
        }

        #viewer-3d-panel canvas {
            display: block;
            /* Loại bỏ khoảng trắng thừa bên dưới canvas */
            width: 100% !important;
            /* Ghi đè style mặc định của three.js nếu có */
            height: 100% !important;
        }

        textarea {
            width: calc(100% - 10px);
            /* Điều chỉnh để padding không làm vỡ layout */
            flex-grow: 1;
            margin-top: 10px;
            border: 1px solid #ccc;
            border-radius: 3px;
            padding: 5px;
            font-family: monospace;
            resize: none;
            /* Không cho phép resize textarea */
        }

        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 3px;
            cursor: pointer;
            margin-top: 5px;
            margin-bottom: 10px;
        }

        button:hover {
            background-color: #0056b3;
        }

        .shape-item {
            padding: 8px;
            border: 1px solid #eee;
            border-radius: 3px;
            margin-bottom: 5px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .shape-item:hover,
        .shape-item.selected {
            background-color: #e9ecef;
        }

        .shape-item button {
            background-color: #dc3545;
            padding: 3px 6px;
            font-size: 0.8em;
            margin: 0;
        }

        .shape-item button:hover {
            background-color: #c82333;
        }

        .section {
            margin-bottom: 15px;
            border: 1px solid #ddd;
            padding: 10px;
            border-radius: 3px;
        }

        .section h3 {
            margin-top: 0;
            font-size: 1.1em;
            color: #333;
        }

        label {
            display: block;
            margin-bottom: 3px;
            font-size: 0.9em;
            color: #555;
        }

        input[type="text"],
        input[type="number"] {
            width: calc(100% - 12px);
            /* width - padding */
            padding: 5px;
            margin-bottom: 8px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }

        .vertex-entry,
        .face-entry,
        .line-entry {
            display: flex;
            gap: 5px;
            align-items: center;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        .vertex-entry input[type="number"] {
            width: 50px;
        }

        .face-entry input[type="text"] {
            flex-grow: 1;
        }

        .vertex-list,
        .face-list,
        .line-list {
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid #eee;
            padding: 5px;
            margin-bottom: 10px;
        }

        .hidden {
            display: none;
        }

        /* Toast Styling */
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1050;
            /* Ensure toast is above other elements, including modals (Bootstrap modal z-index is 1040/1050) */
        }
        /* Styles for Shape Canvas Modal */
        .fullscreen-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 1060; /* Ensure it's above Bootstrap modals (1050) */
            display: none; /* Hidden by default */
            align-items: center;
            justify-content: center;
        }
        .modal-content-wrapper {
            background-color: #fff;
            width: 98%;
            height: 98%;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,.5);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .modal-header-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem;
            border-bottom: 1px solid #dee2e6;
        }
        .modal-header-controls h5 {
            margin-bottom: 0;
        }
        .modal-main-content {
            display: flex;
            flex-grow: 1;
            height: calc(100% - 70px); /* Adjust based on header height + padding */
            overflow: hidden; /* Prevent scrollbars on this container */
        }
        .modal-canvas-section {
            flex: 3;
            padding: 1rem;
            border-right: 1px solid #dee2e6;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden; /* Canvas itself might scroll if larger than container */
            background-color: #f8f9fa; /* Light background for canvas area */
        }
        #shapeDetailCanvas {
            max-width: 100%;
            max-height: 100%;
            border: 1px solid #ced4da;
            background-color: white;
        }
        .modal-info-section {
            flex: 1;
            padding: 1rem;
            overflow-y: auto;
            background-color: #fff;
        }
        .modal-info-section h5 {
            margin-top: 0;
            margin-bottom: 0.75rem;
        }
        .modal-info-section p {
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }
    </style>
</head>

<body>
    <header>
        <h1>Kitect 3D JSON Studio</h1>
        <div class="header-controls-group input-controls">
            <input type="text" id="objectNameInput" class="form-control form-control-sm mr-2"
                placeholder="Nhập Object Name (ví dụ: PFHP-PILLAR-B)" value="OBJECT-NAME">
            <button id="importJsonBtn" class="btn btn-primary btn-sm">Đọc Clipboard</button>
            <input type="file" id="uploadJsonFile" accept=".json" style="display: none;">
            <button id="uploadJsonBtn" class="btn btn-secondary btn-sm ml-2">Upload File</button>
        </div>
        <div class="header-controls-group main-actions">
            <button id="openOptionsModalBtn" class="btn btn-info btn-sm mr-2" data-toggle="modal"
                data-target="#optionsModal">Tùy chọn & Sao chép</button>
            <button id="create2DXmlBtn" class="btn btn-danger btn-sm"
                onclick="window.open('./generate-2d-xml.html', '_blank')">Create 2D XML</button>
        </div>
    </header>
    <div class="main-container">
        <div id="shapes-panel" class="panel">
            <h2>Shapes</h2>
            <button id="addShapeBtn">Thêm Shape Mới</button>
            <div id="shapesListContainer">
                <!-- Danh sách shapes sẽ được thêm vào đây bằng JavaScript -->
            </div>
            <div id="noShapeSelectedMsg">
                <p>Vui lòng chọn một shape từ danh sách hoặc thêm shape mới để bắt đầu chỉnh sửa.</p>
            </div>
        </div>

        <div id="editor-panel" class="panel">
            <h2 style="display: flex; align-items: center; justify-content: space-between;"><span>Editor</span><button id="openShapeCanvasModalBtn" class="btn btn-sm btn-light ml-2" style="display: none; padding: 2px 6px; line-height: 1;" title="Mở trình chỉnh sửa canvas"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-pencil-square" viewBox="0 0 16 16"><path d="M15.502 1.94a.5.5 0 0 1 0 .706L14.459 3.69l-2-2L13.502.646a.5.5 0 0 1 .707 0l1.293 1.293zm-1.75 2.456-2-2L4.939 9.21a.5.5 0 0 0-.121.196l-.805 2.414a.25.25 0 0 0 .316.316l2.414-.805a.5.5 0 0 0 .196-.12l6.813-6.813z"/><path fill-rule="evenodd" d="M1 13.5A1.5 1.5 0 0 0 2.5 15h11a1.5 1.5 0 0 0 1.5-1.5v-6a.5.5 0 0 0-1 0v6a.5.5 0 0 1-.5.5h-11a.5.5 0 0 1-.5-.5v-11a.5.5 0 0 1 .5-.5H9a.5.5 0 0 0 0-1H2.5A1.5 1.5 0 0 0 1 2.5z"/></svg></button></h2>
            <div id="shapeEditorContainer" class="hidden">
                <div class="section">
                    <h3>Thông tin Shape</h3>
                    <p><strong>Tên Shape (Line Mode):</strong> <span id="generatedShapeNameLine"></span></p>
                    <p><strong>Tên Shape (Std Mode):</strong> <span id="generatedShapeNameStd"></span></p>

                    <label for="stdMaterialInput">Std Material:</label>
                    <input type="text" id="stdMaterialInput" placeholder="Ví dụ: R110-0">

                    <h4>Deform Types</h4>
                    <div style="margin-bottom: 10px;">
                        <label style="display: inline-block; margin-right: 10px;">
                            <input type="checkbox" id="deformStretch2Checkbox"> Stretch2
                        </label>
                        <label style="display: inline-block;">
                            <input type="checkbox" id="deformClippingCheckbox"> Clipping
                        </label>
                    </div>
                    <div style="margin-bottom: 10px; font-size: 0.9em; color: #333;">
                        <strong>Current Deform Types:</strong> <span id="currentDeformTypesText"></span>
                    </div>

                    <h4>Custom Pivot (Tọa độ Local của Shape)</h4>
                    <div style="display: flex; gap: 5px; margin-bottom: 10px;">
                        <div style="flex: 1;">
                            <label for="pivotX">Pivot X:</label>
                            <input type="number" id="pivotX" value="0" step="1">
                        </div>
                        <div style="flex: 1;">
                            <label for="pivotY">Pivot Y:</label>
                            <input type="number" id="pivotY" value="0" step="1">
                        </div>
                        <div style="flex: 1;">
                            <label for="pivotZ">Pivot Z:</label>
                            <input type="number" id="pivotZ" value="0" step="1">
                        </div>
                    </div>
                </div>

                <div class="section">
                    <h3>Vertices (v)</h3>
                    <button id="addVertexBtn">Thêm Vertex</button>
                    <div class="vertex-list" id="verticesList">
                        <!-- Vertices sẽ được thêm vào đây -->
                    </div>
                </div>

                <div class="section">
                    <h3>Faces</h3>
                    <label for="faceVertices">Vertices (chỉ số, cách nhau bởi dấu phẩy):</label>
                    <input type="text" id="faceVertices" placeholder="Ví dụ: 0,1,13,12">
                    <button id="addFaceBtn">Thêm Face</button>
                    <div class="face-list" id="facesListContainer">
                        <!-- Faces sẽ được thêm vào đây -->
                    </div>
                </div>

                <div class="section">
                    <h3>Lines</h3>
                    <label for="lineVerticesInput">Vertices (ID đỉnh 1, ID đỉnh 2, cách nhau bởi dấu phẩy):</label>
                    <input type="text" id="lineVerticesInput" placeholder="Ví dụ: 0,1">
                    <button id="addLineBtn">Thêm Line</button>
                    <div class="line-list" id="linesListContainer">
                        <!-- Lines sẽ được thêm vào đây -->
                    </div>
                </div>

                <div class="section" id="transformationsSection">
                    <h3>Phép biến đổi (Transformations)</h3>

                    <div class="subsection">
                        <h4>Tịnh tiến (Translate)</h4>
                        <label for="translateX">Delta X:</label>
                        <input type="number" id="translateX" value="0" step="1">
                        <label for="translateY">Delta Y:</label>
                        <input type="number" id="translateY" value="0" step="1">
                        <label for="translateZ">Delta Z:</label>
                        <input type="number" id="translateZ" value="0" step="1">
                        <button id="applyTranslateBtn">Áp dụng Tịnh tiến</button>
                    </div>

                    <div class="subsection">
                        <h4>Xoay quanh tâm Shape (Rotate around Shape Center)</h4>
                        <p style="font-size:0.8em; color:#555;">Đơn vị: Độ. Thứ tự xoay: X -> Y -> Z.</p>
                        <label for="rotateX">Góc X:</label>
                        <input type="number" id="rotateX" value="0" step="1">
                        <label for="rotateY">Góc Y:</label>
                        <input type="number" id="rotateY" value="0" step="1">
                        <label for="rotateZ">Góc Z:</label>
                        <input type="number" id="rotateZ" value="0" step="1">
                        <button id="applyRotateBtn">Áp dụng Xoay</button>
                    </div>

                    <div class="subsection">
                        <h4>Lật qua tâm Shape (Flip around Shape Center)</h4>
                        <button id="flipXBtn">Lật qua trục X (YZ plane)</button>
                        <button id="flipYBtn">Lật qua trục Y (XZ plane)</button>
                        <button id="flipZBtn">Lật qua trục Z (XY plane)</button>
                    </div>
                </div>

            </div>
        </div>

        <div id="viewer-3d-panel" class="panel">
            <h2>3D View</h2>
            <div id="threejs-canvas-container" style="width: 100%; height: calc(100% - 40px);">
                <!-- Canvas cho Three.js sẽ được thêm vào đây -->
            </div>
        </div>
    </div>

    <!-- Toast Container -->
    <div aria-live="polite" aria-atomic="true" class="toast-container">
        <!-- Toasts will be appended here -->
    </div>

    <!-- Options Modal -->
    <div class="modal fade" id="optionsModal" tabindex="-1" aria-labelledby="optionsModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="optionsModalLabel">Tùy chọn & Sao chép</h5>
                    <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                        <span aria-hidden="true">&times;</span>
                    </button>
                </div>
                <div class="modal-body">
                    <div class="container-fluid">
                        <div class="row">
                            <div class="col-md-6">
                                <h5>Sao chép Dữ liệu</h5>
                                <button id="copyLineGeometryBtn" class="btn btn-outline-primary btn-block mb-2">Copy
                                    Line Geometry</button>
                                <button id="copyStdGeometryBtn" class="btn btn-outline-primary btn-block mb-2">Copy Std
                                    Geometry</button>
                                <button id="copyLineMeshBtn" class="btn btn-outline-success btn-block mb-2">Copy Line
                                    Mesh</button>
                                <button id="copyStdMeshBtn" class="btn btn-outline-success btn-block mb-2">Copy Std
                                    Mesh</button>
                            </div>
                            <div class="col-md-6">
                                <h5>Cài đặt Mặc định cho Shape</h5>
                                <div class="form-group">
                                    <label for="defaultStdMaterialInput">Default Std Material:</label>
                                    <input type="text" id="defaultStdMaterialInput" class="form-control form-control-sm"
                                        placeholder="Ví dụ: R110-0">
                                </div>
                                <div class="form-group">
                                    <label>Default Deform Types:</label>
                                    <div class="form-check">
                                        <input class="form-check-input" type="checkbox"
                                            id="defaultDeformStretch2Checkbox"> <!-- Bỏ checked mặc định -->
                                        <label class="form-check-label"
                                            for="defaultDeformStretch2Checkbox">Stretch2</label>
                                    </div>
                                    <div class="form-check">
                                        <input class="form-check-input" type="checkbox"
                                            id="defaultDeformClippingCheckbox">
                                        <label class="form-check-label"
                                            for="defaultDeformClippingCheckbox">Clipping</label>
                                    </div>
                                </div>
                                <button id="applyDefaultsBtn" class="btn btn-warning btn-block mt-3">Áp dụng cho tất cả
                                    Shapes hiện tại</button>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-dismiss="modal">Đóng</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.9.2/dist/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/lines/LineSegmentsGeometry.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/lines/LineMaterial.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/lines/LineSegments2.js"></script>
    <script>
        // Biến toàn cục cho modal canvas view
        let currentModalViewMode = 'oxy'; // Mặc định là Oxy
        const PIXELS_PER_UNIT_DEFAULT = 20; // For default zoom when no points or single point
        let PIXELS_PER_UNIT = PIXELS_PER_UNIT_DEFAULT; // Will be dynamically calculated
        let modalOriginX = 0; // Dynamically calculated origin X for modal canvas
        let modalOriginY = 0; // Dynamically calculated origin Y for modal canvas
        const MODAL_CANVAS_PADDING = 40; // Pixels of padding around the content when auto-fitting
        const GRID_COLOR = '#cccccc';

        // Biến toàn cục cho chế độ tương tác trong modal canvas
        let currentModalInteractionMode = 'none'; // 'none', 'addPoint', 'moveObject', etc.
        let temporaryNewPoints = []; // Mảng lưu các điểm mới được click trên canvas modal
        let selectedTemporaryPointIndex = -1; // Index của điểm tạm thời đang được chỉnh sửa tọa độ

        // Biến cho trạng thái pan chuột phải
        let isPanningWithRightMouse = false;
        let lastPanX = 0;
        let lastPanY = 0;

        const AXIS_COLOR = '#333333';
        const TEXT_COLOR = '#000000';
        // State của ứng dụng
        let shapesData = [];
        let selectedShapeId = null;
        let currentJsonString = ''; // Lưu trữ chuỗi JSON hiện tại (chủ yếu cho Line Geometry và 3D view)
        let currentObjectName = 'OBJECT-NAME'; // Lưu trữ Object Name, khởi tạo với giá trị mặc định

        // DOM Elements
        const addShapeBtn = document.getElementById('addShapeBtn');
        const shapesListContainer = document.getElementById('shapesListContainer');
        const importJsonBtn = document.getElementById('importJsonBtn');
        const copyLineGeometryBtn = document.getElementById('copyLineGeometryBtn');
        const copyStdGeometryBtn = document.getElementById('copyStdGeometryBtn');
        const copyLineMeshBtn = document.getElementById('copyLineMeshBtn');
        const copyStdMeshBtn = document.getElementById('copyStdMeshBtn');
        const objectNameInput = document.getElementById('objectNameInput');
        const uploadJsonBtn = document.getElementById('uploadJsonBtn');
        const uploadJsonFile = document.getElementById('uploadJsonFile');

        const shapeEditorContainer = document.getElementById('shapeEditorContainer');
        const noShapeSelectedMsg = document.getElementById('noShapeSelectedMsg');
        const generatedShapeNameLine = document.getElementById('generatedShapeNameLine');
        const generatedShapeNameStd = document.getElementById('generatedShapeNameStd');
        const stdMaterialInput = document.getElementById('stdMaterialInput');

        const addVertexBtn = document.getElementById('addVertexBtn');
        const verticesListContainer = document.getElementById('verticesList');

        const addFaceBtn = document.getElementById('addFaceBtn');
        const faceVerticesInput = document.getElementById('faceVertices');
        const facesListContainer = document.getElementById('facesListContainer');

        const addLineBtn = document.getElementById('addLineBtn');
        const lineVerticesInput = document.getElementById('lineVerticesInput');
        const linesListContainer = document.getElementById('linesListContainer');

        // Transformation UI Elements
        const translateXInput = document.getElementById('translateX');
        const translateYInput = document.getElementById('translateY');
        const translateZInput = document.getElementById('translateZ');
        const applyTranslateBtn = document.getElementById('applyTranslateBtn');
        const rotateXInput = document.getElementById('rotateX');
        const rotateYInput = document.getElementById('rotateY');
        const rotateZInput = document.getElementById('rotateZ');
        const applyRotateBtn = document.getElementById('applyRotateBtn');
        const flipXBtn = document.getElementById('flipXBtn');
        const flipYBtn = document.getElementById('flipYBtn');
        const flipZBtn = document.getElementById('flipZBtn');

        const currentDeformTypesText = document.getElementById('currentDeformTypesText');

        const threeJsCanvasContainer = document.getElementById('threejs-canvas-container');

        // Three.js specific variables
        let scene, camera, renderer, controls, shapesGroup;
        let vertexLabelsGroup; // Group cho các nhãn ID đỉnh
        let threeShapeObjects = {}; // Map từ shape._internalId sang { group, lineMaterial, faceMaterial, labelMaterial }

        // Materials for highlighting
        const NORMAL_LINE_COLOR = 0x0000ff;
        const HIGHLIGHTED_LINE_COLOR = 0x007bff; // Changed to Blue
        const NORMAL_FACE_COLOR = 0xcccccc;
        const HIGHLIGHTED_FACE_COLOR = 0xffd700; // Gold
        const NORMAL_LABEL_BG_COLOR = { r: 50, g: 50, b: 50, a: 0.7 };
        const HIGHLIGHTED_LABEL_BG_COLOR = { r: 255, g: 165, b: 0, a: 0.9 }; // Orange background for labels

        // Variables for modal canvas crosshair and coordinates display
        let modalCanvasMouseX = null;
        let modalCanvasMouseY = null;
        let showCrosshairAndCoords = true; // Toggle for the new feature

        // Thêm lại các khai báo biến bị thiếu
        const deformStretch2Checkbox = document.getElementById('deformStretch2Checkbox');
        const deformClippingCheckbox = document.getElementById('deformClippingCheckbox'); // ID này đã được đổi từ deformClipCheckbox
        const pivotXInput = document.getElementById('pivotX');
        const pivotYInput = document.getElementById('pivotY');
        const pivotZInput = document.getElementById('pivotZ');

        const defaultStdMaterialInput = document.getElementById('defaultStdMaterialInput');
        const defaultDeformStretch2Checkbox = document.getElementById('defaultDeformStretch2Checkbox');
        const defaultDeformClippingCheckbox = document.getElementById('defaultDeformClippingCheckbox');
        const applyDefaultsBtn = document.getElementById('applyDefaultsBtn');

        // Raycaster for picking objects
        let raycaster;
        let mouse;

        // --- Helper function to create text sprites (moved to a more global scope) ---
        function createTextSprite(message, parameters) {
            parameters = parameters || {};
            const fontface = parameters.fontface || 'Arial';
            const internalFontsize = parameters.internalFontsize || 32; // Fontsize vẽ lên canvas
            const borderThickness = parameters.borderThickness || 2;
            const borderColor = parameters.borderColor || { r: 0, g: 0, b: 0, a: 1.0 };
            const backgroundColor = parameters.backgroundColor || { r: 255, g: 255, b: 255, a: 0.8 };
            const textColor = parameters.textColor || { r: 0, g: 0, b: 0, a: 1.0 };

            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');

            context.font = 'Bold ' + internalFontsize + 'px ' + fontface;
            const metrics = context.measureText(message);
            const textWidth = metrics.width;

            canvas.width = textWidth + borderThickness * 2 + 20; // Thêm padding cho canvas
            canvas.height = internalFontsize * 1.4 + borderThickness * 2;

            context.font = 'Bold ' + internalFontsize + 'px ' + fontface;
            context.fillStyle = `rgba(${backgroundColor.r},${backgroundColor.g},${backgroundColor.b},${backgroundColor.a})`;
            context.strokeStyle = `rgba(${borderColor.r},${borderColor.g},${borderColor.b},${borderColor.a})`;
            context.lineWidth = borderThickness;

            context.fillStyle = `rgba(${textColor.r},${textColor.g},${textColor.b},${textColor.a})`;
            context.fillText(message, borderThickness + 5, internalFontsize + borderThickness);

            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter; // Thêm magFilter cho nhất quán
            texture.wrapS = THREE.ClampToEdgeWrapping;
            texture.wrapT = THREE.ClampToEdgeWrapping;

            const spriteMaterial = new THREE.SpriteMaterial({
                map: texture,
                sizeAttenuation: false, // THAY ĐỔI Ở ĐÂY: kích thước không đổi khi zoom
                transparent: true, // Cho phép background trong suốt nếu alpha < 1
                alphaTest: 0.1 // Để các pixel gần như trong suốt hoàn toàn không được vẽ
            });
            const sprite = new THREE.Sprite(spriteMaterial);

            // Điều chỉnh scale để sprite có chiều cao mong muốn 
            // Khi sizeAttenuation = false, scale này sẽ trực tiếp ảnh hưởng đến kích thước hiển thị trên màn hình.
            // Bạn có thể cần điều chỉnh giá trị này để đạt được kích thước mong muốn.
            const desiredScreenHeightFactor = parameters.worldHeight || 50; // Có thể cần đổi tên và giá trị
            // Tạm thởi giữ nguyên logic scale cũ, nhưng có thể cần điều chỉnh lại 'desiredScreenHeightFactor'
            // hoặc cách tính toán scale cho phù hợp với sizeAttenuation = false.
            // Ví dụ, bạn có thể muốn đặt một scale cố định:
            // sprite.scale.set(50, 25, 1); // Ví dụ: rộng 50 units, cao 25 units trên màn hình (cần thử nghiệm)
            sprite.scale.set((desiredScreenHeightFactor * canvas.width / canvas.height), desiredScreenHeightFactor, 1.0);

            return sprite;
        }

        // --- UUID Generation ---
        function generateUUID() {
            // Basic UUID v4 generator
            return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>
                (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
            );
        }

        // --- 3D Viewer Initialization ---
        function init3DViewer() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xeeeeee);

            // Camera
            const aspect = threeJsCanvasContainer.clientWidth / threeJsCanvasContainer.clientHeight;
            camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 10000);
            camera.position.set(100, 100, 500); // Điều chỉnh vị trí camera cho phù hợp với dữ liệu của bạn
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(threeJsCanvasContainer.clientWidth, threeJsCanvasContainer.clientHeight);
            threeJsCanvasContainer.appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(200, 500, 300);
            scene.add(directionalLight);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 10;
            controls.maxDistance = 5000;
            controls.addEventListener('change', render3DScene); // render khi có tương tác

            // Shapes Group - to hold all dynamic shapes for easy clearing
            shapesGroup = new THREE.Group();
            scene.add(shapesGroup);

            vertexLabelsGroup = new THREE.Group(); // Khởi tạo group cho nhãn
            scene.add(vertexLabelsGroup);

            // Axes Helper
            const mainAxesHelper = new THREE.AxesHelper(10000); // Tăng chiều dài trục chính
            scene.add(mainAxesHelper);

            // Grid/Ticks for Axes
            const ticksGroup = new THREE.Group();
            const tickLength = 20; // Độ dài của mỗi vạch tick
            const tickStep = 100;  // Khoảng cách giữa các vạch tick
            const axisLength = 10000; // Phải khớp với AxesHelper ở trên
            const tickMaterialX = new THREE.LineBasicMaterial({ color: 0xff0000 }); // Red for X ticks
            const tickMaterialY = new THREE.LineBasicMaterial({ color: 0x00ff00 }); // Green for Y ticks
            const tickMaterialZ = new THREE.LineBasicMaterial({ color: 0x0000ff }); // Blue for Z ticks

            function createTicksForAxis(targetAxis, length, step, tickSize, material) {
                const points = [];
                for (let i = -length; i <= length; i += step) {
                    if (i === 0) continue; // Bỏ qua gốc tọa độ

                    if (targetAxis === 'x') {
                        points.push(new THREE.Vector3(i, -tickSize / 2, 0));
                        points.push(new THREE.Vector3(i, tickSize / 2, 0));
                        points.push(new THREE.Vector3(i, 0, -tickSize / 2));
                        points.push(new THREE.Vector3(i, 0, tickSize / 2));
                    } else if (targetAxis === 'y') {
                        points.push(new THREE.Vector3(-tickSize / 2, i, 0));
                        points.push(new THREE.Vector3(tickSize / 2, i, 0));
                        points.push(new THREE.Vector3(0, i, -tickSize / 2));
                        points.push(new THREE.Vector3(0, i, tickSize / 2));
                    } else if (targetAxis === 'z') {
                        points.push(new THREE.Vector3(-tickSize / 2, 0, i));
                        points.push(new THREE.Vector3(tickSize / 2, 0, i));
                        points.push(new THREE.Vector3(0, -tickSize / 2, i));
                        points.push(new THREE.Vector3(0, tickSize / 2, i));
                    }
                }
                if (points.length > 0) {
                    const tickGeometry = new THREE.BufferGeometry().setFromPoints(points);
                    const ticks = new THREE.LineSegments(tickGeometry, material);
                    ticksGroup.add(ticks);
                }
            }

            createTicksForAxis('x', axisLength, tickStep, tickLength, tickMaterialX);
            createTicksForAxis('y', axisLength, tickStep, tickLength, tickMaterialY);
            createTicksForAxis('z', axisLength, tickStep, tickLength, tickMaterialZ);
            scene.add(ticksGroup);

            // Initialize Raycaster
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            renderer.domElement.addEventListener('pointerdown', onDocumentMouseDown, false);

            // Animation loop for controls damping
            function animate() {
                requestAnimationFrame(animate);
                controls.update(); // only required if controls.enableDamping or controls.autoRotate are set to true
                render3DScene();
            }
            animate();

            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);
            onWindowResize(); // Initial call to set size
        }

        function onWindowResize() {
            if (!renderer || !camera || !threeJsCanvasContainer) return;
            const newWidth = threeJsCanvasContainer.clientWidth;
            const newHeight = threeJsCanvasContainer.clientHeight;

            camera.aspect = newWidth / newHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(newWidth, newHeight);
            update3DView();
        }

        function render3DScene() {
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }

        // --- Update 3D View ---
        function update3DView() {
            if (!scene || !shapesGroup) return;

            // Clear previous shapes and labels first
            while (shapesGroup.children.length > 0) {
                shapesGroup.remove(shapesGroup.children[0]);
            }
            shapesGroup.clear(); // Đảm bảo group rỗng
            threeShapeObjects = {}; // Reset map object

            while (vertexLabelsGroup && vertexLabelsGroup.children.length > 0) {
                vertexLabelsGroup.remove(vertexLabelsGroup.children[0]);
            }
            if (vertexLabelsGroup) vertexLabelsGroup.clear();


            shapesData.forEach(shape => {
                const isSelected = shape._internalId === selectedShapeId;

                const shapeSpecificGroup = new THREE.Group(); // Group riêng cho mỗi shape
                shapeSpecificGroup.userData.shapeId = shape._internalId; // Store shapeId for picking
                shapesGroup.add(shapeSpecificGroup); // Thêm group của shape vào group chính

                const currentLineMaterial = new THREE.LineBasicMaterial({
                    color: isSelected ? HIGHLIGHTED_LINE_COLOR : NORMAL_LINE_COLOR,
                    depthTest: false, // Để line không bị ẩn bởi face nếu trùng
                });
                const currentFaceMaterial = new THREE.MeshStandardMaterial({
                    color: isSelected ? HIGHLIGHTED_FACE_COLOR : NORMAL_FACE_COLOR,
                    side: THREE.FrontSide,
                    metalness: 0.1,
                    roughness: 0.75,
                    depthTest: true
                });
                const currentLabelBackgroundColor = isSelected ? HIGHLIGHTED_LABEL_BG_COLOR : NORMAL_LABEL_BG_COLOR;
                const currentLabelTextColor = isSelected ? { r: 0, g: 0, b: 0, a: 1 } : { r: 255, g: 255, b: 255, a: 1 };


                // Lưu trữ các đối tượng three.js của shape này để có thể highlight sau
                threeShapeObjects[shape._internalId] = {
                    group: shapeSpecificGroup, // Group chứa tất cả elements của shape này
                    lines: null, // Sẽ được gán khi tạo LineSegments
                    mesh: null,  // Sẽ được gán khi tạo Mesh
                    labels: [] // Mảng các sprite nhãn
                };

                if (!shape.v || Object.keys(shape.v).length === 0) return;

                const vertexMap = {};
                const points = [];
                Object.keys(shape.v).sort((a, b) => parseInt(a) - parseInt(b)).forEach((key, index) => {
                    const coords = shape.v[key];
                    const pivot = shape.pivot || [0, 0, 0]; // Lấy pivot, mặc định [0,0,0]
                    const vertexPosition = new THREE.Vector3(
                        coords[0] + pivot[0],
                        coords[1] + pivot[1],
                        coords[2] + pivot[2]
                    );
                    points.push(vertexPosition);
                    vertexMap[key] = index;

                    const currentWorldHeight = 0.1; // Đặt lại kích thước nhãn mong muốn trên màn hình
                    const labelSprite = createTextSprite(key.toString(), {
                        internalFontsize: 32,    // Giữ nguyên font size cho texture sắc nét
                        worldHeight: currentWorldHeight,
                        backgroundColor: currentLabelBackgroundColor,
                        textColor: currentLabelTextColor,
                        fontface: 'monospace'
                    });
                    labelSprite.position.copy(vertexPosition);
                    labelSprite.position.y += (currentWorldHeight * 0.5) + 2;
                    if (isSelected) { // Chỉ thêm label vào group của shape nếu shape được chọn
                        shapeSpecificGroup.add(labelSprite);
                    }
                    threeShapeObjects[shape._internalId].labels.push(labelSprite); // Vẫn lưu trữ tham chiếu đến label
                });

                if (points.length === 0) return;

                if (shape.lines && shape.lines.length > 0) {
                    const linePointsForBuffer = []; // For existing LineBasicMaterial if not selected
                    const flatLineVertices = [];   // For LineMaterial if selected

                    shape.lines.forEach(line => {
                        if (vertexMap[line.v1.toString()] !== undefined && vertexMap[line.v2.toString()] !== undefined) {
                            const p1 = points[vertexMap[line.v1.toString()]];
                            const p2 = points[vertexMap[line.v2.toString()]];

                            flatLineVertices.push(p1.x, p1.y, p1.z);
                            flatLineVertices.push(p2.x, p2.y, p2.z);
                        }
                    });

                    if (flatLineVertices.length > 0) {
                        if (isSelected) { // Chỉ vẽ lines nếu shape được chọn
                            const lineGeo = new THREE.LineSegmentsGeometry();
                            lineGeo.setPositions(flatLineVertices);

                            const lineMat = new THREE.LineMaterial({
                                color: HIGHLIGHTED_LINE_COLOR,
                                linewidth: 3, // Độ dày của line (ví dụ: 3 pixels)
                                resolution: new THREE.Vector2(threeJsCanvasContainer.clientWidth, threeJsCanvasContainer.clientHeight),
                                depthTest: true, // Đổi thành true để đường bị khuất không hiển thị
                                dashed: false
                            });

                            const lineSegmentsFat = new THREE.LineSegments2(lineGeo, lineMat);
                            shapeSpecificGroup.add(lineSegmentsFat);
                            threeShapeObjects[shape._internalId].lines = lineSegmentsFat;
                        }
                    }
                }

                if (shape.faces && Object.keys(shape.faces).length > 0) {
                    const faceIndices = [];
                    Object.values(shape.faces).forEach(face => {
                        const vIndices = face.vertices;
                        const mappedVIndices = vIndices.map(vi => vertexMap[vi.toString()]).filter(vi => vi !== undefined);

                        if (mappedVIndices.length >= 3) {
                            for (let i = 1; i < mappedVIndices.length - 1; i++) {
                                faceIndices.push(mappedVIndices[0], mappedVIndices[i], mappedVIndices[i + 1]);
                            }
                        }
                    });

                    if (faceIndices.length > 0) {
                        const faceGeometry = new THREE.BufferGeometry().setFromPoints(points);
                        faceGeometry.setIndex(faceIndices);
                        faceGeometry.computeVertexNormals();
                        const mesh = new THREE.Mesh(faceGeometry, currentFaceMaterial);
                        shapeSpecificGroup.add(mesh); // Thêm mesh vào group của shape
                        threeShapeObjects[shape._internalId].mesh = mesh;
                    }
                }
            });
            render3DScene();
        }

        // --- Render Functions ---
        function renderShapesList() {
            shapesListContainer.innerHTML = '';
            if (shapesData.length === 0) {
                shapesListContainer.innerHTML = '<p>Chưa có shape nào.</p>';
            } else {
                shapesData.forEach((shape, index) => {
                    const shapeItem = document.createElement('div');
                    shapeItem.classList.add('shape-item');
                    if (shape._internalId === selectedShapeId) {
                        shapeItem.classList.add('selected');
                    }
                    // Hiển thị tên theo mode "Line" trong danh sách cho nhất quán, hoặc có thể chọn một mode cố định
                    const displayIdentifiers = generateShapeIdentifiers(index, "Line");
                    shapeItem.textContent = `Shape: ${displayIdentifiers.name}`;
                    shapeItem.dataset.shapeId = shape._internalId; // Vẫn dùng _internalId để chọn

                    const deleteBtn = document.createElement('button');
                    deleteBtn.innerHTML = '🗑️';
                    deleteBtn.title = 'Xóa Shape';
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        deleteShape(shape._internalId);
                    };

                    const copyShapeBtn = document.createElement('button');
                    copyShapeBtn.innerHTML = '📋';
                    copyShapeBtn.title = 'Sao chép Shape';
                    copyShapeBtn.style.backgroundColor = '#28a745';
                    copyShapeBtn.style.marginLeft = '5px';
                    copyShapeBtn.onclick = (e) => {
                        e.stopPropagation();
                        copyShape(shape._internalId);
                    };

                    shapeItem.appendChild(copyShapeBtn);
                    shapeItem.appendChild(deleteBtn);

                    shapeItem.onclick = () => {
                        selectShape(shape._internalId);
                    };
                    shapesListContainer.appendChild(shapeItem);
                });
            }
            // Không cần gọi update3DView ở đây nữa vì selectShape sẽ làm điều đó thông qua renderJsonOutput
        }

        function renderJsonOutput() {
            // Hàm này giờ chỉ tạo JSON cho Line Geometry và cập nhật 3D view
            currentJsonString = generateJsonString(true); // true để bao gồm lines
            update3DView(); // Update 3D view whenever JSON output changes
        }

        function generateJsonString(includeLines) {
            const shapesForJson = shapesData.map((s, index) => {
                const { _internalId, pivot, stdMaterial, deformTypes, ...shapeRest } = s; // Lấy thêm stdMaterial, deformTypes
                const currentPivot = pivot && Array.isArray(pivot) && pivot.length === 3 ? pivot : [0, 0, 0];

                const mode = includeLines ? "Line" : "Std";
                const identifiers = generateShapeIdentifiers(index, mode);

                const worldVertices = {};
                if (shapeRest.v) {
                    Object.keys(shapeRest.v).forEach(vKey => {
                        const localCoord = shapeRest.v[vKey];
                        worldVertices[vKey] = [
                            parseFloat((localCoord[0] + currentPivot[0]).toFixed(1)),
                            parseFloat((localCoord[1] + currentPivot[1]).toFixed(1)),
                            parseFloat((localCoord[2] + currentPivot[2]).toFixed(1))
                        ];
                    });
                }

                const outputShape = {
                    ...shapeRest,
                    name: identifiers.name, // Sử dụng tên được tạo động
                    uuid: identifiers.uuid, // Sử dụng UUID được tạo động
                    v: worldVertices,
                    lines: includeLines ? (shapeRest.lines || []) : []
                };
                // Không thêm stdMaterial và deformTypes vào đây vì đây là JSON cho Geometry
                return outputShape;
            });

            const output = {
                shapes: shapesForJson
            };
            return JSON.stringify(output); // Bỏ null, 2 để minimize
        }

        function renderSelectedShapeEditor() {
            if (!selectedShapeId) {
                shapeEditorContainer.classList.add('hidden');
                noShapeSelectedMsg.classList.remove('hidden');
                if (currentDeformTypesText) currentDeformTypesText.textContent = 'None';
                return;
            }

            shapeEditorContainer.classList.remove('hidden');
            noShapeSelectedMsg.classList.add('hidden');

            const shape = shapesData.find(s => s._internalId === selectedShapeId);
            if (!shape) return; // Should not happen

            const shapeIndex = shapesData.findIndex(s => s._internalId === selectedShapeId);
            if (shapeIndex === -1) return; // Should not happen

            const lineIdentifiers = generateShapeIdentifiers(shapeIndex, "Line");
            const stdIdentifiers = generateShapeIdentifiers(shapeIndex, "Std");

            generatedShapeNameLine.textContent = lineIdentifiers.name;
            generatedShapeNameStd.textContent = stdIdentifiers.name;
            // UUID hiển thị có thể lấy theo Line mode hoặc làm rõ hơn
            // generatedShapeUuid.textContent = `${lineIdentifiers.uuid} (Line Mode) / ${stdIdentifiers.uuid} (Std Mode)`; // ĐÃ XÓA

            stdMaterialInput.value = shape.stdMaterial || '';

            // Xử lý Deform Types Checkboxes
            shape.deformTypes = shape.deformTypes || [];
            deformStretch2Checkbox.checked = shape.deformTypes.includes('Stretch2');
            deformClippingCheckbox.checked = shape.deformTypes.includes('Clipping');
            updateCurrentDeformTypesText(shape.deformTypes); // Cập nhật text hiển thị

            // Hiển thị và xử lý pivot
            shape.pivot = shape.pivot || [0, 0, 0]; // Đảm bảo pivot tồn tại
            pivotXInput.value = shape.pivot[0];
            pivotYInput.value = shape.pivot[1];
            pivotZInput.value = shape.pivot[2];

            renderVerticesList(shape);
            renderFacesList(shape);
            renderLinesList(shape);
            renderJsonOutput();
        }

        function renderVerticesList(shape) {
            verticesListContainer.innerHTML = '';
            if (!shape || !shape.v) return;

            Object.entries(shape.v).forEach(([key, coords], index) => {
                const vEntry = document.createElement('div');
                vEntry.classList.add('vertex-entry');

                const idLabel = document.createElement('span');
                idLabel.textContent = `ID(${key}):`;

                // Gộp thành 1 input
                const coordsInput = document.createElement('input');
                coordsInput.type = 'text';
                coordsInput.value = coords.join(','); // Hiển thị dạng X,Y,Z
                coordsInput.dataset.vertexKey = key;
                coordsInput.style.flexGrow = 1; // Cho input chiếm nhiều không gian hơn
                coordsInput.onchange = handleVertexCoordsChange; // Hàm xử lý mới

                const copyBtn = document.createElement('button');
                copyBtn.innerHTML = '📋';
                copyBtn.title = 'Sao chép Vertex';
                copyBtn.style.backgroundColor = '#17a2b8';
                copyBtn.onclick = () => copyVertex(key);

                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = '🗑️';
                deleteBtn.title = 'Xóa Vertex';
                deleteBtn.style.backgroundColor = '#ffc107';
                deleteBtn.onclick = () => deleteVertex(key);

                vEntry.append(idLabel, coordsInput, copyBtn, deleteBtn);
                verticesListContainer.appendChild(vEntry);
            });
        }

        function renderFacesList(shape) {
            facesListContainer.innerHTML = '';
            if (!shape || !shape.faces) return;

            Object.entries(shape.faces).forEach(([key, faceData]) => {
                const fEntry = document.createElement('div');
                fEntry.classList.add('face-entry');
                fEntry.textContent = `Face ID(${key}): ${faceData.vertices.join(', ')}`;

                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = '🗑️';
                deleteBtn.title = 'Xóa Face';
                deleteBtn.style.backgroundColor = '#ffc107';
                deleteBtn.onclick = () => deleteFace(key);

                fEntry.appendChild(deleteBtn);
                facesListContainer.appendChild(fEntry);
            });
        }

        function renderLinesList(shape) {
            linesListContainer.innerHTML = '';
            if (!shape || !shape.lines) return;

            shape.lines.forEach((line, index) => {
                const lEntry = document.createElement('div');
                lEntry.classList.add('line-entry');
                lEntry.textContent = `Line: v${line.v1} - v${line.v2}`;

                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = '🗑️';
                deleteBtn.title = 'Xóa Line';
                deleteBtn.style.backgroundColor = '#ffc107';
                deleteBtn.onclick = () => deleteLine(index);

                lEntry.appendChild(deleteBtn);
                linesListContainer.appendChild(lEntry);
            });
        }


        // --- Event Handlers & Logic ---
        addShapeBtn.onclick = () => {
            const newShapeInternalId = Date.now() + Math.random(); // ID nội bộ duy nhất, không dùng cho name/uuid nữa
            const defaultStdMaterial = defaultStdMaterialInput.value.trim();
            const defaultDeformTypes = []; // Khởi tạo mảng rỗng
            if (defaultDeformStretch2Checkbox.checked) defaultDeformTypes.push('Stretch2');
            if (defaultDeformClippingCheckbox.checked) defaultDeformTypes.push('Clipping');

            const newShape = {
                _internalId: newShapeInternalId,
                // name và uuid sẽ được tạo động, không cần lưu trữ cố định trong shape object nữa
                faces: {},
                lines: [],
                v: {},
                pivot: [0, 0, 0],
                deformTypes: defaultDeformTypes, // Sử dụng giá trị default
                stdMaterial: defaultStdMaterial  // Sử dụng giá trị default
            };
            shapesData.push(newShape);
            // Không cần gán selectedShapeId ngay, vì selectShape sẽ làm điều đó thông qua renderShapesList
            renderShapesList(); // Cập nhật danh sách trước
            selectShape(newShapeInternalId); // Tự động chọn shape mới
        };

        function selectShape(shapeIdToSelect) {
            selectedShapeId = shapeIdToSelect;
            renderShapesList();
            renderSelectedShapeEditor();
            renderJsonOutput(); // Điều này sẽ gọi update3DView và áp dụng highlight

            const editBtn = document.getElementById('openShapeCanvasModalBtn');
            if (editBtn) {
                editBtn.style.display = selectedShapeId ? 'inline-block' : 'none';
            }
            // Nếu không có shape nào được chọn, đảm bảo modal cũng đóng (nếu đang mở)
            if (!selectedShapeId) {
                const shapeCanvasModal = document.getElementById('shapeCanvasModal');
                if (shapeCanvasModal && shapeCanvasModal.style.display === 'flex') {
                    shapeCanvasModal.style.display = 'none';
                }
            }
        }

        function deleteShape(shapeIdToDelete) {
            shapesData = shapesData.filter(s => s._internalId !== shapeIdToDelete);
            if (selectedShapeId === shapeIdToDelete) {
                selectedShapeId = null;
                if (currentDeformTypesText) currentDeformTypesText.textContent = 'None';
                // Xóa luôn text tên/uuid đang hiển thị trong editor
                generatedShapeNameLine.textContent = '';
                generatedShapeNameStd.textContent = '';
                // generatedShapeUuid.textContent = ''; // ĐÃ XÓA
            }
            renderShapesList();
            renderSelectedShapeEditor(); // Cập nhật editor (có thể ẩn đi)
            renderJsonOutput();
        }

        function generateShapeIdentifiers(shapeIndex, mode) {
            const baseName = currentObjectName || "DEFAULT_OBJECT";
            const suffix = mode === "Line" ? "L" : "G";
            const name = `${baseName}-${suffix}_${shapeIndex + 1}`;
            return { name: name, uuid: name }; // UUID giống hệt name
        }

        objectNameInput.onchange = (e) => {
            currentObjectName = e.target.value.trim();
            renderShapesList();
            renderSelectedShapeEditor(); // Cập nhật tên hiển thị nếu có shape đang chọn
            renderJsonOutput(); // Cập nhật JSON và 3D view
        };

        addVertexBtn.onclick = () => {
            if (!selectedShapeId) return;
            const shape = shapesData.find(s => s._internalId === selectedShapeId);
            if (!shape) return;

            const existingKeys = Object.keys(shape.v).map(k => parseInt(k)).filter(k => !isNaN(k));
            const newKey = existingKeys.length > 0 ? Math.max(...existingKeys) + 1 : 0;

            shape.v[newKey.toString()] = [0, 0, 0]; // Default coords
            renderVerticesList(shape);
            renderJsonOutput();
        };

        function handleVertexCoordsChange(event) {
            if (!selectedShapeId) return;
            const shape = shapesData.find(s => s._internalId === selectedShapeId);
            if (!shape) return;

            const vertexKey = event.target.dataset.vertexKey;
            const newCoordsStr = event.target.value.trim();
            const coordsArray = newCoordsStr.split(',').map(c => parseFloat(c.trim()));

            if (coordsArray.length === 3 && coordsArray.every(c => !isNaN(c))) {
                shape.v[vertexKey] = coordsArray;
                renderJsonOutput();
            } else {
                alert("Định dạng tọa độ không hợp lệ. Vui lòng nhập dưới dạng X,Y,Z (ví dụ: 10.5,20,30.2)");
                event.target.value = shape.v[vertexKey].join(',');
            }
        }

        function copyVertex(vertexKeyToCopy) {
            if (!selectedShapeId) {
                showToast('Vui lòng chọn một shape trước.', 'warning');
                return;
            }
            const shape = shapesData.find(s => s._internalId === selectedShapeId);

            if (!shape) {
                showToast('Không tìm thấy shape được chọn.', 'error');
                return;
            }

            // Kiểm tra shape.v và vertex nguồn
            if (typeof shape.v !== 'object' || shape.v === null || !shape.v[vertexKeyToCopy]) {
                showToast(`Không tìm thấy vertex '${vertexKeyToCopy}' hoặc dữ liệu vertices không hợp lệ.`, 'error');
                console.warn('[CopyVertex] Invalid shape.v or source vertex. Shape:', shape, 'VertexKey:', vertexKeyToCopy);
                return;
            }

            const coordsToCopy = [...shape.v[vertexKeyToCopy]];

            // Tạo key mới theo định dạng 'vN', tương tự như trong saveAndCloseModal
            let nextVertexNum = 1;
            const existingVertexKeys = Object.keys(shape.v);
            if (existingVertexKeys.length > 0) {
                const numericKeys = existingVertexKeys
                    .map(key => parseInt(String(key).replace('v', ''), 10))
                    .filter(num => !isNaN(num));
                if (numericKeys.length > 0) {
                    nextVertexNum = Math.max(...numericKeys) + 1;
                }
            }
            const newKey = String(nextVertexNum);

            shape.v[newKey] = coordsToCopy;
            renderVerticesList(shape); // Vẽ lại danh sách vertices cho shape này
            renderJsonOutput(); // Cập nhật JSON và 3D view
            showToast(`Vertex ${vertexKeyToCopy} đã được sao chép thành ${newKey}.`);
        }

        function deleteVertex(vertexKeyToDelete) {
            if (!selectedShapeId) return;
            const shape = shapesData.find(s => s._internalId === selectedShapeId);
            if (!shape || !shape.v[vertexKeyToDelete]) return;

            // Bỏ confirm, thực hiện xóa trực tiếp
            // if (confirm(`Bạn có chắc muốn xóa Vertex ID(${vertexKeyToDelete})? Điều này có thể ảnh hưởng đến Faces và Lines.`)) {
            delete shape.v[vertexKeyToDelete];
            renderVerticesList(shape);
            renderJsonOutput();
            showToast(`Đã xóa Vertex ID(${vertexKeyToDelete}). Lưu ý: Faces và Lines tham chiếu đến vertex này có thể không còn hợp lệ.`, 'warning');
            // }
        }

        addFaceBtn.onclick = () => {
            if (!selectedShapeId) return;
            const shape = shapesData.find(s => s._internalId === selectedShapeId);
            if (!shape) return;

            const verticesStr = faceVerticesInput.value.trim();
            const existingFaceKeys = Object.keys(shape.faces).map(k => parseInt(k)).filter(k => !isNaN(k));
            let newFaceKey = 0;
            if (existingFaceKeys.length > 0) {
                newFaceKey = Math.max(...existingFaceKeys) + 1;
            }
            const faceKey = newFaceKey.toString();

            if (!verticesStr) {
                showToast("Danh sách vertices cho face không được để trống.", 'error');
                return;
            }
            const verticesIndices = verticesStr.split(',').map(v => parseInt(v.trim())).filter(v => !isNaN(v));
            if (verticesIndices.length < 3) {
                showToast("Một face cần ít nhất 3 vertices.", 'error');
                return;
            }
            for (let vIndex of verticesIndices) {
                if (!shape.v[vIndex.toString()]) {
                    showToast(`Vertex ID '${vIndex}' không tồn tại trong danh sách vertices hiện tại của shape.`, 'error');
                    return;
                }
            }
            shape.faces[faceKey] = { vertices: verticesIndices };
            renderFacesList(shape);
            if (verticesIndices.length >= 2) {
                for (let i = 0; i < verticesIndices.length; i++) {
                    const vA = verticesIndices[i];
                    const vB = verticesIndices[(i + 1) % verticesIndices.length];
                    if (vA === vB || !shape.v[vA.toString()] || !shape.v[vB.toString()]) continue;
                    const lineExists = shape.lines.some(existingLine =>
                        (existingLine.v1 === vA && existingLine.v2 === vB) ||
                        (existingLine.v1 === vB && existingLine.v2 === vA)
                    );
                    if (!lineExists) {
                        shape.lines.push({ v1: vA, v2: vB });
                    }
                }
                renderLinesList(shape);
            }
            renderJsonOutput();
            faceVerticesInput.value = '';
        };

        function deleteFace(faceKeyToDelete) {
            if (!selectedShapeId) return;
            const shape = shapesData.find(s => s._internalId === selectedShapeId);
            if (!shape || !shape.faces[faceKeyToDelete]) return;
            delete shape.faces[faceKeyToDelete];
            renderFacesList(shape);
            renderJsonOutput();
        }

        addLineBtn.onclick = () => {
            if (!selectedShapeId) return;
            const shape = shapesData.find(s => s._internalId === selectedShapeId);
            if (!shape) return;
            const verticesStr = lineVerticesInput.value.trim();
            if (!verticesStr) {
                showToast("Vui lòng nhập ID của hai đỉnh, cách nhau bởi dấu phẩy.", 'error');
                return;
            }
            const parts = verticesStr.split(',');
            if (parts.length !== 2) {
                showToast("Định dạng không hợp lệ. Vui lòng nhập hai ID đỉnh, cách nhau bởi dấu phẩy (ví dụ: 0,1).", 'error');
                return;
            }
            const v1 = parseInt(parts[0].trim());
            const v2 = parseInt(parts[1].trim());
            if (isNaN(v1) || isNaN(v2)) {
                showToast("ID Vertex phải là số.", 'error');
                return;
            }
            if (!shape.v[v1.toString()]) {
                showToast(`Vertex ID '${v1}' không tồn tại trong shape này.`, 'error');
                return;
            }
            if (!shape.v[v2.toString()]) {
                showToast(`Vertex ID '${v2}' không tồn tại trong shape này.`, 'error');
                return;
            }
            if (v1 === v2) {
                showToast("Một line không thể bắt đầu và kết thúc ở cùng một vertex.", 'error');
                return;
            }
            const lineExists = shape.lines.some(existingLine =>
                (existingLine.v1 === v1 && existingLine.v2 === v2) || (existingLine.v1 === v2 && existingLine.v2 === v1)
            );
            if (lineExists) {
                showToast("Line này đã tồn tại.", 'error');
                return;
            }
            shape.lines.push({ v1: v1, v2: v2 });
            renderLinesList(shape);
            renderJsonOutput();
            lineVerticesInput.value = '';
        };

        function deleteLine(lineIndexToDelete) {
            if (!selectedShapeId) return;
            const shape = shapesData.find(s => s._internalId === selectedShapeId);
            if (!shape || !shape.lines[lineIndexToDelete]) return;
            shape.lines.splice(lineIndexToDelete, 1);
            renderLinesList(shape);
            renderJsonOutput();
        }

        // --- Transformation Functions ---
        function calculateShapeCentroid(shape) {
            if (!shape || !shape.v || Object.keys(shape.v).length === 0) {
                return new THREE.Vector3(0, 0, 0); // Default to origin if no vertices
            }
            const centroid = new THREE.Vector3(0, 0, 0);
            const vertexKeys = Object.keys(shape.v);
            vertexKeys.forEach(key => {
                centroid.add(new THREE.Vector3(...shape.v[key]));
            });
            centroid.divideScalar(vertexKeys.length);
            return centroid;
        }

        applyTranslateBtn.onclick = () => {
            if (!selectedShapeId) return;
            const shape = shapesData.find(s => s._internalId === selectedShapeId);
            if (!shape || !shape.v) return;

            // Đảm bảo shape.pivot tồn tại và là một mảng
            shape.pivot = shape.pivot && Array.isArray(shape.pivot) && shape.pivot.length === 3 ? shape.pivot : [0, 0, 0];

            const deltaX = parseFloat(translateXInput.value) || 0;
            const deltaY = parseFloat(translateYInput.value) || 0;
            const deltaZ = parseFloat(translateZInput.value) || 0;

            shape.pivot[0] = parseFloat((shape.pivot[0] + deltaX).toFixed(1));
            shape.pivot[1] = parseFloat((shape.pivot[1] + deltaY).toFixed(1));
            shape.pivot[2] = parseFloat((shape.pivot[2] + deltaZ).toFixed(1));

            // Không cần cập nhật shape.v nữa vì chúng là local
            // renderVerticesList(shape); // Không cần thiết nếu chỉ pivot thay đổi
            renderSelectedShapeEditor(); // Cập nhật giá trị pivot trên UI
            renderJsonOutput(); // Cập nhật JSON và 3D view
        };

        applyRotateBtn.onclick = () => {
            if (!selectedShapeId) return;
            const shape = shapesData.find(s => s._internalId === selectedShapeId);
            if (!shape || !shape.v) return;

            const angleX = THREE.MathUtils.degToRad(parseFloat(rotateXInput.value) || 0);
            const angleY = THREE.MathUtils.degToRad(parseFloat(rotateYInput.value) || 0);
            const angleZ = THREE.MathUtils.degToRad(parseFloat(rotateZInput.value) || 0);

            // const centroid = calculateShapeCentroid(shape); // Không cần centroid nữa vì xoay local vertices
            const euler = new THREE.Euler(angleX, angleY, angleZ, 'XYZ'); // Thứ tự xoay XYZ

            Object.keys(shape.v).forEach(key => {
                const vertex = new THREE.Vector3(...shape.v[key]); // Đây là local vertex
                // vertex.sub(centroid); // Không cần trừ centroid
                vertex.applyEuler(euler); // Xoay quanh gốc (0,0,0) của local space
                // vertex.add(centroid); // Không cần cộng lại centroid
                shape.v[key] = [
                    parseFloat(vertex.x.toFixed(1)),
                    parseFloat(vertex.y.toFixed(1)),
                    parseFloat(vertex.z.toFixed(1))
                ];
            });
            renderVerticesList(shape);
            renderJsonOutput();
        };

        function applyFlip(axis) {
            if (!selectedShapeId) return;
            const shape = shapesData.find(s => s._internalId === selectedShapeId);
            if (!shape || !shape.v) return;

            // const centroid = calculateShapeCentroid(shape); // Không cần centroid nữa

            Object.keys(shape.v).forEach(key => {
                const vertex = new THREE.Vector3(...shape.v[key]); // Local vertex
                // vertex.sub(centroid); // Không cần
                if (axis === 'x') vertex.x *= -1;
                if (axis === 'y') vertex.y *= -1;
                if (axis === 'z') vertex.z *= -1;
                // vertex.add(centroid); // Không cần
                shape.v[key] = [
                    parseFloat(vertex.x.toFixed(1)),
                    parseFloat(vertex.y.toFixed(1)),
                    parseFloat(vertex.z.toFixed(1))
                ];
            });
            renderVerticesList(shape);
            renderJsonOutput();
        }

        flipXBtn.onclick = () => applyFlip('x');
        flipYBtn.onclick = () => applyFlip('y');
        flipZBtn.onclick = () => applyFlip('z');

        pivotXInput.onchange = handlePivotChange;
        pivotYInput.onchange = handlePivotChange;
        pivotZInput.onchange = handlePivotChange;

        function handlePivotChange() {
            if (!selectedShapeId) return;
            const shape = shapesData.find(s => s._internalId === selectedShapeId);
            if (!shape) return;

            const newPivotX = parseFloat(pivotXInput.value) || 0;
            const newPivotY = parseFloat(pivotYInput.value) || 0;
            const newPivotZ = parseFloat(pivotZInput.value) || 0;

            shape.pivot = [newPivotX, newPivotY, newPivotZ];
            renderJsonOutput(); // Cập nhật 3D view và JSON
        }

        deformStretch2Checkbox.onchange = handleDeformTypeChange;
        deformClippingCheckbox.onchange = handleDeformTypeChange;

        function handleDeformTypeChange(event) {
            if (!selectedShapeId) return;
            const shape = shapesData.find(s => s._internalId === selectedShapeId);
            if (!shape) return;

            const type = event.target.id === 'deformStretch2Checkbox' ? 'Stretch2' : 'Clipping';
            shape.deformTypes = shape.deformTypes || [];

            if (event.target.checked) {
                // Thêm nếu chưa có, giữ thứ tự nếu đã có từ trước (do uncheck rồi check lại)
                if (!shape.deformTypes.includes(type)) {
                    shape.deformTypes.push(type);
                }
            } else {
                // Xóa khỏi mảng
                shape.deformTypes = shape.deformTypes.filter(dt => dt !== type);
            }
            updateCurrentDeformTypesText(shape.deformTypes); // Cập nhật text hiển thị
            // Không cần gọi renderJsonOutput() ở đây vì JSON cho LineMesh được tạo riêng khi bấm nút
        }

        function updateCurrentDeformTypesText(deformTypesArray) {
            if (currentDeformTypesText) {
                currentDeformTypesText.textContent = deformTypesArray.join(', ') || 'None';
            }
        }

        function generateLineMeshJsonString() {
            const children = shapesData.map((shape, index) => {
                const identifiers = generateShapeIdentifiers(index, "Line");
                // Đảm bảo shape.name không rỗng, nếu rỗng dùng một giá trị tạm
                // const geometryName = (shape.name && shape.name.trim() !== '') ? shape.name.trim() : `Shape_${shape._internalId}`; // Cũ
                return {
                    "@type": ".Mesh2",
                    geometry: identifiers.name, // Sử dụng tên được tạo động
                    deformTypes: shape.deformTypes && Array.isArray(shape.deformTypes) ? shape.deformTypes : ['Stretch2'],
                    material: "MF", // Giữ nguyên như logic cũ của LineMesh
                    edgeMaterial: "ML0" // Giữ nguyên
                };
            });
            return JSON.stringify({ children: children }); // Bỏ null, 2 để minimize
        }

        copyLineMeshBtn.onclick = () => {
            const lineMeshJson = generateLineMeshJsonString();
            navigator.clipboard.writeText(lineMeshJson).then(() => {
                showToast('Đã sao chép Line Mesh JSON vào clipboard!', 'success');
            }).catch(err => {
                console.error('Lỗi khi sao chép Line Mesh JSON: ', err);
                showToast('Không thể tự động sao chép Line Mesh JSON. Vui lòng thử lại.', 'error');
            });
        };

        function generateStdMeshJsonString() {
            const children = shapesData.map((shape, index) => {
                const identifiers = generateShapeIdentifiers(index, "Std");
                // const geometryName = (shape.name && shape.name.trim() !== '') ? shape.name.trim() : `Shape_${shape._internalId}`; // Cũ
                return {
                    "@type": ".Mesh2",
                    geometry: identifiers.name, // Sử dụng tên được tạo động
                    deformTypes: shape.deformTypes && Array.isArray(shape.deformTypes) ? shape.deformTypes : ['Stretch2'],
                    material: shape.stdMaterial || "",
                    matTag: "mat1"
                };
            });
            return JSON.stringify({ children: children }); // Bỏ null, 2 để minimize
        }

        copyStdMeshBtn.onclick = () => {
            const stdMeshJson = generateStdMeshJsonString();
            navigator.clipboard.writeText(stdMeshJson).then(() => {
                showToast('Đã sao chép Std Mesh JSON vào clipboard!', 'success');
            }).catch(err => {
                console.error('Lỗi khi sao chép Std Mesh JSON: ', err);
                showToast('Không thể tự động sao chép Std Mesh JSON. Vui lòng thử lại.', 'error');
            });
        };

        stdMaterialInput.onchange = (e) => {
            if (selectedShapeId) {
                const shape = shapesData.find(s => s._internalId === selectedShapeId);
                if (shape) {
                    shape.stdMaterial = e.target.value;
                    // Không cần renderJsonOutput() vì stdMaterial không ảnh hưởng trực tiếp đến 3D view hoặc JSON của các nút copy khác
                }
            }
        };

        importJsonBtn.onclick = async () => {
            try {
                const textFromClipboard = await navigator.clipboard.readText();
                if (!textFromClipboard) {
                    showToast("Clipboard rỗng hoặc không chứa dữ liệu text.", 'info');
                    return;
                }

                const parsedData = JSON.parse(textFromClipboard);

                if (!parsedData || !Array.isArray(parsedData.shapes)) {
                    showToast("Lỗi: Dữ liệu từ clipboard không phải JSON hợp lệ hoặc không có thuộc tính 'shapes' dạng mảng.", 'error');
                    return;
                }

                const isValidShapeStructure = parsedData.shapes.every(shape =>
                    typeof shape.v === 'object' && shape.v !== null &&
                    typeof shape.faces === 'object' && shape.faces !== null &&
                    Array.isArray(shape.lines)
                );

                if (!isValidShapeStructure) {
                    showToast("Lỗi: Một hoặc nhiều shape trong JSON từ clipboard không có cấu trúc v, faces, hoặc lines hợp lệ.", 'error');
                    return;
                }

                if (!currentObjectName || currentObjectName.trim() === "") {
                    showToast("Vui lòng nhập Object Name trước khi import JSON.", 'warning');
                    objectNameInput.focus();
                    return;
                }

                shapesData = parsedData.shapes.map((s, index) => {
                    const internalId = Date.now() + index + Math.random();
                    return {
                        _internalId: internalId,
                        v: s.v || {},
                        faces: s.faces || {},
                        lines: s.lines || [],
                        pivot: s.pivot && Array.isArray(s.pivot) && s.pivot.length === 3 ? s.pivot : [0, 0, 0],
                        // Nếu s.deformTypes không tồn tại, sẽ lấy từ các checkbox mặc định (giờ đây sẽ là rỗng nếu không check)
                        deformTypes: s.deformTypes && Array.isArray(s.deformTypes) ? s.deformTypes : (defaultDeformStretch2Checkbox.checked ? ['Stretch2'] : []).concat(defaultDeformClippingCheckbox.checked ? ['Clipping'] : []),
                        stdMaterial: s.stdMaterial || defaultStdMaterialInput.value.trim()
                    };
                });

                selectedShapeId = null;
                renderShapesList();
                renderSelectedShapeEditor();
                renderJsonOutput();

                if (shapesData.length > 0 && !selectedShapeId) {
                    // Option: select the first shape automatically after import
                    // selectShape(shapesData[0]._internalId);
                } else if (selectedShapeId) {
                    const currentSelectedShape = shapesData.find(s => s._internalId === selectedShapeId);
                    if (currentSelectedShape) {
                        updateCurrentDeformTypesText(currentSelectedShape.deformTypes);
                    }
                } else {
                    if (currentDeformTypesText) currentDeformTypesText.textContent = 'None';
                }

            } catch (error) {
                console.error("Lỗi khi import JSON từ clipboard:", error);
                if (error.name === 'NotAllowedError') {
                    showToast("Lỗi: Không được phép truy cập clipboard. Vui lòng cấp quyền cho trang web.", 'error');
                } else if (error instanceof SyntaxError) {
                    showToast("Lỗi: Dữ liệu trong clipboard không phải là định dạng JSON hợp lệ.", 'error');
                } else {
                    showToast("Đã xảy ra lỗi khi đọc hoặc parse JSON từ clipboard. Vui lòng kiểm tra console.", 'error');
                }
            }
        };

        uploadJsonBtn.onclick = () => {
            uploadJsonFile.click(); // Trigger click event của input file ẩn
        };

        uploadJsonFile.onchange = async (event) => {
            const file = event.target.files[0];
            if (!file) {
                showToast("Không có file nào được chọn.", 'info');
                return;
            }

            if (file.type !== "application/json") {
                showToast("Vui lòng chọn một file .json hợp lệ.", 'error');
                event.target.value = null; // Reset input file
                return;
            }

            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const textFromFile = e.target.result;
                    if (!textFromFile) {
                        showToast("File rỗng hoặc không thể đọc.", 'error');
                        event.target.value = null; // Reset input file
                        return;
                    }

                    const parsedData = JSON.parse(textFromFile);

                    if (!parsedData || !Array.isArray(parsedData.shapes)) {
                        showToast("Lỗi: Dữ liệu từ file không phải JSON hợp lệ hoặc không có thuộc tính 'shapes' dạng mảng.", 'error');
                        event.target.value = null; // Reset input file
                        return;
                    }

                    const isValidShapeStructure = parsedData.shapes.every(shape =>
                        typeof shape.v === 'object' && shape.v !== null &&
                        typeof shape.faces === 'object' && shape.faces !== null &&
                        Array.isArray(shape.lines)
                    );

                    if (!isValidShapeStructure) {
                        showToast("Lỗi: Một hoặc nhiều shape trong JSON từ file không có cấu trúc v, faces, hoặc lines hợp lệ.", 'error');
                        event.target.value = null; // Reset input file
                        return;
                    }

                    if (!currentObjectName || currentObjectName.trim() === "") {
                        showToast("Vui lòng nhập Object Name trước khi import JSON.", 'warning');
                        objectNameInput.focus();
                        event.target.value = null; // Reset input file
                        return;
                    }

                    shapesData = parsedData.shapes.map((s, index) => {
                        const internalId = Date.now() + index + Math.random();
                        return {
                            _internalId: internalId,
                            v: s.v || {},
                            faces: s.faces || {},
                            lines: s.lines || [],
                            pivot: s.pivot && Array.isArray(s.pivot) && s.pivot.length === 3 ? s.pivot : [0, 0, 0],
                            deformTypes: s.deformTypes && Array.isArray(s.deformTypes) ? s.deformTypes : (defaultDeformStretch2Checkbox.checked ? ['Stretch2'] : []).concat(defaultDeformClippingCheckbox.checked ? ['Clipping'] : []),
                            stdMaterial: s.stdMaterial || defaultStdMaterialInput.value.trim()
                        };
                    });

                    selectedShapeId = null;
                    renderShapesList();
                    renderSelectedShapeEditor();
                    renderJsonOutput();
                    showToast(`Đã import thành công dữ liệu từ file ${file.name}`, 'success');


                    if (shapesData.length > 0 && !selectedShapeId) {
                        // Option: select the first shape automatically after import
                        // selectShape(shapesData[0]._internalId);
                    } else if (selectedShapeId) {
                        const currentSelectedShape = shapesData.find(s => s._internalId === selectedShapeId);
                        if (currentSelectedShape) {
                            updateCurrentDeformTypesText(currentSelectedShape.deformTypes);
                        }
                    } else {
                        if (currentDeformTypesText) currentDeformTypesText.textContent = 'None';
                    }
                    event.target.value = null; // Reset input file sau khi xử lý thành công

                } catch (error) {
                    console.error("Lỗi khi import JSON từ file:", error);
                    if (error instanceof SyntaxError) {
                        showToast("Lỗi: Dữ liệu trong file không phải là định dạng JSON hợp lệ.", 'error');
                    } else {
                        showToast("Đã xảy ra lỗi khi đọc hoặc parse JSON từ file. Vui lòng kiểm tra console.", 'error');
                    }
                    event.target.value = null; // Reset input file
                }
            };
            reader.onerror = () => {
                showToast("Lỗi khi đọc file.", 'error');
                event.target.value = null; // Reset input file
            };
            reader.readAsText(file);
        };

        function copyShape(shapeIdToCopy) {
            // Tìm shape gốc để sao chép
            const originalShape = shapesData.find(s => s._internalId === shapeIdToCopy);
            if (!originalShape) return;

            // Tạo một bản sao sâu của shape (trừ _internalId)
            // Quan trọng: Cần sao chép sâu các object và array bên trong (v, faces, lines, pivot, deformTypes)
            const newShapeInternalId = Date.now() + Math.random();
            const newV = JSON.parse(JSON.stringify(originalShape.v || {}));
            const newFaces = JSON.parse(JSON.stringify(originalShape.faces || {}));
            const newLines = JSON.parse(JSON.stringify(originalShape.lines || []));
            const newPivot = JSON.parse(JSON.stringify(originalShape.pivot || [0, 0, 0]));
            const newDeformTypes = JSON.parse(JSON.stringify(originalShape.deformTypes || []));

            const copiedShape = {
                _internalId: newShapeInternalId,
                v: newV,
                faces: newFaces,
                lines: newLines,
                pivot: newPivot, // Sao chép pivot
                deformTypes: newDeformTypes, // Sao chép deformTypes
                stdMaterial: originalShape.stdMaterial // Sao chép stdMaterial
            };

            // Thêm shape đã sao chép vào mảng shapesData
            shapesData.push(copiedShape);

            // Cập nhật danh sách shapes và tự động chọn shape mới được sao chép
            renderShapesList();
            selectShape(newShapeInternalId); // Chọn shape mới được copy
        }

        applyDefaultsBtn.onclick = () => {
            const defaultStdMaterial = defaultStdMaterialInput.value.trim();
            const defaultDeformTypes = [];
            if (defaultDeformStretch2Checkbox.checked) defaultDeformTypes.push('Stretch2');
            if (defaultDeformClippingCheckbox.checked) defaultDeformTypes.push('Clipping');

            if (shapesData.length === 0) {
                showToast("Không có shape nào để áp dụng.", 'info');
                return;
            }

            const confirmApply = confirm(`Bạn có chắc muốn áp dụng default Std Material '${defaultStdMaterial}' và Deform Types '${defaultDeformTypes.join(', ')}' cho tất cả ${shapesData.length} shapes không? Hành động này không thể hoàn tác.`);
            if (!confirmApply) return;

            shapesData.forEach(shape => {
                shape.stdMaterial = defaultStdMaterial;
                shape.deformTypes = [...defaultDeformTypes]; // Tạo bản sao để tránh tham chiếu
            });

            if (selectedShapeId) {
                renderSelectedShapeEditor(); // Cập nhật editor nếu có shape đang được chọn
            }
            renderJsonOutput(); // Cập nhật 3D view
            showToast(`Đã áp dụng giá trị mặc định cho ${shapesData.length} shapes.`, 'success');
        };

        copyLineGeometryBtn.onclick = () => {
            const lineGeometryJsonString = generateJsonString(true); // true để bao gồm lines
            if (!lineGeometryJsonString) {
                showToast('Không có dữ liệu Line Geometry JSON để sao chép.', 'info');
                return;
            }
            navigator.clipboard.writeText(lineGeometryJsonString).then(() => {
                showToast('Đã sao chép Line Geometry JSON vào clipboard!', 'success');
            }).catch(err => {
                console.error('Lỗi khi sao chép Line Geometry JSON: ', err);
                showToast('Không thể tự động sao chép JSON. Vui lòng thử lại.', 'error');
            });
        };

        copyStdGeometryBtn.onclick = () => {
            const stdGeometryJsonString = generateJsonString(false); // false để không bao gồm lines
            if (!stdGeometryJsonString) {
                showToast('Không thể tạo Standard Geometry JSON.', 'info');
                return;
            }
            navigator.clipboard.writeText(stdGeometryJsonString).then(() => {
                showToast('Đã sao chép Standard Geometry JSON (không có lines) vào clipboard!', 'success');
            }).catch(err => {
                console.error('Lỗi khi sao chép Standard Geometry JSON: ', err);
                showToast('Không thể tự động sao chép JSON. Vui lòng thử lại.', 'error');
            });
        };

        // --- Toast Notification Function ---
        function showToast(message, type = 'info') {
            const toastContainer = document.querySelector('.toast-container');
            if (!toastContainer) return; // Should not happen if HTML is correct

            const toastId = 'toast-' + Date.now();
            let toastHeaderClass = '';
            let toastIcon = '';

            switch (type) {
                case 'success':
                    toastHeaderClass = 'bg-success text-white';
                    toastIcon = '✔️'; // Simple check icon
                    break;
                case 'error':
                    toastHeaderClass = 'bg-danger text-white';
                    toastIcon = '❌'; // Simple cross icon
                    break;
                case 'warning':
                    toastHeaderClass = 'bg-warning text-dark';
                    toastIcon = '⚠️'; // Simple warning icon
                    break;
                default: // info
                    toastHeaderClass = 'bg-info text-white';
                    toastIcon = 'ℹ️'; // Simple info icon
                    break;
            }

            const toastHTML = `
                <div id="${toastId}" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-delay="5000">
                    <div class="toast-header ${toastHeaderClass}">
                        <strong class="mr-auto">${toastIcon} Thông báo</strong>
                        <button type="button" class="ml-2 mb-1 close" data-dismiss="toast" aria-label="Close">
                            <span aria-hidden="true">&times;</span>
                        </button>
                    </div>
                    <div class="toast-body">
                        ${message}
                    </div>
                </div>
            `;

            toastContainer.insertAdjacentHTML('beforeend', toastHTML);
            const toastElement = document.getElementById(toastId);
            $(toastElement).toast('show'); // Initialize and show the toast using jQuery

            // Optional: Remove the toast from DOM after it's hidden
            $(toastElement).on('hidden.bs.toast', function () {
                this.remove();
            });
        }

        // --- Initialization ---
        function init() {
            // Có thể load dữ liệu mẫu hoặc từ localStorage ở đây
            objectNameInput.value = currentObjectName; // Đảm bảo input hiển thị giá trị khởi tạo

            renderShapesList();
            renderSelectedShapeEditor(); // Ban đầu sẽ ẩn editor
            renderJsonOutput(); // This will also call update3DView
            init3DViewer();
        }

        init();

        // --- Modal Canvas View Parameter Calculation ---
        function calculateAndUpdateModalCanvasViewParams() {
            const shapeDetailCanvas = document.getElementById('shapeDetailCanvas');
            if (!shapeDetailCanvas || !currentEditingShapeInModal) {
                console.warn("calculateAndUpdateModalCanvasViewParams: Canvas or current editing shape not available. Using defaults.");
                if (shapeDetailCanvas) { // If canvas exists, center origin with default PPU
                    PIXELS_PER_UNIT = PIXELS_PER_UNIT_DEFAULT;
                    modalOriginX = shapeDetailCanvas.width / 2;
                    modalOriginY = shapeDetailCanvas.height / 2;
                } else { // Fallback if canvas itself is missing (should not happen if modal is open)
                    PIXELS_PER_UNIT = PIXELS_PER_UNIT_DEFAULT;
                    modalOriginX = 250; // Arbitrary default
                    modalOriginY = 250; // Arbitrary default
                }
                return;
            }

            const canvasWidthForCalc = shapeDetailCanvas.width;
            const canvasHeightForCalc = shapeDetailCanvas.height;
            // Use temporaryNewPoints for fitting, as these include existing points plus newly added ones
            const pointsToConsider = temporaryNewPoints; 

            if (pointsToConsider.length > 0) {
                let minCoord1, maxCoord1, minCoord2, maxCoord2;

                if (currentModalViewMode === 'oxy') {
                    minCoord1 = Math.min(...pointsToConsider.map(p => p.x));
                    maxCoord1 = Math.max(...pointsToConsider.map(p => p.x));
                    minCoord2 = Math.min(...pointsToConsider.map(p => p.y));
                    maxCoord2 = Math.max(...pointsToConsider.map(p => p.y));
                } else if (currentModalViewMode === 'oxz') {
                    minCoord1 = Math.min(...pointsToConsider.map(p => p.x));
                    maxCoord1 = Math.max(...pointsToConsider.map(p => p.x));
                    minCoord2 = Math.min(...pointsToConsider.map(p => p.z)); 
                    maxCoord2 = Math.max(...pointsToConsider.map(p => p.z));
                } else { // oyz
                    minCoord1 = Math.min(...pointsToConsider.map(p => p.y)); 
                    maxCoord1 = Math.max(...pointsToConsider.map(p => p.y));
                    minCoord2 = Math.min(...pointsToConsider.map(p => p.z)); 
                    maxCoord2 = Math.max(...pointsToConsider.map(p => p.z));
                }

                const dataRange1 = (maxCoord1 - minCoord1);
                const dataRange2 = (maxCoord2 - minCoord2);
                let scale1 = Infinity, scale2 = Infinity;

                if (dataRange1 > 0.00001) { // Epsilon for floating point comparison
                    scale1 = (canvasWidthForCalc - MODAL_CANVAS_PADDING * 2) / dataRange1;
                }
                if (dataRange2 > 0.00001) {
                    scale2 = (canvasHeightForCalc - MODAL_CANVAS_PADDING * 2) / dataRange2;
                }
                
                if (pointsToConsider.length === 1 || (dataRange1 <= 0.00001 && dataRange2 <= 0.00001) ) {
                    PIXELS_PER_UNIT = PIXELS_PER_UNIT_DEFAULT;
                } else if (dataRange1 <= 0.00001) { // Points form a "vertical" line in current projection
                    PIXELS_PER_UNIT = (scale2 !== Infinity && scale2 > 0) ? scale2 : PIXELS_PER_UNIT_DEFAULT;
                } else if (dataRange2 <= 0.00001) { // Points form a "horizontal" line in current projection
                    PIXELS_PER_UNIT = (scale1 !== Infinity && scale1 > 0) ? scale1 : PIXELS_PER_UNIT_DEFAULT;
                } else {
                     PIXELS_PER_UNIT = Math.min(scale1, scale2);
                }
                
                // Clamp PPU. Allow very small PPU for large coordinate ranges.
        // Max PPU prevents excessive zoom for very small shapes.
        // Min PPU prevents PPU from becoming zero or negative if calculations are extreme.
        const MIN_PPU_CLAMP = 0.001; // Allow 1 world unit to be very small in pixels
        const MAX_PPU_CLAMP = 500;   // Max 500 pixels for one world unit

        if (!(PIXELS_PER_UNIT > 0 && isFinite(PIXELS_PER_UNIT))) {
            console.warn(`[CalcViewParams] PPU was calculated as non-positive/infinite (${PIXELS_PER_UNIT}). Resetting to default.`);
            PIXELS_PER_UNIT = PIXELS_PER_UNIT_DEFAULT;
        }
        PIXELS_PER_UNIT = Math.max(MIN_PPU_CLAMP, Math.min(PIXELS_PER_UNIT, MAX_PPU_CLAMP));

                const worldCenter1 = (minCoord1 + maxCoord1) / 2;
                const worldCenter2 = (minCoord2 + maxCoord2) / 2;

                modalOriginX = (canvasWidthForCalc / 2) - (worldCenter1 * PIXELS_PER_UNIT);
                modalOriginY = (canvasHeightForCalc / 2) + (worldCenter2 * PIXELS_PER_UNIT); // Canvas Y is inverted from world Y/Z

                console.log(`[CalcViewParams] View: ${currentModalViewMode}, DataRange1: (${minCoord1.toFixed(2)}-${maxCoord1.toFixed(2)}), DataRange2: (${minCoord2.toFixed(2)}-${maxCoord2.toFixed(2)})`);
                console.log(`[CalcViewParams] Calculated PPU: ${PIXELS_PER_UNIT.toFixed(2)}, Origin: (${modalOriginX.toFixed(2)}, ${modalOriginY.toFixed(2)})`);

            } else {
                // No points, use default zoom and center origin
                PIXELS_PER_UNIT = PIXELS_PER_UNIT_DEFAULT;
                modalOriginX = canvasWidthForCalc / 2;
                modalOriginY = canvasHeightForCalc / 2;
                console.log('[CalcViewParams] No points. Using default PPU and centered origin.');
            }
        }

        // --- Raycaster Click Handler ---
        function onDocumentMouseDown(event) {
            event.preventDefault();
            console.log(event);

            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(shapesGroup.children, true);

            if (intersects.length > 0) {
                let clickedObject = intersects[0].object;
                let parentGroupWithShapeId = null;
                console.log(clickedObject);

                while (clickedObject && clickedObject !== scene) {
                    if (clickedObject.userData && clickedObject.userData.shapeId) {
                        parentGroupWithShapeId = clickedObject;
                        break;
                    }
                    clickedObject = clickedObject.parent;
                }

                if (parentGroupWithShapeId) {
                    const shapeId = parentGroupWithShapeId.userData.shapeId;
                    if (shapeId && shapeId !== selectedShapeId) {
                        selectShape(shapeId);
                    }
                }
            }
        }

        // --- Shape Canvas Modal Logic ---
        let currentEditingShapeInModal = null; // Shape đang được chỉnh sửa trong modal
        const COORD_EPSILON = 0.001; // Ngưỡng để so sánh tọa độ điểm

        // Helper function to get unique points from an array based on an epsilon
        function getUniquePoints(pointsArray, epsilon) {
            const unique = [];
            pointsArray.forEach(p1 => {
                let isDuplicate = false;
                for (const p2 of unique) {
                    if (Math.abs(p1.x - p2.x) < epsilon &&
                        Math.abs(p1.y - p2.y) < epsilon &&
                        Math.abs(p1.z - p2.z) < epsilon) {
                        isDuplicate = true;
                        break;
                    }
                }
                if (!isDuplicate) {
                    unique.push(p1);
                }
            });
            return unique;
        }

        function closeShapeEditorModal() {
            const shapeCanvasModal = document.getElementById('shapeCanvasModal');
            if (shapeCanvasModal) {
                shapeCanvasModal.style.display = 'none';
            }
            currentEditingShapeInModal = null; // Xóa tham chiếu khi đóng modal
            // console.log('Modal closed, currentEditingShapeInModal:', currentEditingShapeInModal);

            // Reset trạng thái tương tác
            currentModalInteractionMode = 'none'; // Reset mode
            setActiveModalModeButton('interactionModeNoneBtn'); // Reset to 'none' mode
            if (modalClickedPointCoordsContainer) modalClickedPointCoordsContainer.style.display = 'none';
            selectedTemporaryPointIndex = -1; // Bỏ highlight tất cả các nút chế độ
            const canvas = document.getElementById('shapeDetailCanvas');
            if (canvas) {
                canvas.style.cursor = 'default';
            }
        }

        function updateShapeInList(updatedShape) {
            if (!updatedShape || !updatedShape._internalId) {
                console.error('[UpdateShape] Invalid shape or missing _internalId for update.');
                return;
            }
            // 'shapesData' là mảng toàn cục chứa các shape objects
            const index = shapesData.findIndex(s => s._internalId === updatedShape._internalId);
            if (index !== -1) {
                shapesData[index] = updatedShape;
                console.log('[UpdateShape] Shape updated in list:', updatedShape);
            } else {
                console.warn('[UpdateShape] Shape not found in list for ID:', updatedShape._internalId);
            }
        }

        // Hàm cập nhật tọa độ điểm tạm thởi từ input
        function updateTemporaryPointFromInputs() {
            console.log('[UpdateTempPoint] Function called. Selected Index:', selectedTemporaryPointIndex);
            if (selectedTemporaryPointIndex === -1 || !temporaryNewPoints[selectedTemporaryPointIndex]) {
                console.warn('[UpdateTempPoint] No temporary point selected or invalid index. Current temporaryNewPoints:', JSON.stringify(temporaryNewPoints));
                return;
            }

            const currentPoint = temporaryNewPoints[selectedTemporaryPointIndex];
            console.log(`[UpdateTempPoint] Point ${selectedTemporaryPointIndex} BEFORE update: (${currentPoint.x}, ${currentPoint.y}, ${currentPoint.z})`);

            const newX = parseFloat(modalPointXInput.value);
            const newY = parseFloat(modalPointYInput.value);
            const newZ = parseFloat(modalPointZInput.value);

            let changed = false;
            if (!isNaN(newX) && currentPoint.x !== newX) { currentPoint.x = newX; changed = true; }
            if (!isNaN(newY) && currentPoint.y !== newY) { currentPoint.y = newY; changed = true; }
            if (!isNaN(newZ) && currentPoint.z !== newZ) { currentPoint.z = newZ; changed = true; }

            if (changed) {
                console.log(`[UpdateTempPoint] Point ${selectedTemporaryPointIndex} AFTER update: (${currentPoint.x}, ${currentPoint.y}, ${currentPoint.z})`);
                console.log('[UpdateTempPoint] Calling drawModalCanvas() to refresh.');
                drawModalCanvas(); // Vẽ lại toàn bộ modal canvas để phản ánh thay đổi
            } else {
                console.log(`[UpdateTempPoint] No change in values for point ${selectedTemporaryPointIndex}.`);
            }
        }

        function saveAndCloseModal() {
    console.log('[SaveModal] Attempting to save changes...');
    try {
        if (!currentEditingShapeInModal) {
            console.log('[SaveModal] No shape currently being edited.');
            showToast('Không có shape nào đang được chỉnh sửa.', 'info');
            return; 
        }
        if (!temporaryNewPoints || temporaryNewPoints.length === 0) {
            console.log('[SaveModal] No new temporary points to save.');
            showToast('Không có điểm tạm thời nào để lưu.', 'info');
            return;
        }

        // 1. Lọc các điểm duy nhất từ temporaryNewPoints
        const uniqueTempPoints = getUniquePoints(temporaryNewPoints, COORD_EPSILON);
        if (uniqueTempPoints.length === 0) {
            console.log('[SaveModal] All temporary points were duplicates of each other or list was empty after filtering.');
            showToast('Không có điểm mới hợp lệ nào để thêm (có thể tất cả đều trùng lặp).', 'info');
            return;
        }

        // Đảm bảo currentEditingShapeInModal.v là một đối tượng
        if (typeof currentEditingShapeInModal.v !== 'object' || currentEditingShapeInModal.v === null) {
            currentEditingShapeInModal.v = {};
        }

        // 2. Xác định ID số tiếp theo cho vertex (ví dụ: 0, 1, 2, ...)
        let nextVertexNum = 0; // Bắt đầu từ 0 nếu không có key số nào tồn tại
        const existingVertexKeys = Object.keys(currentEditingShapeInModal.v);
        
        if (existingVertexKeys.length > 0) {
            const numericStringKeys = existingVertexKeys.filter(key => /^\d+$/.test(key)); // Lọc các key là chuỗi số
            
            if (numericStringKeys.length > 0) {
                const numericKeysAsNumbers = numericStringKeys.map(key => parseInt(key, 10));
                nextVertexNum = Math.max(...numericKeysAsNumbers) + 1;
            }
            // Nếu không có key dạng số nào (ví dụ: chỉ có "v0", "v1"), nextVertexNum sẽ vẫn là 0.
        }
        console.log(`[SaveModal] Starting new numeric vertex ID from ${nextVertexNum}`);

        let addedPointsCount = 0;
        uniqueTempPoints.forEach(pointObj => {
            // 3. Kiểm tra trùng lặp với các vertex hiện có trong shape
            let isDuplicateWithExisting = false;
            for (const vertexKey in currentEditingShapeInModal.v) {
                const existingVertexArray = currentEditingShapeInModal.v[vertexKey]; // Dạng [x, y, z]
                if (Math.abs(existingVertexArray[0] - pointObj.x) < COORD_EPSILON &&
                    Math.abs(existingVertexArray[1] - pointObj.y) < COORD_EPSILON &&
                    Math.abs(existingVertexArray[2] - pointObj.z) < COORD_EPSILON) {
                    isDuplicateWithExisting = true;
                    console.log(`[SaveModal] Point (${pointObj.x.toFixed(2)}, ${pointObj.y.toFixed(2)}, ${pointObj.z.toFixed(2)}) is a duplicate of existing vertex ${vertexKey}. Skipping.`);
                    break;
                }
            }

            if (!isDuplicateWithExisting) {
                const newVertexId = String(nextVertexNum); // Định dạng ID là "0", "1", ...
                currentEditingShapeInModal.v[newVertexId] = [pointObj.x, pointObj.y, pointObj.z];
                console.log(`[SaveModal] Added vertex ${newVertexId}: [${pointObj.x.toFixed(2)}, ${pointObj.y.toFixed(2)}, ${pointObj.z.toFixed(2)}]`);
                nextVertexNum++; // Tăng số hiệu cho ID tiếp theo
                addedPointsCount++;
            }
        });

        if (addedPointsCount > 0) {
            console.log('[SaveModal] Vertices object after adding new points:', JSON.stringify(currentEditingShapeInModal.v));
            updateShapeInList(currentEditingShapeInModal); // Cập nhật trong danh sách shapesData
            renderShapesList(); // Vẽ lại danh sách shape UI
            selectShape(currentEditingShapeInModal._internalId); // Chọn lại shape vừa sửa
            renderSelectedShapeEditor(); // Cập nhật editor panel
            update3DView(); // Cập nhật view 3D

            showToast(`Đã thêm ${addedPointsCount} điểm mới vào shape '${currentEditingShapeInModal.n || currentEditingShapeInModal.name}'.`);
        } else {
            showToast('Không có điểm mới nào được thêm (tất cả đều trùng với các điểm đã có hoặc đã tồn tại trong danh sách tạm thời).', 'info');
        }

    } catch (error) {
        console.error('[SaveModal] Error during save operation:', error);
        showToast('Lỗi: Không thể lưu các thay đổi. Vui lòng kiểm tra Console.', 'error');
    } finally {
        closeShapeEditorModal(); // Đảm bảo modal luôn đóng và reset trạng thái
    }
}

        // Cập nhật nút đóng trên HTML của modal để gọi hàm này
        // Ví dụ: onclick="closeShapeEditorModal()"

        document.addEventListener('DOMContentLoaded', () => {
            const openShapeCanvasModalBtn = document.getElementById('openShapeCanvasModalBtn');

        if (openShapeCanvasModalBtn) {
            openShapeCanvasModalBtn.addEventListener('click', () => {
                setActiveModalModeButton('interactionModeNoneBtn'); // Set default mode on open
                const shapeCanvasModal = document.getElementById('shapeCanvasModal');
                const shapeDetailCanvas = document.getElementById('shapeDetailCanvas');
                const modalCanvasContainer = document.getElementById('modalCanvasContainer');
                const shapeCanvasModalTitle = document.getElementById('shapeCanvasModalTitle');
                const modalInfoContent = document.getElementById('modalInfoContent');

                if (!shapeCanvasModal) {
                    console.error('Shape Canvas Modal element not found on click!');
                    showToast('Lỗi: Không tìm thấy modal canvas (click).', 'error');
                    return;
                }

                if (!selectedShapeId) {
                    showToast('Vui lòng chọn một shape để chỉnh sửa.', 'warning');
                    return;
                }
                const shape = shapesData.find(s => s._internalId === selectedShapeId);
                if (!shape) {
                    showToast('Không tìm thấy shape được chọn.', 'error');
                    currentEditingShapeInModal = null;
                    return;
                }
                currentEditingShapeInModal = shape; // Lưu shape đang được focus

                const shapeIndex = shapesData.findIndex(s => s._internalId === shape._internalId);
                let shapeDisplayName = 'Unnamed Shape';
                if (shapeIndex !== -1) {
                    const identifiers = generateShapeIdentifiers(shapeIndex, 'Line'); // Lấy tên dạng 'L'
                    shapeDisplayName = identifiers.name;
                }

                console.log('Modal Open: Target title element:', shapeCanvasModalTitle);
                console.log('Modal Open: Current shape object:', shape);
                console.log('Modal Open: Shape name to display (from generateShapeIdentifiers):', shapeDisplayName);

                if (shapeCanvasModalTitle) {
                    shapeCanvasModalTitle.textContent = `Canvas Editor: ${shapeDisplayName}`;
                }
                console.log('[DebugModalOpen] About to show modal.');
                shapeCanvasModal.style.display = 'flex';
                console.log('[DebugModalOpen] Modal display set to flex.');

                if (shapeDetailCanvas && modalCanvasContainer) {
                    let shapeDetailCtx = shapeDetailCanvas.getContext('2d');
                    const containerWidth = modalCanvasContainer.clientWidth;
                    const containerHeight = modalCanvasContainer.clientHeight;
                    shapeDetailCanvas.width = containerWidth > 20 ? containerWidth - 20 : 200; 
                    shapeDetailCanvas.height = containerHeight > 20 ? containerHeight - 20 : 150;

                    currentModalViewMode = 'oxy'; // Đặt lại view mặc định khi mở modal
                    setActiveViewButton('viewOxyBtn'); // Highlight nút mặc định

                    // Reset trạng thái tương tác khi mở modal
                    currentModalInteractionMode = 'none';
                    temporaryNewPoints = []; // Khởi tạo mảng điểm tạm thởi
                    // setActiveModalModeButton(null); // This was causing the issue, mode is already set.
                    if (shapeDetailCanvas) shapeDetailCanvas.style.cursor = 'default';

                    // Nạp các điểm hiện có của shape vào temporaryNewPoints để hiển thị
                    if (currentEditingShapeInModal && currentEditingShapeInModal.v) {
                        console.log('[OpenModal] Loading existing vertices into temporaryNewPoints. Original vertices:', JSON.stringify(currentEditingShapeInModal.v));
                        for (const vertexId in currentEditingShapeInModal.v) {
                            if (Object.hasOwnProperty.call(currentEditingShapeInModal.v, vertexId)) {
                                const vCoords = currentEditingShapeInModal.v[vertexId]; // [x, y, z]
                                if (Array.isArray(vCoords) && vCoords.length === 3) {
                                    temporaryNewPoints.push({ x: vCoords[0], y: vCoords[1], z: vCoords[2], originalId: vertexId }); // Lưu originalId để có thể xử lý sau này
                                } else {
                                    console.warn(`[OpenModal] Vertex ${vertexId} has invalid format:`, vCoords);
                                }
                            }
                        }
                        console.log('[OpenModal] temporaryNewPoints after loading existing vertices:', JSON.stringify(temporaryNewPoints));
                        // TODO: Cần cơ chế để phân biệt điểm cũ và điểm mới khi LƯU để tránh nhân bản.
                        // Hiện tại, hàm saveAndCloseModal sẽ coi tất cả điểm trong temporaryNewPoints là điểm mới.
                    }

                    calculateAndUpdateModalCanvasViewParams(); // Calculate PPU and origin

                    drawModalCanvas();
                } else {
                    if (!shapeDetailCanvas) console.error('shapeDetailCanvas not found');
                    if (!modalCanvasContainer) console.error('modalCanvasContainer not found');
                }

                if(modalInfoContent) {
                    modalInfoContent.innerHTML = `<h5>${shapeDisplayName}</h5>
                                        <p><strong>ID:</strong> ${shape._internalId}</p>
                                        <p><strong>Loại:</strong> ${shape.type}</p>
                                        <p><strong>Số đỉnh:</strong> ${shape.vertices && typeof shape.vertices === 'object' ? Object.keys(shape.vertices).length : 0}</p>
                                        <p><strong>Số mặt:</strong> ${shape.faces && Array.isArray(shape.faces) ? shape.faces.length : 0}</p>
                                        <p><strong>Số đường:</strong> ${shape.lines && Array.isArray(shape.lines) ? shape.lines.length : 0}</p>
                                        <!-- Thêm thông tin khác nếu cần -->`;
                } else {
                    const modalInfoSection = document.getElementById('modalInfoSection');
                    if(modalInfoSection) modalInfoSection.innerHTML = '<p>Lỗi khi tải chi tiết shape.</p>';
                    else console.error('modalInfoContent and modalInfoSection not found');
                }
                if (modalClickedPointCoordsContainer) modalClickedPointCoordsContainer.style.display = 'none'; // Ẩn input tọa độ
                if (modalPointXInput) modalPointXInput.value = '';
                if (modalPointYInput) modalPointYInput.value = '';
                if (modalPointZInput) modalPointZInput.value = '';
            });
        }

function calculateNiceGridStep(pixelsPerUnit, minPixelSpacing = 40, maxPixelSpacing = 100) {
    if (pixelsPerUnit <= 0) {
        return { worldStep: 1, pixelStep: PIXELS_PER_UNIT_DEFAULT }; // Fallback
    }

    const niceSteps = [0.001, 0.002, 0.005, 0.01, 0.02, 0.05, 0.1, 0.2, 0.25, 0.5, 1, 2, 2.5, 5, 10, 20, 25, 50, 100, 200, 250, 500, 1000];
    
    let bestWorldStep = 1;
    let bestPixelStep = pixelsPerUnit; 

    const targetPixelStep = (minPixelSpacing + maxPixelSpacing) / 2;
    let smallestDiff = Infinity;

    for (const worldStep of niceSteps) {
        const currentPixelStep = worldStep * pixelsPerUnit;
        if (currentPixelStep >= minPixelSpacing && currentPixelStep <= maxPixelSpacing) {
            const diff = Math.abs(currentPixelStep - targetPixelStep);
            if (diff < smallestDiff) {
                smallestDiff = diff;
                bestWorldStep = worldStep;
                bestPixelStep = currentPixelStep;
            }
        }
    }
    
    if (smallestDiff === Infinity) { // If no step fits the range, find the closest one
        for (const worldStep of niceSteps) {
            const currentPixelStep = worldStep * pixelsPerUnit;
            const diff = Math.abs(currentPixelStep - targetPixelStep);
            if (diff < smallestDiff) {
                smallestDiff = diff;
                bestWorldStep = worldStep;
                bestPixelStep = currentPixelStep;
            }
        }
    }
    
    // Ensure pixelStep is not too small, making grid lines indistinguishable
    if (bestPixelStep < 5 && pixelsPerUnit > 0) { 
        for (const worldStep of niceSteps) {
            if (worldStep * pixelsPerUnit > 5) { // Find first nice step that results in pixelStep > 5
                bestWorldStep = worldStep;
                bestPixelStep = worldStep * pixelsPerUnit;
                break;
            }
        }
        // If still too small (e.g., pixelsPerUnit is extremely small), fallback to a default pixelStep
        if (bestPixelStep < 5) {
             bestPixelStep = minPixelSpacing; // Or some other sensible default
             bestWorldStep = bestPixelStep / pixelsPerUnit;
        }
    }

    return { worldStep: bestWorldStep, pixelStep: bestPixelStep };
}

        function drawGridAndAxes(ctx, viewMode, canvasWidth, canvasHeight, originX, originY, pixelsPerUnit) {
            const axisColor = '#FF0000'; 
            const gridColor = '#CCCCCC'; 
            const textColor = '#000000'; 
            const lineWidthThin = 0.5;
            const lineWidthThick = 1;

            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // Tính toán bước lưới "đẹp"
            const { worldStep: gridWorldStep, pixelStep: gridPixelStep } = calculateNiceGridStep(pixelsPerUnit);
            
            if (gridPixelStep <= 0) { 
                console.warn("[drawGridAndAxes] Invalid gridPixelStep:", gridPixelStep, "pixelsPerUnit:", pixelsPerUnit, "Falling back or skipping grid.");
                // Fallback: Vẽ trục chính nếu pixelsPerUnit hợp lệ
                if (pixelsPerUnit > 0) {
                    ctx.beginPath();
                    ctx.strokeStyle = axisColor;
                    ctx.lineWidth = lineWidthThick;
                    ctx.moveTo(0, originY);
                    ctx.lineTo(canvasWidth, originY);
                    ctx.moveTo(originX, 0);
                    ctx.lineTo(originX, canvasHeight);
                    ctx.stroke();
                    ctx.fillStyle = textColor;
                    ctx.fillText('0', originX + 10, originY + 10);
                }
                return;
            }

            // --- Vẽ Lưới ---
            ctx.beginPath();
            ctx.strokeStyle = gridColor;
            ctx.lineWidth = lineWidthThin;

            // Lưới dọc (song song với trục Y của canvas)
            let currentWorldValX = Math.ceil(((0 - originX) / pixelsPerUnit) / gridWorldStep) * gridWorldStep;
            let safetyCountX = 0;
            while (safetyCountX++ < (canvasWidth / gridPixelStep) + 5) { // Safety break
                const canvasX = originX + currentWorldValX * pixelsPerUnit;
                if (canvasX > canvasWidth + gridPixelStep) break;
                if (canvasX >= -gridPixelStep) { // Chỉ vẽ nếu nó gần hoặc trong viewport
                    ctx.moveTo(canvasX, 0);
                    ctx.lineTo(canvasX, canvasHeight);
                }
                currentWorldValX += gridWorldStep;
            }

            // Lưới ngang (song song với trục X của canvas)
            // worldY tại đáy canvas (pixel Y = canvasHeight) là ((originY - canvasHeight) / pixelsPerUnit)
            let currentWorldValY = Math.ceil(((originY - canvasHeight) / pixelsPerUnit) / gridWorldStep) * gridWorldStep;
            let safetyCountY = 0;
            while (safetyCountY++ < (canvasHeight / gridPixelStep) + 5) { // Safety break
                const canvasY = originY - currentWorldValY * pixelsPerUnit; // Trừ vì Y thế giới ngược Y canvas
                if (canvasY < -gridPixelStep) break;
                if (canvasY <= canvasHeight + gridPixelStep) { // Chỉ vẽ nếu nó gần hoặc trong viewport
                    ctx.moveTo(0, canvasY);
                    ctx.lineTo(canvasWidth, canvasY);
                }
                currentWorldValY += gridWorldStep;
            }
            ctx.stroke();

            // --- Vẽ Trục Tọa Độ --- (Vẫn giữ nguyên, vì trục chính là đường tại originX, originY)
            ctx.beginPath();
            ctx.strokeStyle = axisColor;
            ctx.lineWidth = lineWidthThick;
            ctx.moveTo(0, originY); // Trục X (đường y = world 0)
            ctx.lineTo(canvasWidth, originY);
            ctx.moveTo(originX, 0); // Trục Y (đường x = world 0)
            ctx.lineTo(originX, canvasHeight);
            ctx.stroke();

            // --- Vẽ Nhãn Số trên Trục ---
            ctx.fillStyle = textColor;
            const labelOffset = 10;

            function formatLabel(value, step) {
                if (step >= 1) return String(Math.round(value));
                const stepStr = String(step);
                const decimalPlaces = stepStr.includes('.') ? stepStr.split('.')[1].length : 0;
                return value.toFixed(Math.min(2, decimalPlaces)); // Giới hạn tối đa 2 chữ số thập phân, hoặc theo step
            }

            // Nhãn trên trục X (dọc theo đường y = originY)
            if (originY >= -labelOffset && originY <= canvasHeight + labelOffset) { // Chỉ vẽ nếu trục X chính hiển thị
                currentWorldValX = Math.ceil(((0 - originX) / pixelsPerUnit) / gridWorldStep) * gridWorldStep;
                safetyCountX = 0;
                while (safetyCountX++ < (canvasWidth / gridPixelStep) + 5) {
                    const canvasX = originX + currentWorldValX * pixelsPerUnit;
                    if (canvasX > canvasWidth + gridPixelStep) break;
                    if (canvasX >= -gridPixelStep - labelOffset) { // Buffer cho label
                        if (Math.abs(currentWorldValX) > gridWorldStep * 0.0001 || Math.abs(currentWorldValX) === 0) { // Vẽ '0' nếu là gốc, hoặc các số khác
                           // Avoid drawing label '0' if originX itself is not on this tick
                           if (Math.abs(currentWorldValX) === 0 && Math.abs(originX - canvasX) > gridPixelStep * 0.1) {
                               // This is world 0, but originX (canvas projection of world 0) is not here, so don't label this tick as 0.
                           } else {
                               ctx.fillText(formatLabel(currentWorldValX, gridWorldStep), canvasX, originY + labelOffset);
                           }
                        }
                    }
                    currentWorldValX += gridWorldStep;
                }
            }

            // Nhãn trên trục Y (dọc theo đường x = originX)
            if (originX >= -labelOffset && originX <= canvasWidth + labelOffset) { // Chỉ vẽ nếu trục Y chính hiển thị
                currentWorldValY = Math.ceil(((originY - canvasHeight) / pixelsPerUnit) / gridWorldStep) * gridWorldStep;
                safetyCountY = 0;
                while (safetyCountY++ < (canvasHeight / gridPixelStep) + 5) {
                    const canvasY = originY - currentWorldValY * pixelsPerUnit;
                    if (canvasY < -gridPixelStep) break;
                    if (canvasY <= canvasHeight + gridPixelStep + labelOffset) { // Buffer cho label
                         if (Math.abs(currentWorldValY) > gridWorldStep * 0.0001 || Math.abs(currentWorldValY) === 0) {
                            if (Math.abs(currentWorldValY) === 0 && Math.abs(originY - canvasY) > gridPixelStep * 0.1) {
                                // World 0, but originY is not here.
                            } else {
                                ctx.fillText(formatLabel(currentWorldValY, gridWorldStep), originX + labelOffset, canvasY);
                            }
                        }
                    }
                    currentWorldValY += gridWorldStep;
                }
            }
            
            // Nhãn gốc tọa độ '0' - vẽ một cách rõ ràng nếu gốc (originX, originY) nằm trong canvas
            // và chưa được vẽ bởi logic ở trên (trường hợp currentWorldValX/Y là 0)
            if (originX >= -labelOffset && originX <= canvasWidth + labelOffset && 
                originY >= -labelOffset && originY <= canvasHeight + labelOffset) {
                // Check if '0' label for X axis would have been drawn near originX
                let xZeroDrawn = false;
                if (originY >= -labelOffset && originY <= canvasHeight + labelOffset) {
                    if (Math.abs( (0 - originX) / pixelsPerUnit ) < gridWorldStep * 0.5) xZeroDrawn = true;
                }
                // Check if '0' label for Y axis would have been drawn near originY
                let yZeroDrawn = false;
                if (originX >= -labelOffset && originX <= canvasWidth + labelOffset) {
                     if (Math.abs( (originY - 0) / pixelsPerUnit ) < gridWorldStep * 0.5) yZeroDrawn = true;
                }
                // If origin is a grid intersection and labels for 0 on X and Y axes were already drawn, this specific '0' might be redundant
                // However, the logic above tries to draw 0 if currentWorldVal is 0.
                // This explicit '0' ensures it's there if origin itself is on screen.
                // The conditions in the loops above for currentWorldValX/Y === 0 should ideally handle it.
                // Let's simplify: if origin is on screen, draw '0'. The loops above might skip it if origin is not a grid line itself.
                 ctx.fillText('0', originX + labelOffset, originY + labelOffset);
            }

            // --- Vẽ tên trục ---
            ctx.font = 'bold 12px Arial';
            let axisLabelX = 'X';
            let axisLabelY = 'Y';

            if (viewMode === 'oxy') { axisLabelX = 'X'; axisLabelY = 'Y'; }
            else if (viewMode === 'oxz') { axisLabelX = 'X'; axisLabelY = 'Z'; }
            else if (viewMode === 'oyz') { axisLabelX = 'Y'; axisLabelY = 'Z'; }

            ctx.fillText(axisLabelX, canvasWidth - 15, originY - 15);
            ctx.fillText(axisLabelY, originX + 15, 15);
        }

        // Helper function to get scaled mouse coordinates on canvas
function getScaledMouseCoordinatesOnCanvas(event, canvasElement) {
    if (!canvasElement) return { x: 0, y: 0 };
    const canvasRect = canvasElement.getBoundingClientRect();

    // Mouse coordinates relative to the canvas element's top-left corner
    const mouseX_relative_to_canvas_element = event.clientX - canvasRect.left;
    const mouseY_relative_to_canvas_element = event.clientY - canvasRect.top;

    // Adjust mouse coordinates if the canvas's display size is different from its drawing surface size
    const scaleX = canvasElement.width / canvasRect.width;
    const scaleY = canvasElement.height / canvasRect.height;

    const finalCanvasX = mouseX_relative_to_canvas_element * scaleX;
    const finalCanvasY = mouseY_relative_to_canvas_element * scaleY;

    return { x: finalCanvasX, y: finalCanvasY };
}

function drawModalCanvas() { 
            const canvas = document.getElementById('shapeDetailCanvas');
            if (!canvas) {
                console.error('drawModalCanvas: Canvas element #shapeDetailCanvas not found!');
                return;
            }
            const ctx = canvas.getContext('2d');
            if (!ctx) {
                console.error('drawModalCanvas: Failed to get 2D context from canvas.');
                return;
            }

            // If not in 'addPoint' mode AND no shape is being edited, then we can't draw meaningfully.
            // However, if in 'addPoint' mode, we might want to draw grid/crosshair even without a shape.
            if (currentModalInteractionMode !== 'addPoint' && !currentEditingShapeInModal) {
                console.warn('drawModalCanvas: currentEditingShapeInModal is null and not in addPoint mode. Cannot draw.');
                ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas if we are returning early
                return;
            }
            // If in 'addPoint' mode but no shape, we proceed, but some features depending on shape details might use defaults.
            console.log(`Attempting to draw modal canvas. View: ${currentModalViewMode}, Shape ID: ${currentEditingShapeInModal._internalId}, Canvas WxH: ${canvas.width}x${canvas.height}, PPU: ${PIXELS_PER_UNIT.toFixed(2)}, Origin: (${modalOriginX.toFixed(2)}, ${modalOriginY.toFixed(2)})`);
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            drawGridAndAxes(ctx, currentModalViewMode, canvas.width, canvas.height, modalOriginX, modalOriginY, PIXELS_PER_UNIT);
            drawTemporaryPoints(ctx, modalOriginX, modalOriginY, PIXELS_PER_UNIT, currentModalViewMode); 
            // TODO: Gọi drawShapeProjection(...) với các tham số tương tự

            // Draw crosshair and coordinates if mouse is over canvas
            // Draw crosshair and coordinates if in 'addPoint' mode and mouse is over canvas
            // Now allows drawing even if currentEditingShapeInModal is null, using default Z/Y/X for the third dimension.
            if (showCrosshairAndCoords && currentModalInteractionMode === 'addPoint' && modalCanvasMouseX !== null && modalCanvasMouseY !== null && canvas) {
                console.log('[CrosshairDebug] Drawing crosshair and coords block. Mouse:', modalCanvasMouseX, modalCanvasMouseY, 'Mode:', currentModalInteractionMode, 'ShapeID:', currentEditingShapeInModal._internalId );
                ctx.save(); // Save context state
                ctx.strokeStyle = 'rgba(100, 100, 100, 0.7)';
                ctx.lineWidth = 0.5;
                ctx.fillStyle = 'black';
                ctx.font = '10px Arial';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'bottom';

                // Draw horizontal line (clipped to canvas)
                ctx.beginPath();
                ctx.moveTo(0, modalCanvasMouseY);
                ctx.lineTo(canvas.width, modalCanvasMouseY);
                ctx.stroke();

                // Draw vertical line (clipped to canvas)
                ctx.beginPath();
                ctx.moveTo(modalCanvasMouseX, 0);
                ctx.lineTo(modalCanvasMouseX, canvas.height);
                ctx.stroke();

                // Calculate world coordinates from modalCanvasMouseX/Y (which are canvas-relative)
                let worldDspX, worldDspY, worldDspZ; // Coordinates for display
                if (currentModalViewMode === 'oxy') {
                    worldDspX = (modalCanvasMouseX - modalOriginX) / PIXELS_PER_UNIT;
                    worldDspY = (modalOriginY - modalCanvasMouseY) / PIXELS_PER_UNIT;
                    worldDspZ = (currentEditingShapeInModal && currentEditingShapeInModal.vertices && Object.keys(currentEditingShapeInModal.vertices).length > 0) ? (currentEditingShapeInModal.vertices[Object.keys(currentEditingShapeInModal.vertices)[0]]?.z || 0) : 0;
                } else if (currentModalViewMode === 'oxz') {
                    worldDspX = (modalCanvasMouseX - modalOriginX) / PIXELS_PER_UNIT;
                    worldDspZ = (modalOriginY - modalCanvasMouseY) / PIXELS_PER_UNIT;
                    worldDspY = (currentEditingShapeInModal && currentEditingShapeInModal.vertices && Object.keys(currentEditingShapeInModal.vertices).length > 0) ? (currentEditingShapeInModal.vertices[Object.keys(currentEditingShapeInModal.vertices)[0]]?.y || 0) : 0;
                } else if (currentModalViewMode === 'oyz') {
                    worldDspY = (modalCanvasMouseX - modalOriginX) / PIXELS_PER_UNIT;
                    worldDspZ = (modalOriginY - modalCanvasMouseY) / PIXELS_PER_UNIT;
                    worldDspX = (currentEditingShapeInModal && currentEditingShapeInModal.vertices && Object.keys(currentEditingShapeInModal.vertices).length > 0) ? (currentEditingShapeInModal.vertices[Object.keys(currentEditingShapeInModal.vertices)[0]]?.x || 0) : 0;
                } else {
                    worldDspX = 0; worldDspY = 0; worldDspZ = 0;
                }

                const coordText = `(${worldDspX.toFixed(2)}, ${worldDspY.toFixed(2)}, ${worldDspZ.toFixed(2)})`;
                
                let textX = modalCanvasMouseX + 8;
                let textY = modalCanvasMouseY - 8;
                const textMetrics = ctx.measureText(coordText);
                const textWidth = textMetrics.width;
                const textHeight = 10; 

                if (textX + textWidth + 5 > canvas.width) textX = modalCanvasMouseX - textWidth - 8;
                if (textY - textHeight < 5) textY = modalCanvasMouseY + textHeight + 12; 
                if (textY + 5 > canvas.height) {
                    textY = modalCanvasMouseY - 8;
                    if (textY - textHeight < 5) textY = textHeight + 5;
                }

                console.log(`[CrosshairDebug] World Coords: (${worldDspX?.toFixed(2)}, ${worldDspY?.toFixed(2)}, ${worldDspZ?.toFixed(2)})`);
                console.log(`[CrosshairDebug] coordText: ${coordText}`);
                console.log(`[CrosshairDebug] Calculated text position before drawing: X=${textX}, Y=${textY}`);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.85)'; 
                ctx.fillRect(textX - 3, textY - textHeight - 3, textWidth + 6, textHeight + 6);
                ctx.fillStyle = 'black';
                ctx.fillText(coordText, textX, textY);
                ctx.restore();
            }
            console.log(`Finished drawing canvas for view: ${currentModalViewMode}`);
        }

        function drawTemporaryPoints(ctx, originX, originY, pixelsPerUnit, viewMode) {
            if (!temporaryNewPoints || temporaryNewPoints.length === 0) return;

            const canvas = document.getElementById('shapeDetailCanvas');
            if (!canvas) return;
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;

            ctx.fillStyle = 'blue'; // Màu cho điểm tạm thởi
            ctx.strokeStyle = 'darkblue';
            ctx.lineWidth = 1;

            temporaryNewPoints.forEach(point3D => {
                let pX, pY;
                // Chuyển đổi từ tọa độ 3D của điểm tạm thởi sang 2D trên canvas
                // dựa trên viewMode (tham số của hàm)
                if (viewMode === 'oxy') {
                    pX = originX + point3D.x * pixelsPerUnit;
                    pY = originY - point3D.y * pixelsPerUnit; // Y ngược lại trên canvas
                } else if (viewMode === 'oxz') {
                    pX = originX + point3D.x * pixelsPerUnit;
                    pY = originY - point3D.z * pixelsPerUnit; // Z thay cho Y
                } else if (viewMode === 'oyz') {
                    pX = originX + point3D.y * pixelsPerUnit; // Y thay cho X
                    pY = originY - point3D.z * pixelsPerUnit; // Z thay cho Y
                } else {
                    console.warn(`drawTemporaryPoints: Unknown viewMode '${viewMode}' for point ${JSON.stringify(point3D)}`);
                    return; // Bỏ qua điểm này nếu viewMode không xác định
                }

                // Vẽ điểm
                ctx.beginPath();
                ctx.arc(pX, pY, 5, 0, 2 * Math.PI); // Vẽ vòng tròn nhỏ
                ctx.fill();
                ctx.stroke();

                // Hiển thị tọa độ bên cạnh điểm (tọa độ thế giới 3D)
                ctx.fillStyle = 'black';
                ctx.font = '10px Arial';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'bottom';
                let coordText = '';
                if (viewMode === 'oxy') coordText = `(${point3D.x.toFixed(1)}, ${point3D.y.toFixed(1)})`;
                else if (viewMode === 'oxz') coordText = `(${point3D.x.toFixed(1)}, ${point3D.z.toFixed(1)})`;
                else if (viewMode === 'oyz') coordText = `(${point3D.y.toFixed(1)}, ${point3D.z.toFixed(1)})`;
                    ctx.fillText(coordText, pX + 7, pY - 7);
                }); // End of temporaryNewPoints.forEach
        } // End of function drawTemporaryPoints

        function setActiveViewButton(activeButtonId) {
            const buttonIds = ['viewOxyBtn', 'viewOxzBtn', 'viewOyzBtn'];
            buttonIds.forEach(id => {
                const btn = document.getElementById(id);
                if (btn) {
                    btn.classList.remove('btn-primary');
                    btn.classList.add('btn-outline-secondary');
                }
            });
            const activeBtnElement = document.getElementById(activeButtonId);
            if (activeBtnElement) {
                activeBtnElement.classList.remove('btn-outline-secondary');
                activeBtnElement.classList.add('btn-primary');
            }
        }

        function updateCanvasCursor() {
            const canvas = document.getElementById('shapeDetailCanvas');
            if (!canvas) return;

            if (isPanningWithRightMouse) {
                canvas.style.cursor = 'grabbing';
            } else {
                switch (currentModalInteractionMode) {
                    case 'addPoint':
                        canvas.style.cursor = 'crosshair';
                        break;
                    case 'moveObject':
                        canvas.style.cursor = 'move';
                        break;
                    default: // 'none' or other
                        canvas.style.cursor = 'default';
                        break;
                }
            }
            // console.log('[CursorUpdate] Canvas cursor set to:', canvas.style.cursor, 'Mode:', currentModalInteractionMode, 'Panning:', isPanningWithRightMouse);
        }

        function setActiveModalModeButton(activeButtonId) {
            console.log('[Debug] setActiveModalModeButton called with ID:', activeButtonId);
            const buttonIds = ['interactionModeNoneBtn', 'interactionModeAddPointBtn', 'interactionModeMoveObjectBtn'];

            buttonIds.forEach(id => {
                const btn = document.getElementById(id);
                if (btn) {
                    btn.classList.remove('btn-success'); 
                    btn.classList.add('btn-outline-secondary');
                }
            });

            const activeButtonElement = document.getElementById(activeButtonId);
            if (activeButtonElement) {
                activeButtonElement.classList.remove('btn-outline-secondary');
                activeButtonElement.classList.add('btn-success');
            }

            if (activeButtonId === 'interactionModeAddPointBtn') {
                currentModalInteractionMode = 'addPoint';
            } else if (activeButtonId === 'interactionModeMoveObjectBtn') {
                currentModalInteractionMode = 'moveObject';
            } else { // Default to 'none' for interactionModeNoneBtn or any other case
                currentModalInteractionMode = 'none';
            }
            // updateCanvasCursor() will be called regardless of panning, 
            // but its behavior changes based on isPanningWithRightMouse and currentModalInteractionMode.
            // If panning, it should ideally ensure the cursor is 'grabbing'.
            // If not panning, it sets cursor based on interaction mode.
            updateCanvasCursor();

            if (!isPanningWithRightMouse && showCrosshairAndCoords) {
                drawModalCanvas(); // Redraw for crosshair if not panning
            }
            console.log('[ModalMode] Interaction mode set to:', currentModalInteractionMode);
        }

        // Event listeners for modal interaction mode buttons
        document.getElementById('interactionModeNoneBtn')?.addEventListener('click', () => setActiveModalModeButton('interactionModeNoneBtn'));
        document.getElementById('interactionModeAddPointBtn')?.addEventListener('click', () => {
            setActiveModalModeButton('interactionModeAddPointBtn');
            console.log('[Debug] currentModalInteractionMode after click on AddPointBtn:', currentModalInteractionMode);
        });
        document.getElementById('interactionModeMoveObjectBtn')?.addEventListener('click', () => setActiveModalModeButton('interactionModeMoveObjectBtn'));
        
        // Event listeners cho các nút View Control trên Modal
        const viewOxyBtn = document.getElementById('viewOxyBtn');
        const viewOxzBtn = document.getElementById('viewOxzBtn');
        const viewOyzBtn = document.getElementById('viewOyzBtn');
        console.log('[ViewControlButtons] viewOxyBtn element:', viewOxyBtn);
        console.log('[ViewControlButtons] viewOxzBtn element:', viewOxzBtn);
        console.log('[ViewControlButtons] viewOyzBtn element:', viewOyzBtn);

        // Khai báo biến cho các element liên quan đến việc thêm điểm và thông báo
        const modalMessage = document.getElementById('modalMessage');
        const modalClickedPointCoordsContainer = document.getElementById('modalClickedPointCoordsContainer');
        const modalPointXInput = document.getElementById('modalPointX');
        const modalPointYInput = document.getElementById('modalPointY');
        const modalPointZInput = document.getElementById('modalPointZ');
        const modalAddBtn = document.getElementById('modalAddBtn'); // Nút "Thêm Điểm Tạm Thời"
        const modalSaveBtn = document.getElementById('saveModalBtn');

        if (modalAddBtn) {
            modalAddBtn.addEventListener('click', () => {
                console.log('[ModalEvent] "Thêm Điểm Tạm Thời" button clicked.');
                if (!currentEditingShapeInModal) {
                    showToast('Lỗi: Không có shape nào đang được chọn để thêm điểm.', 'error');
                    if (modalMessage) modalMessage.textContent = 'Lỗi: Chưa chọn shape.';
                    return;
                }
                const x = parseFloat(modalPointXInput.value);
                const y = parseFloat(modalPointYInput.value);
                const z = parseFloat(modalPointZInput.value);

                if (isNaN(x) || isNaN(y) || isNaN(z)) {
                    showToast('Vui lòng nhập tọa độ hợp lệ cho điểm.', 'warning');
                    if (modalMessage) modalMessage.textContent = 'Tọa độ không hợp lệ.';
                    return;
                }
                const newPoint = { x, y, z };
                temporaryNewPoints.push(newPoint);
                console.log('[ModalEvent] Added temporary point:', newPoint, 'Total temp points:', temporaryNewPoints.length);
                
                if (modalMessage) modalMessage.textContent = ''; // Xóa thông báo cũ
                if (modalMessage) modalMessage.textContent = `Đã thêm: (${x.toFixed(2)}, ${y.toFixed(2)}, ${z.toFixed(2)}). Tổng điểm tạm: ${temporaryNewPoints.length}`;
                
                drawModalCanvas(); // Vẽ lại canvas để hiển thị điểm mới
            });
        }

        // Event listener cho việc click trên canvas để thêm điểm
        const shapeDetailCanvasForClick = document.getElementById('shapeDetailCanvas');
        if (shapeDetailCanvasForClick) {
            shapeDetailCanvasForClick.addEventListener('click', (event) => {
                if (currentModalInteractionMode !== 'addPoint' || !currentEditingShapeInModal) return;

                const canvasRect = shapeDetailCanvasForClick.getBoundingClientRect();
                
                // Tọa độ chuột gốc so với viewport
                // console.log(`[DebugOffset] Mouse Click: clientX=${event.clientX}, clientY=${event.clientY}`);
                // console.log(`[DebugOffset] Canvas Rect: left=${canvasRect.left}, top=${canvasRect.top}, width=${canvasRect.width}, height=${canvasRect.height}`);

                // Tọa độ chuột so với góc trên bên trái của phần tử canvas
                let mouseX_relative_to_canvas_element = event.clientX - canvasRect.left;
                let mouseY_relative_to_canvas_element = event.clientY - canvasRect.top;

                // console.log(`[DebugOffset] Mouse relative to canvas element: x=${mouseX_relative_to_canvas_element}, y=${mouseY_relative_to_canvas_element}`);
                // console.log(`[DebugOffset] Canvas drawing surface size: width=${shapeDetailCanvasForClick.width}, height=${shapeDetailCanvasForClick.height}`);

                // Điều chỉnh tọa độ chuột nếu kích thước hiển thị của canvas khác với kích thước bề mặt vẽ
                // (ví dụ: khi canvas được scale bằng CSS)
                const scaleX = shapeDetailCanvasForClick.width / canvasRect.width;
                const scaleY = shapeDetailCanvasForClick.height / canvasRect.height;
                
                const finalCanvasX = mouseX_relative_to_canvas_element * scaleX;
                const finalCanvasY = mouseY_relative_to_canvas_element * scaleY;

                // console.log(`[DebugOffset] Scaling factors: scaleX=${scaleX}, scaleY=${scaleY}`);
                // console.log(`[DebugOffset] Final scaled mouse coords on canvas: x=${finalCanvasX}, y=${finalCanvasY}`);

                // modalOriginX and modalOriginY are calculated in calculateAndUpdateModalCanvasViewParams
                // and represent the canvas coordinates of the world origin (0,0) for the current view.
                let point3D = { x: 0, y: 0, z: 0 };

                if (currentModalViewMode === 'oxy') {
                    point3D.x = (finalCanvasX - modalOriginX) / PIXELS_PER_UNIT;
                    point3D.y = (modalOriginY - finalCanvasY) / PIXELS_PER_UNIT; // modalOriginY already accounts for inverted Y
                    point3D.z = 0;
                } else if (currentModalViewMode === 'oxz') {
                    point3D.x = (finalCanvasX - modalOriginX) / PIXELS_PER_UNIT;
                    point3D.z = (modalOriginY - finalCanvasY) / PIXELS_PER_UNIT; // modalOriginY for Z in OXZ view
                    point3D.y = 0;
                } else if (currentModalViewMode === 'oyz') {
                    point3D.y = (finalCanvasX - modalOriginX) / PIXELS_PER_UNIT; // modalOriginX for Y in OYZ view (first coord)
                    point3D.z = (modalOriginY - finalCanvasY) / PIXELS_PER_UNIT; // modalOriginY for Z in OYZ view (second coord)
                    point3D.x = 0;
                }
                
                point3D.x = parseFloat(point3D.x.toFixed(2));
                point3D.y = parseFloat(point3D.y.toFixed(2));
                point3D.z = parseFloat(point3D.z.toFixed(2));

                // console.log(`[DebugOffset] World coords before PIXELS_PER_UNIT: x_raw=${(finalCanvasX - originCanvasX)}, y_raw=${(originCanvasY - finalCanvasY)} (for Oxy)`);
                console.log(`[AddPoint] Attempting to add point. Mode: ${currentModalViewMode}, FinalCanvasClick:(${finalCanvasX.toFixed(2)},${finalCanvasY.toFixed(2)}), PIXELS: ${PIXELS_PER_UNIT.toFixed(4)}`);
                console.log('[AddPoint] Calculated 3D point:', point3D);

                // Diagnostic: Convert back to canvas coordinates to check consistency
                let recalculatedCanvasX, recalculatedCanvasY;
                if (currentModalViewMode === 'oxy') {
                    recalculatedCanvasX = modalOriginX + point3D.x * PIXELS_PER_UNIT;
                    recalculatedCanvasY = modalOriginY - point3D.y * PIXELS_PER_UNIT;
                } else if (currentModalViewMode === 'oxz') {
                    recalculatedCanvasX = modalOriginX + point3D.x * PIXELS_PER_UNIT;
                    recalculatedCanvasY = modalOriginY - point3D.z * PIXELS_PER_UNIT;
                } else if (currentModalViewMode === 'oyz') {
                    recalculatedCanvasX = modalOriginX + point3D.y * PIXELS_PER_UNIT;
                    recalculatedCanvasY = modalOriginY - point3D.z * PIXELS_PER_UNIT;
                }
                console.log(`[CoordCheck] Original click (scaled): (${finalCanvasX.toFixed(2)}, ${finalCanvasY.toFixed(2)})`);
                console.log(`[CoordCheck] World point: (${point3D.x.toFixed(2)}, ${point3D.y.toFixed(2)}, ${point3D.z.toFixed(2)})`);
                console.log(`[CoordCheck] Recalculated canvas coords: (${recalculatedCanvasX.toFixed(2)}, ${recalculatedCanvasY.toFixed(2)})`);
                console.log(`[CoordCheck] modalOrigin: (${modalOriginX.toFixed(2)}, ${modalOriginY.toFixed(2)}), PPU: ${PIXELS_PER_UNIT.toFixed(4)}`);

                temporaryNewPoints.push(point3D);
                drawModalCanvas();
                selectedTemporaryPointIndex = temporaryNewPoints.length - 1;
                console.log(`[CanvasClick] Added temporary point: (${point3D.x}, ${point3D.y}, ${point3D.z}), view: ${currentModalViewMode}. Index: ${selectedTemporaryPointIndex}`);
                // drawTemporaryPoints(shapeCanvasCtx); // Đã được gọi trong drawModalCanvas(), không cần gọi lại ở đây

                // Hiển thị và điền dữ liệu vào input tọa độ
                console.log('[CanvasClick] Attempting to show coordinate inputs. Current mode:', currentModalInteractionMode);
                console.log('[CanvasClick] modalClickedPointCoordsContainer exists:', !!modalClickedPointCoordsContainer);
                if (modalClickedPointCoordsContainer) {
                    modalClickedPointCoordsContainer.style.display = 'block';
                    // Sử dụng getComputedStyle để kiểm tra style thực tế được áp dụng
                    console.log('[CanvasClick] Set display to block. Computed display style:', window.getComputedStyle(modalClickedPointCoordsContainer).display);
                } else {
                    console.error('[CanvasClick] modalClickedPointCoordsContainer is null or undefined!');
                }

                if (modalPointXInput) modalPointXInput.value = point3D.x.toFixed(2);
                if (modalPointYInput) modalPointYInput.value = point3D.y.toFixed(2);
                if (modalPointZInput) modalPointZInput.value = point3D.z.toFixed(2);
                console.log('[CanvasClick] Populated input fields.');

                // Gắn (hoặc cập nhật) event listeners
                [modalPointXInput, modalPointYInput, modalPointZInput].forEach(input => {
                    if (input) {
                        // Gỡ bỏ listener cũ để tránh bị gọi nhiều lần
                        input.removeEventListener('input', updateTemporaryPointFromInputs);
                        input.addEventListener('input', updateTemporaryPointFromInputs);
                    }
                });
            });
        }


        // Event listener for mouse move on modal canvas to update cursor
        const shapeDetailCanvasForCursorUpdate = document.getElementById('shapeDetailCanvas');
        if (shapeDetailCanvasForCursorUpdate) {
            shapeDetailCanvasForCursorUpdate.addEventListener('mousemove', (event) => {
                if (showCrosshairAndCoords) {
                    const coords = getScaledMouseCoordinatesOnCanvas(event, shapeDetailCanvasForCursorUpdate);
                    modalCanvasMouseX = coords.x;
                    modalCanvasMouseY = coords.y;
                } else {
                    modalCanvasMouseX = null;
                    modalCanvasMouseY = null;
                }

                if (!isPanningWithRightMouse) {
                    updateCanvasCursor(); // Update cursor based on mode if not panning
                    if (showCrosshairAndCoords && currentModalInteractionMode === 'addPoint') {
                        drawModalCanvas(); // Redraw for crosshair movement
                    }
                } else {
                    // Panning cursor is handled by global mousemove. 
                    // drawModalCanvas is also called by global mousemove during panning.
                    // We've updated modalCanvasMouseX/Y above, so the crosshair during pan will use it.
                    // No explicit call to updateCanvasCursor() or drawModalCanvas() here to avoid conflict/redundancy.
                }
            });

            shapeDetailCanvasForCursorUpdate.addEventListener('mouseleave', () => {
                if (showCrosshairAndCoords && currentModalInteractionMode === 'addPoint') {
                    modalCanvasMouseX = null;
                    modalCanvasMouseY = null;
                    drawModalCanvas(); // Redraw to remove crosshair
                }
            });
        }

// Event listener for mouse wheel zoom on modal canvas
const shapeDetailCanvasForZoom = document.getElementById('shapeDetailCanvas');
if (shapeDetailCanvasForZoom) {
    shapeDetailCanvasForZoom.addEventListener('wheel', (event) => {
        event.preventDefault(); // Prevent page scrolling

        if (!currentEditingShapeInModal) return;

        const { x: mouseX, y: mouseY } = getScaledMouseCoordinatesOnCanvas(event, shapeDetailCanvasForZoom);

        let worldPointBeforeZoomX_axis1, worldPointBeforeZoomY_axis2;

        // Determine world coordinates under mouse before zoom based on the current view mode
        // The first component (worldPointBeforeZoomX_axis1) always corresponds to the first axis of the view mode (X in Oxy/Oxz, Y in Oyz)
        // The second component (worldPointBeforeZoomY_axis2) always corresponds to the second axis of the view mode (Y in Oxy, Z in Oxz/Oyz)
        worldPointBeforeZoomX_axis1 = (mouseX - modalOriginX) / PIXELS_PER_UNIT;
        worldPointBeforeZoomY_axis2 = (modalOriginY - mouseY) / PIXELS_PER_UNIT; // modalOriginY handles canvas Y inversion

        const zoomFactor = event.deltaY < 0 ? 1.1 : 1 / 1.1; // Zoom in or out
        let newPixelsPerUnit = PIXELS_PER_UNIT * zoomFactor;

        const MIN_PPU_CLAMP = 0.001;
        const MAX_PPU_CLAMP = 500;
        newPixelsPerUnit = Math.max(MIN_PPU_CLAMP, Math.min(newPixelsPerUnit, MAX_PPU_CLAMP));
        
        if (Math.abs(newPixelsPerUnit - PIXELS_PER_UNIT) < 0.00001) {
            return; // No significant change in PPU (e.g., hit clamp limit)
        }

        // Update origins to keep the world point under mouse stationary
        modalOriginX = mouseX - worldPointBeforeZoomX_axis1 * newPixelsPerUnit;
        modalOriginY = mouseY + worldPointBeforeZoomY_axis2 * newPixelsPerUnit;

        PIXELS_PER_UNIT = newPixelsPerUnit;

        console.log(`[Zoom] PPU: ${PIXELS_PER_UNIT.toFixed(4)}, Origin: (${modalOriginX.toFixed(2)}, ${modalOriginY.toFixed(2)})`);
        drawModalCanvas();

        // Restore cursor after zoom if not panning
            updateCanvasCursor();
        }
    , { passive: false }); // passive: false to allow preventDefault
}

// --- Pan Functionality Start ---
if (shapeDetailCanvasForZoom) { // Reuse the canvas element from zoom logic
    // 1. Prevent context menu on right-click
    shapeDetailCanvasForZoom.addEventListener('contextmenu', (event) => {
        event.preventDefault();
    });

    // 2. Mousedown to initiate panning
    shapeDetailCanvasForZoom.addEventListener('mousedown', (event) => {
        if (event.button === 2) { // Right mouse button
            if (!currentEditingShapeInModal) return;
            isPanningWithRightMouse = true;
            const { x: mouseX, y: mouseY } = getScaledMouseCoordinatesOnCanvas(event, shapeDetailCanvasForZoom);
            lastPanX = mouseX;
            lastPanY = mouseY;
            shapeDetailCanvasForZoom.style.cursor = 'grabbing';
            // console.log('[Pan] Mousedown - Start Panning');
        }
    });
}

// 3. Mousemove on document to pan (listens on document to allow panning even if mouse leaves canvas)
document.addEventListener('mousemove', (event) => {
    if (isPanningWithRightMouse) {
        if (!currentEditingShapeInModal || !shapeDetailCanvasForZoom) { // Ensure canvas context still valid
            isPanningWithRightMouse = false;
            if(shapeDetailCanvasForZoom) shapeDetailCanvasForZoom.style.cursor = 'default';
            return;
        }
        const { x: currentMouseX, y: currentMouseY } = getScaledMouseCoordinatesOnCanvas(event, shapeDetailCanvasForZoom);
        
        const deltaX = currentMouseX - lastPanX;
        const deltaY = currentMouseY - lastPanY;

        modalOriginX += deltaX;
        modalOriginY += deltaY;

        lastPanX = currentMouseX;
        lastPanY = currentMouseY;

        // console.log(`[Pan] Mousemove - Delta: (${deltaX.toFixed(2)}, ${deltaY.toFixed(2)}), New Origin: (${modalOriginX.toFixed(2)}, ${modalOriginY.toFixed(2)})`);
            if (showCrosshairAndCoords && shapeDetailCanvasForZoom) { // shapeDetailCanvasForZoom is the modal canvas
                const rect = shapeDetailCanvasForZoom.getBoundingClientRect();
                // Update modalCanvasMouseX/Y based on the global event's clientX/Y
                // relative to the canvas, as the mouse might be outside the canvas while panning.
                modalCanvasMouseX = event.clientX - rect.left;
                modalCanvasMouseY = event.clientY - rect.top;
            }
            drawModalCanvas();
    }
});

// 4. Mouseup on document to stop panning
document.addEventListener('mouseup', (event) => {
    if (event.button === 2 && isPanningWithRightMouse) { // Right mouse button released
        isPanningWithRightMouse = false;
        if (shapeDetailCanvasForZoom) { // Check if canvas element exists
            updateCanvasCursor();
        }
        // console.log('[Pan] Mouseup - Stop Panning');
    }
});
// --- Pan Functionality End ---

        if (viewOxyBtn) {
            viewOxyBtn.addEventListener('click', () => {
                console.log('[ViewControl] viewOxyBtn clicked. Current shape:', currentEditingShapeInModal, 'Mode before change:', currentModalViewMode);
                if (!currentEditingShapeInModal) {
                    console.warn('[ViewControl] viewOxyBtn: No currentEditingShapeInModal. Aborting.');
                    return;
                }
                currentModalViewMode = 'oxy';
                console.log('[ViewControl] viewOxyBtn: Mode set to oxy. Calling setActiveViewButton and drawModalCanvas.');
                setActiveViewButton('viewOxyBtn');
                drawModalCanvas();
            });
        }
        if (viewOxzBtn) {
            viewOxzBtn.addEventListener('click', () => {
                console.log('[ViewControl] viewOxzBtn clicked. Current shape:', currentEditingShapeInModal, 'Mode before change:', currentModalViewMode);
                if (!currentEditingShapeInModal) {
                    console.warn('[ViewControl] viewOxzBtn: No currentEditingShapeInModal. Aborting.');
                    return;
                }
                currentModalViewMode = 'oxz';
                console.log('[ViewControl] viewOxzBtn: Mode set to oxz. Calling setActiveViewButton and drawModalCanvas.');
                setActiveViewButton('viewOxzBtn');
                drawModalCanvas();
            });
        }
        if (viewOyzBtn) {
            viewOyzBtn.addEventListener('click', () => {
                console.log('[ViewControl] viewOyzBtn clicked. Current shape:', currentEditingShapeInModal, 'Mode before change:', currentModalViewMode);
                if (!currentEditingShapeInModal) {
                    console.warn('[ViewControl] viewOyzBtn: No currentEditingShapeInModal. Aborting.');
                    return;
                }
                currentModalViewMode = 'oyz';
                console.log('[ViewControl] viewOyzBtn: Mode set to oyz. Calling setActiveViewButton and drawModalCanvas.');
                setActiveViewButton('viewOyzBtn');
                drawModalCanvas();
            });
        }

        window.addEventListener('keydown', (event) => {
            const shapeCanvasModal = document.getElementById('shapeCanvasModal');
            if (event.key === 'Escape' && shapeCanvasModal && shapeCanvasModal.style.display === 'flex') {
                closeShapeEditorModal();
            }
        });
    }); // Đóng DOMContentLoaded listener
    </script>
    <!-- Fullscreen Shape Canvas Modal -->
    <div id="shapeCanvasModal" class="fullscreen-modal">
        <div class="modal-content-wrapper">
            <div class="modal-header-controls">
                 <h5 id="shapeCanvasModalTitle">Shape Canvas Editor</h5>
                 <div class="modal-header-button-groups" style="display: flex; gap: 15px; margin: 0 auto;">
                    <div class="btn-group btn-group-sm" role="group" aria-label="View Controls">
                        <button type="button" class="btn btn-outline-secondary" id="viewOxyBtn" title="Chế độ xem Oxy">Oxy</button>
                        <button type="button" class="btn btn-outline-secondary" id="viewOxzBtn" title="Chế độ xem Oxz">Oxz</button>
                        <button type="button" class="btn btn-outline-secondary" id="viewOyzBtn" title="Chế độ xem Oyz">Oyz</button>
                    </div>
                    <div class="btn-group btn-group-sm" role="group" aria-label="Interaction Mode Controls">
                        <button type="button" class="btn btn-outline-secondary" id="interactionModeNoneBtn" title="Chế độ chọn (Không làm gì)">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-cursor-fill" viewBox="0 0 16 16"> <path d="M14.082 2.182a.5.5 0 0 1 .103.557L8.528 15.467a.5.5 0 0 1-.917-.007L5.57 10.694.803 8.652a.5.5 0 0 1-.006-.916l12.728-5.657a.5.5 0 0 1 .556.103z"/> </svg>
                            Chọn
                        </button>
                        <button type="button" class="btn btn-outline-secondary" id="interactionModeAddPointBtn" title="Chế độ thêm điểm">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-crosshair" viewBox="0 0 16 16"> <path d="M8.5.5a.5.5 0 0 0-1 0v.518A7 7 0 0 0 1.018 7.5H.5a.5.5 0 0 0 0 1h.518A7 7 0 0 0 7.5 14.982v.518a.5.5 0 0 0 1 0v-.518A7 7 0 0 0 14.982 8.5h.518a.5.5 0 0 0 0-1h-.518A7 7 0 0 0 8.5 1.018V.5Zm-6.48 7A6 6 0 0 1 7.5 2.02v10.96A6 6 0 0 1 2.02 8Zm11.96 0A6 6 0 0 1 8.5 13.98V2.02A6 6 0 0 1 13.98 8Z"/> </svg>
                            Thêm Điểm
                        </button>
                        <button type="button" class="btn btn-outline-secondary" id="interactionModeMoveObjectBtn" title="Chế độ di chuyển điểm/đối tượng">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-hand-index-thumb" viewBox="0 0 16 16"> <path d="M6.75 1a.75.75 0 0 1 .75.75V8a.5.5 0 0 0 1 0V5.467l.086-.004c.317-.012.637-.008.949.004.312.012.624.03.928.058.283.027.564.064.83.115.27.052.53.115.776.193.248.079.484.172.702.278l.028.014c.218.104.422.218.612.34.19.122.364.258.52.408.158.15.295.315.413.49.117.177.212.365.284.562.072.195.122.4.146.612.024.21.028.428.02.638a4.007 4.007 0 0 1-.12.967c-.065.26-.15.507-.253.739-.104.233-.222.453-.356.657-.133.205-.28.392-.44.561-.16.17-.334.32-.524.452-.19.132-.392.243-.606.331a5.03 5.03 0 0 1-.707.215c-.22.061-.448.106-.68.132-.233.026-.47.038-.708.038-.313 0-.614-.014-.91-.043l-.02-.002-.02-.002A1.5 1.5 0 0 1 8 12.5V8.865a.5.5 0 0 0-.5-.5H4.25a.75.75 0 0 1-.75-.75V1.75A.75.75 0 0 1 4.25 1h2.5ZM4.25 8.115H6.5V12h1.5a.5.5 0 0 0 .478-.356c.09-.22.19-.43.292-.626.102-.197.21-.388.322-.572.113-.184.23-.357.348-.518.12-.162.235-.312.342-.45.108-.138.206-.263.295-.375.09-.113.17-.215.24-.304.07-.09.128-.17.176-.238.048-.07.085-.127.11-.175.026-.048.04-.086.044-.114.005-.028.002-.047-.003-.057a.316.316 0 0 0-.06-.137c-.03-.044-.068-.08-.11-.11-.043-.03-.09-.054-.14-.073a.97.97 0 0 0-.188-.09c-.077-.027-.158-.048-.24-.062-.084-.014-.17-.023-.258-.028-.09-.005-.178-.007-.266-.007l-.035.001-.031.001c-.25-.006-.5-.002-.732.007l-.07.003-.026.001H7.5V1.75h-3.5v6.365Z"/> </svg>
                            Di Chuyển Điểm
                        </button>
                    </div>
                 </div>
                 <div class="btn-group btn-group-sm" role="group" aria-label="Save Cancel Controls">
                        <button type="button" class="btn btn-success" id="saveModalBtn" onclick="saveAndCloseModal()" title="Lưu thay đổi">Lưu</button>
                        <button type="button" class="btn btn-secondary" id="cancelModalBtn" onclick="closeShapeEditorModal()" title="Hủy bỏ">Hủy</button>
                    </div>
            </div>
            <div class="modal-main-content">
                <div id="modalCanvasContainer" class="modal-canvas-section">
                    <canvas id="shapeDetailCanvas"></canvas>
                </div>
                <div id="modalInfoSection" class="modal-info-section">
                    <div id="modalInfoContent"> <!-- Div for dynamic content -->
                       <h4>Thông tin</h4>
                       <p>Nội dung thông tin sẽ được hiển thị ở đây khi một shape được chọn và modal được mở.</p>
                       <div id="modalClickedPointCoordsContainer" style="display:none; margin-top: 10px;">
                           <h5>Tọa độ điểm đang chọn:</h5>
                           <div>
                               <label for="modalPointX" style="display: inline-block; width: 20px;">X:</label>
                               <input type="number" id="modalPointX" step="any" style="width: calc(100% - 30px); margin-bottom: 5px;">
                           </div>
                           <div>
                               <label for="modalPointY" style="display: inline-block; width: 20px;">Y:</label>
                               <input type="number" id="modalPointY" step="any" style="width: calc(100% - 30px); margin-bottom: 5px;">
                           </div>
                           <div>
                               <label for="modalPointZ" style="display: inline-block; width: 20px;">Z:</label>
                               <input type="number" id="modalPointZ" step="any" style="width: calc(100% - 30px);">
                           </div>
                       </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</body>

</html>